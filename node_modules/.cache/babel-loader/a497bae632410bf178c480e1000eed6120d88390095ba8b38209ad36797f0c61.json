{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nexport const useGraphClipboard = ({\n  graph,\n  selectedNodes,\n  selectedContainerIds,\n  selectedEdgeId,\n  onGraphChange,\n  clearSelection,\n  setSelectedNodes,\n  setSelectedContainerIds,\n  setSelectedEdgeId,\n  onStartEditing\n}) => {\n  _s();\n  const [clipboard, setClipboard] = useState(null);\n\n  // Helper: Clears everything including edges\n  const clearAllSelection = () => {\n    // TODO: use clearSelection from useGraphSelection\n    clearSelection(); // Clears nodes/containers via parent logic\n    setSelectedEdgeId(null);\n  };\n  const selectAll = () => {\n    const allNodesIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodesIds);\n    setSelectedContainerIds(allContainerIds);\n    // Usually we don't select all edges in \"Ctrl+A\" as it clutters, \n    // but if you want to, you would add logic here.\n  };\n  const deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0 && !selectedEdgeId) return;\n    const newGraph = graph.clone();\n\n    // 1. Delete Nodes\n    selectedNodes.forEach(id => newGraph.removeNode(id));\n\n    // 2. Delete Containers\n    selectedContainerIds.forEach(id => newGraph.removeContainer(id));\n\n    // 3. Delete Selected Edge\n    if (selectedEdgeId) {\n      delete newGraph.edgesById[selectedEdgeId];\n    }\n    onGraphChange(newGraph);\n    clearAllSelection();\n  };\n  const copy = e => {\n    e.preventDefault();\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n\n    // Only copy edges if both ends are selected (Standard logic)\n    // OR if the edge itself is explicitly selected (Optional enhancement)\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge => allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId) || edge.id === selectedEdgeId);\n    const clipboardData = {\n      nodes: nodesToCopy,\n      containers: containersToCopy,\n      edges: edgesToCopy\n    };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n  const paste = e => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      const idMap = new Map();\n      const newSelectedNodes = new Set();\n      const newSelectedContainers = new Set();\n\n      // 1. Paste Containers\n      data.containers.forEach(c => {\n        const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(c.id, newId);\n        newGraph.containersById[newId] = {\n          ...c,\n          id: newId,\n          position: {\n            x: c.position.x + 20,\n            y: c.position.y + 20\n          },\n          nodeIds: [],\n          childContainerIds: []\n        };\n        newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach(n => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = {\n          ...n,\n          id: newId,\n          position: {\n            x: n.position.x + 20,\n            y: n.position.y + 20\n          },\n          parentId: n.parentId ? idMap.get(n.parentId) : undefined\n        };\n        newSelectedNodes.add(newId);\n        if (n.parentId && idMap.has(n.parentId)) {\n          var _newGraph$containersB;\n          (_newGraph$containersB = newGraph.containersById[idMap.get(n.parentId)]) === null || _newGraph$containersB === void 0 ? void 0 : _newGraph$containersB.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges\n      data.edges.forEach(e => {\n        // We attempt to remap, but if the nodes weren't copied, we try to keep original IDs \n        // (This allows copying an edge between two existing nodes if needed, though rare in this flow)\n        const newSource = idMap.get(e.sourceNodeId) || e.sourceNodeId;\n        const newTarget = idMap.get(e.targetNodeId) || e.targetNodeId;\n\n        // Ensure valid endpoints exist in the new graph\n        const sourceExists = newGraph.nodesById[newSource] || newGraph.containersById[newSource];\n        const targetExists = newGraph.nodesById[newTarget] || newGraph.containersById[newTarget];\n        if (sourceExists && targetExists) {\n          const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n          newGraph.edgesById[newEdgeId] = {\n            ...e,\n            id: newEdgeId,\n            sourceNodeId: newSource,\n            targetNodeId: newTarget\n          };\n        }\n      });\n      onGraphChange(newGraph);\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n      setSelectedEdgeId(null); // Deselect old edge\n    } catch (err) {\n      console.error(\"Paste failed\", err);\n    }\n  };\n\n  // Keyboard Listener\n  useEffect(() => {\n    const handleKeyDown = e => {\n      const target = e.target;\n      // Ignore if typing in an input\n      if (target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\") return;\n\n      // 1. Delete\n      if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        deleteSelected();\n        return;\n      }\n\n      // 2. Escape (Deselect All)\n      if (e.key === \"Escape\") {\n        clearAllSelection();\n        return;\n      }\n\n      // 3. Modifiers (Ctrl/Cmd)\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") selectAll();\n        if (e.key === \"c\") copy(e);\n        if (e.key === \"x\") {\n          copy(e);\n          deleteSelected();\n        }\n        if (e.key === \"v\") paste(e);\n        return;\n      }\n\n      // 4. Direct Typing -> Edit Edge Name\n      // Conditions: Single char, No modifiers, Only 1 edge selected, No nodes/containers selected\n      if (e.key.length === 1 && selectedEdgeId && selectedNodes.size === 0 && selectedContainerIds.size === 0) {\n        // Prevent default (e.g. space scrolling)\n        if (e.key === \" \") e.preventDefault();\n        const newGraph = graph.clone();\n        const edge = newGraph.edgesById[selectedEdgeId];\n        if (edge) {\n          // Update the label to the typed character immediately\n          edge.label = e.key;\n          onGraphChange(newGraph);\n\n          // Trigger the Editor UI to open\n          if (onStartEditing) onStartEditing(selectedEdgeId);\n        }\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, selectedEdgeId, clipboard]);\n  return {\n    deleteSelected,\n    copy,\n    paste\n  };\n};\n_s(useGraphClipboard, \"1H+Q2r5p85WO+8m7YfmWK/uQKVg=\");","map":{"version":3,"names":["useState","useEffect","useGraphClipboard","graph","selectedNodes","selectedContainerIds","selectedEdgeId","onGraphChange","clearSelection","setSelectedNodes","setSelectedContainerIds","setSelectedEdgeId","onStartEditing","_s","clipboard","setClipboard","clearAllSelection","selectAll","allNodesIds","Set","Object","keys","nodesById","allContainerIds","containersById","deleteSelected","size","newGraph","clone","forEach","id","removeNode","removeContainer","edgesById","copy","e","preventDefault","nodesToCopy","values","filter","n","has","containersToCopy","c","allSelectedIds","edgesToCopy","edge","sourceNodeId","targetNodeId","clipboardData","nodes","containers","edges","JSON","stringify","paste","data","parse","idMap","Map","newSelectedNodes","newSelectedContainers","newId","crypto","randomUUID","slice","set","position","x","y","nodeIds","childContainerIds","add","parentId","get","undefined","_newGraph$containersB","push","newSource","newTarget","sourceExists","targetExists","newEdgeId","err","console","error","handleKeyDown","target","tagName","key","ctrlKey","metaKey","length","label","window","addEventListener","removeEventListener"],"sources":["/home/belac/sysFlow/src/hooks/useGraphClipboard.ts"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\n\ninterface UseGraphClipboardProps {\n  graph: GraphModel;\n  selectedNodes: Set<string>;\n  selectedContainerIds: Set<string>;\n  selectedEdgeId: string | null; // NEW: Track edge\n  onGraphChange: (newGraph: GraphModel) => void;\n  clearSelection: () => void;\n  setSelectedNodes: (ids: Set<string>) => void;\n  setSelectedContainerIds: (ids: Set<string>) => void;\n  setSelectedEdgeId: (id: string | null) => void; // NEW: To clear edge\n  onStartEditing?: (id: string) => void; // NEW: To trigger UI editor\n}\n\nexport const useGraphClipboard = ({\n  graph,\n  selectedNodes,\n  selectedContainerIds,\n  selectedEdgeId,\n  onGraphChange,\n  clearSelection,\n  setSelectedNodes,\n  setSelectedContainerIds,\n  setSelectedEdgeId,\n  onStartEditing,\n}: UseGraphClipboardProps) => {\n  const [clipboard, setClipboard] = useState<string | null>(null);\n\n  // Helper: Clears everything including edges\n  const clearAllSelection = () => { // TODO: use clearSelection from useGraphSelection\n    clearSelection(); // Clears nodes/containers via parent logic\n    setSelectedEdgeId(null);\n  };\n\n  const selectAll = () => {\n    const allNodesIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodesIds);\n    setSelectedContainerIds(allContainerIds);\n    // Usually we don't select all edges in \"Ctrl+A\" as it clutters, \n    // but if you want to, you would add logic here.\n  };\n\n  const deleteSelected = () => {\n    if (\n      selectedNodes.size === 0 &&\n      selectedContainerIds.size === 0 &&\n      !selectedEdgeId\n    )\n      return;\n\n    const newGraph = graph.clone();\n\n    // 1. Delete Nodes\n    selectedNodes.forEach((id) => newGraph.removeNode(id));\n\n    // 2. Delete Containers\n    selectedContainerIds.forEach((id) => newGraph.removeContainer(id));\n\n    // 3. Delete Selected Edge\n    if (selectedEdgeId) {\n      delete newGraph.edgesById[selectedEdgeId];\n    }\n\n    onGraphChange(newGraph);\n    clearAllSelection();\n  };\n\n  const copy = (e: KeyboardEvent) => {\n    e.preventDefault();\n    const nodesToCopy = Object.values(graph.nodesById).filter((n) =>\n      selectedNodes.has(n.id)\n    );\n    const containersToCopy = Object.values(graph.containersById).filter((c) =>\n      selectedContainerIds.has(c.id)\n    );\n\n    // Only copy edges if both ends are selected (Standard logic)\n    // OR if the edge itself is explicitly selected (Optional enhancement)\n    const allSelectedIds = new Set([\n      ...selectedNodes,\n      ...selectedContainerIds,\n    ]);\n    \n    const edgesToCopy = Object.values(graph.edgesById).filter(\n      (edge) =>\n        (allSelectedIds.has(edge.sourceNodeId) &&\n         allSelectedIds.has(edge.targetNodeId)) ||\n        edge.id === selectedEdgeId\n    );\n\n    const clipboardData = {\n      nodes: nodesToCopy,\n      containers: containersToCopy,\n      edges: edgesToCopy,\n    };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n\n  const paste = (e: KeyboardEvent) => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      const idMap = new Map<string, string>();\n      const newSelectedNodes = new Set<string>();\n      const newSelectedContainers = new Set<string>();\n\n      // 1. Paste Containers\n      data.containers.forEach((c: any) => {\n        const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(c.id, newId);\n        newGraph.containersById[newId] = {\n          ...c,\n          id: newId,\n          position: { x: c.position.x + 20, y: c.position.y + 20 },\n          nodeIds: [],\n          childContainerIds: [],\n        };\n        newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach((n: any) => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = {\n          ...n,\n          id: newId,\n          position: { x: n.position.x + 20, y: n.position.y + 20 },\n          parentId: n.parentId ? idMap.get(n.parentId) : undefined,\n        };\n        newSelectedNodes.add(newId);\n        if (n.parentId && idMap.has(n.parentId)) {\n          newGraph.containersById[idMap.get(n.parentId)!]?.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges\n      data.edges.forEach((e: any) => {\n        // We attempt to remap, but if the nodes weren't copied, we try to keep original IDs \n        // (This allows copying an edge between two existing nodes if needed, though rare in this flow)\n        const newSource = idMap.get(e.sourceNodeId) || e.sourceNodeId;\n        const newTarget = idMap.get(e.targetNodeId) || e.targetNodeId;\n\n        // Ensure valid endpoints exist in the new graph\n        const sourceExists = newGraph.nodesById[newSource] || newGraph.containersById[newSource];\n        const targetExists = newGraph.nodesById[newTarget] || newGraph.containersById[newTarget];\n\n        if (sourceExists && targetExists) {\n          const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n          newGraph.edgesById[newEdgeId] = {\n            ...e,\n            id: newEdgeId,\n            sourceNodeId: newSource,\n            targetNodeId: newTarget,\n          };\n        }\n      });\n\n      onGraphChange(newGraph);\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n      setSelectedEdgeId(null); // Deselect old edge\n    } catch (err) {\n      console.error(\"Paste failed\", err);\n    }\n  };\n\n  // Keyboard Listener\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement;\n      // Ignore if typing in an input\n      if (target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\") return;\n\n      // 1. Delete\n      if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        deleteSelected();\n        return;\n      }\n\n      // 2. Escape (Deselect All)\n      if (e.key === \"Escape\") {\n        clearAllSelection();\n        return;\n      }\n\n      // 3. Modifiers (Ctrl/Cmd)\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") selectAll();\n        if (e.key === \"c\") copy(e);\n        if (e.key === \"x\") {\n          copy(e);\n          deleteSelected();\n        }\n        if (e.key === \"v\") paste(e);\n        return;\n      }\n\n      // 4. Direct Typing -> Edit Edge Name\n      // Conditions: Single char, No modifiers, Only 1 edge selected, No nodes/containers selected\n      if (\n        e.key.length === 1 && \n        selectedEdgeId && \n        selectedNodes.size === 0 && \n        selectedContainerIds.size === 0\n      ) {\n         // Prevent default (e.g. space scrolling)\n         if(e.key === \" \") e.preventDefault();\n\n         const newGraph = graph.clone();\n         const edge = newGraph.edgesById[selectedEdgeId];\n         \n         if (edge) {\n            // Update the label to the typed character immediately\n            edge.label = e.key; \n            onGraphChange(newGraph);\n            \n            // Trigger the Editor UI to open\n            if (onStartEditing) onStartEditing(selectedEdgeId);\n         }\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, selectedEdgeId, clipboard]);\n\n  return { deleteSelected, copy, paste };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}