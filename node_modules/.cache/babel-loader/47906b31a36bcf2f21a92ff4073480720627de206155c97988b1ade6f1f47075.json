{"ast":null,"code":"// Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph, id) => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container === null || container === void 0 ? void 0 : container.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph, pos) => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 && pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width && pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nexport const recomputeContainerSize = (graph, id) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n    const n = graph.getNode(nId);\n    if (!n) return;\n    hasChildren = true;\n    minX = Math.min(minX, n.position.x);\n    minY = Math.min(minY, n.position.y);\n    maxX = Math.max(maxX, n.position.x + 100);\n    maxY = Math.max(maxY, n.position.y + 50);\n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n    const ch = graph.containersById[childId];\n    if (!ch) return;\n    hasChildren = true;\n    minX = Math.min(minX, ch.position.x);\n    minY = Math.min(minY, ch.position.y);\n    maxX = Math.max(maxX, ch.position.x + ch.size.width);\n    maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n  if (!hasChildren) return;\n  const requiredWidth = maxX - minX + CONTAINER_PADDING * 2;\n  const requiredHeight = maxY - minY + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\nexport const assignEntityToContainer = (graph, entityId, skipContainerId) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n  for (const c of containers) {\n    if (c.id === entityId || skipContainerId && c.id === skipContainerId) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside = entity.position.x >= c.position.x && entity.position.y >= c.position.y && entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width && entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n          const oldParent = graph.containersById[entity.parentId];\n          if (oldParent) {\n            var _oldParent$childConta;\n            if (isContainer) oldParent.childContainerIds = (_oldParent$childConta = oldParent.childContainerIds) === null || _oldParent$childConta === void 0 ? void 0 : _oldParent$childConta.filter(id => id !== entityId);else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n          }\n        }\n\n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n    const prev = graph.containersById[entity.parentId];\n    if (prev) {\n      var _prev$childContainerI;\n      if (isContainer) prev.childContainerIds = (_prev$childContainerI = prev.childContainerIds) === null || _prev$childContainerI === void 0 ? void 0 : _prev$childContainerI.filter(id => id !== entityId);else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n    }\n    entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph, container) => {\n  const containerPorts = container.ports || [];\n  if (!container.collapsed) return containerPorts;\n  const proxyPorts = [];\n  const childNodeIds = new Set(container.nodeIds || []);\n  Object.values(graph.edgesById).forEach(edge => {\n    const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n    const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n    // Edge goes OUT\n    if (isSourceInside && !isTargetInside) {\n      var _sourceNode$ports;\n      const sourceNode = graph.nodesById[edge.sourceNodeId];\n      const internalPort = sourceNode === null || sourceNode === void 0 ? void 0 : (_sourceNode$ports = sourceNode.ports) === null || _sourceNode$ports === void 0 ? void 0 : _sourceNode$ports.find(p => p.id === edge.sourcePortId);\n      proxyPorts.push({\n        id: edge.sourcePortId || `proxy-src-${edge.id}`,\n        label: internalPort ? `${sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.label}.${internalPort.label}` : \"out\"\n      });\n    }\n    // Edge comes IN\n    else if (!isSourceInside && isTargetInside) {\n      var _targetNode$ports;\n      const targetNode = graph.nodesById[edge.targetNodeId];\n      const internalPort = targetNode === null || targetNode === void 0 ? void 0 : (_targetNode$ports = targetNode.ports) === null || _targetNode$ports === void 0 ? void 0 : _targetNode$ports.find(p => p.id === edge.targetPortId);\n      proxyPorts.push({\n        id: edge.targetPortId || `proxy-tgt-${edge.id}`,\n        label: internalPort ? `${targetNode === null || targetNode === void 0 ? void 0 : targetNode.label}.${internalPort.label}` : \"in\"\n      });\n    }\n  });\n  return [...containerPorts, ...proxyPorts];\n};\nexport const collectDragStartPositions = (rootIds, map, graph) => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...n.position\n        });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...c.position\n        });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n        c.nodeIds.forEach(nid => {\n          const child = graph.nodesById[nid];\n          if (child && !map.has(nid)) map.set(nid, {\n            ...child.position\n          });\n        });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};","map":{"version":3,"names":["CONTAINER_HEADER_HEIGHT","CONTAINER_PADDING","MIN_CONTAINER_WIDTH","MIN_CONTAINER_HEIGHT","isEntityVisible","graph","id","node","nodesById","container","containersById","currentParentId","parentId","parent","collapsed","hitTestEntity","pos","nodes","Object","values","containers","n","x","position","y","c","reverse","size","width","height","recomputeContainerSize","minX","Infinity","minY","maxX","maxY","hasChildren","nodeIds","forEach","nId","getNode","Math","min","max","childContainerIds","childId","ch","requiredWidth","requiredHeight","assignEntityToContainer","entityId","skipContainerId","entity","isContainer","isContainerEntity","inside","oldParent","_oldParent$childConta","filter","includes","push","prev","_prev$childContainerI","undefined","getRenderablePorts","containerPorts","ports","proxyPorts","childNodeIds","Set","edgesById","edge","isSourceInside","has","sourceNodeId","isTargetInside","targetNodeId","_sourceNode$ports","sourceNode","internalPort","find","p","sourcePortId","label","_targetNode$ports","targetNode","targetPortId","collectDragStartPositions","rootIds","map","set","nid","child"],"sources":["/home/belac/sysFlow/src/utils/GraphLogic.ts"],"sourcesContent":["import { GraphModel } from \"../models/GraphModel\";\nimport { Container } from \"../models/Container\";\nimport { Node } from \"../models/Node\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { getPortPosition } from \"./Geometry\"; // Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph: GraphModel, id: ID): boolean => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container?.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph: GraphModel, pos: Vec2): ID | null => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 &&\n        pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width &&\n        pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nexport const recomputeContainerSize = (graph: GraphModel, id: ID) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n      const n = graph.getNode(nId);\n      if (!n) return;\n      hasChildren = true;\n      minX = Math.min(minX, n.position.x);\n      minY = Math.min(minY, n.position.y);\n      maxX = Math.max(maxX, n.position.x + 100);\n      maxY = Math.max(maxY, n.position.y + 50); \n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n      const ch = graph.containersById[childId];\n      if (!ch) return;\n      hasChildren = true;\n      minX = Math.min(minX, ch.position.x);\n      minY = Math.min(minY, ch.position.y);\n      maxX = Math.max(maxX, ch.position.x + ch.size.width);\n      maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n\n  if (!hasChildren) return; \n\n  const requiredWidth = (maxX - minX) + CONTAINER_PADDING * 2;\n  const requiredHeight = (maxY - minY) + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\n\nexport const assignEntityToContainer = (graph: GraphModel, entityId: ID, skipContainerId?: ID) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n\n  for (const c of containers) {\n    if (c.id === entityId || (skipContainerId && c.id === skipContainerId)) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside =\n      entity.position.x >= c.position.x &&\n      entity.position.y >= c.position.y &&\n      entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width &&\n      entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n             const oldParent = graph.containersById[entity.parentId];\n             if (oldParent) {\n                 if(isContainer) oldParent.childContainerIds = oldParent.childContainerIds?.filter(id => id !== entityId);\n                 else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n             }\n        }\n        \n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n      const prev = graph.containersById[entity.parentId];\n      if (prev) {\n        if (isContainer) prev.childContainerIds = prev.childContainerIds?.filter(id => id !== entityId);\n        else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n      }\n      entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph: GraphModel, container: Container): Port[] => {\n    const containerPorts = container.ports || [];\n    if (!container.collapsed) return containerPorts;\n\n    const proxyPorts: Port[] = [];\n    const childNodeIds = new Set(container.nodeIds || []); \n\n    Object.values(graph.edgesById).forEach(edge => {\n      const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n      const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n      // Edge goes OUT\n      if (isSourceInside && !isTargetInside) {\n        const sourceNode = graph.nodesById[edge.sourceNodeId];\n        const internalPort = sourceNode?.ports?.find(p => p.id === edge.sourcePortId);\n        proxyPorts.push({\n          id: edge.sourcePortId || `proxy-src-${edge.id}`, \n          label: internalPort ? `${sourceNode?.label}.${internalPort.label}` : \"out\"\n        });\n      } \n      // Edge comes IN\n      else if (!isSourceInside && isTargetInside) {\n        const targetNode = graph.nodesById[edge.targetNodeId];\n        const internalPort = targetNode?.ports?.find(p => p.id === edge.targetPortId);\n        proxyPorts.push({\n          id: edge.targetPortId || `proxy-tgt-${edge.id}`, \n          label: internalPort ? `${targetNode?.label}.${internalPort.label}` : \"in\"\n        });\n      }\n    });\n\n    return [...containerPorts, ...proxyPorts];\n};\n\nexport const collectDragStartPositions = (\n  rootIds: ID[],\n  map: Map<ID, Vec2>,\n  graph: GraphModel\n): Map<ID, Vec2> => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, { ...n.position });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, { ...c.position });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n          c.nodeIds.forEach(nid => {\n              const child = graph.nodesById[nid];\n              if(child && !map.has(nid)) map.set(nid, {...child.position});\n          });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}