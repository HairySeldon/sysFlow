{"ast":null,"code":"var _jsxFileName = \"/home/belac/sysFlow/src/components/GraphEdgeLayer.tsx\";\nimport React from \"react\";\nimport * as GraphLogic from \"../utils/GraphLogic\";\n\n// Helper interface to ensure we can handle both types safely\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const GraphEdgeLayer = ({\n  graph,\n  mode,\n  creatingEdge\n}) => {\n  // 1. Helper to find any entity (Node OR Container)\n  const getEntity = id => {\n    return graph.nodesById[id] || graph.containersById[id];\n  };\n\n  // 2. Helper to calculate the absolute center of an entity\n  const getEntityCenter = entity => {\n    var _entity$size$width, _entity$size, _entity$size$height, _entity$size2;\n    // Default to 100x50 if size is missing (standard Node size)\n    // Use actual size if present (Containers)\n    const w = (_entity$size$width = (_entity$size = entity.size) === null || _entity$size === void 0 ? void 0 : _entity$size.width) !== null && _entity$size$width !== void 0 ? _entity$size$width : 100;\n    const h = (_entity$size$height = (_entity$size2 = entity.size) === null || _entity$size2 === void 0 ? void 0 : _entity$size2.height) !== null && _entity$size$height !== void 0 ? _entity$size$height : 50;\n    return {\n      x: entity.position.x + w / 2,\n      y: entity.position.y + h / 2\n    };\n  };\n\n  // 3. Main Logic: Get the visual anchor point for an edge end\n  const getVisualAnchor = entityId => {\n    // A. If the entity (Node or Container) is visible on the canvas\n    if (GraphLogic.isEntityVisible(graph, entityId)) {\n      const entity = getEntity(entityId);\n      if (entity) {\n        return getEntityCenter(entity);\n      }\n    }\n\n    // B. If not visible (collapsed inside a parent), find the parent container\n    const containers = Object.values(graph.containersById);\n    const parent = containers.find(c => {\n      var _c$nodeIds, _c$childContainerIds;\n      return ((_c$nodeIds = c.nodeIds) === null || _c$nodeIds === void 0 ? void 0 : _c$nodeIds.includes(entityId)) || ((_c$childContainerIds = c.childContainerIds) === null || _c$childContainerIds === void 0 ? void 0 : _c$childContainerIds.includes(entityId));\n    });\n\n    // If parent is found and visible, the edge connects to the PARENT's center\n    if (parent && GraphLogic.isEntityVisible(graph, parent.id)) {\n      return getEntityCenter(parent);\n    }\n    return null;\n  };\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    style: {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"100%\",\n      height: \"100%\",\n      pointerEvents: \"none\",\n      overflow: \"visible\",\n      zIndex: 0\n    },\n    children: [Object.values(graph.edgesById).map(edge => {\n      const start = getVisualAnchor(edge.sourceNodeId);\n      const end = getVisualAnchor(edge.targetNodeId);\n      if (!start || !end) return null;\n      return /*#__PURE__*/_jsxDEV(\"line\", {\n        x1: start.x,\n        y1: start.y,\n        x2: end.x,\n        y2: end.y,\n        stroke: \"black\",\n        strokeWidth: \"2\"\n      }, edge.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 89,\n        columnNumber: 11\n      }, this);\n    }), mode === \"edge-create\" && creatingEdge && /*#__PURE__*/_jsxDEV(\"line\", {\n      // Line starts at the mouse position (drag point)\n      x1: creatingEdge.position.x,\n      y1: creatingEdge.position.y\n\n      // Line ends at the center of the Source Entity (Node OR Container)\n      ,\n      x2: (() => {\n        const source = getEntity(creatingEdge.sourceNodeId);\n        return source ? getEntityCenter(source).x : creatingEdge.position.x;\n      })(),\n      y2: (() => {\n        const source = getEntity(creatingEdge.sourceNodeId);\n        return source ? getEntityCenter(source).y : creatingEdge.position.y;\n      })(),\n      stroke: \"black\",\n      strokeWidth: \"2\",\n      strokeDasharray: \"5,5\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 5\n  }, this);\n};\n_c = GraphEdgeLayer;\nvar _c;\n$RefreshReg$(_c, \"GraphEdgeLayer\");","map":{"version":3,"names":["React","GraphLogic","jsxDEV","_jsxDEV","GraphEdgeLayer","graph","mode","creatingEdge","getEntity","id","nodesById","containersById","getEntityCenter","entity","_entity$size$width","_entity$size","_entity$size$height","_entity$size2","w","size","width","h","height","x","position","y","getVisualAnchor","entityId","isEntityVisible","containers","Object","values","parent","find","c","_c$nodeIds","_c$childContainerIds","nodeIds","includes","childContainerIds","style","top","left","pointerEvents","overflow","zIndex","children","edgesById","map","edge","start","sourceNodeId","end","targetNodeId","x1","y1","x2","y2","stroke","strokeWidth","fileName","_jsxFileName","lineNumber","columnNumber","source","strokeDasharray","_c","$RefreshReg$"],"sources":["/home/belac/sysFlow/src/components/GraphEdgeLayer.tsx"],"sourcesContent":["import React from \"react\";\nimport { Vec2 } from \"../models/Entity\";\nimport * as GraphLogic from \"../utils/GraphLogic\";\n\n// Helper interface to ensure we can handle both types safely\ninterface EntityShape {\n  id: string;\n  position: Vec2;\n  size?: { width: number; height: number }; // Containers have size, Nodes might not\n  nodeIds?: string[];\n  childContainerIds?: string[];\n}\n\ninterface GraphEdgeLayerProps {\n  graph: any;\n  mode: string;\n  creatingEdge: { sourceNodeId: string; position: Vec2 } | null;\n}\n\nexport const GraphEdgeLayer: React.FC<GraphEdgeLayerProps> = ({\n  graph,\n  mode,\n  creatingEdge,\n}) => {\n\n  // 1. Helper to find any entity (Node OR Container)\n  const getEntity = (id: string): EntityShape | undefined => {\n    return graph.nodesById[id] || graph.containersById[id];\n  };\n\n  // 2. Helper to calculate the absolute center of an entity\n  const getEntityCenter = (entity: EntityShape) => {\n    // Default to 100x50 if size is missing (standard Node size)\n    // Use actual size if present (Containers)\n    const w = entity.size?.width ?? 100;\n    const h = entity.size?.height ?? 50;\n    return {\n      x: entity.position.x + w / 2,\n      y: entity.position.y + h / 2\n    };\n  };\n\n  // 3. Main Logic: Get the visual anchor point for an edge end\n  const getVisualAnchor = (entityId: string): Vec2 | null => {\n    \n    // A. If the entity (Node or Container) is visible on the canvas\n    if (GraphLogic.isEntityVisible(graph, entityId)) {\n      const entity = getEntity(entityId);\n      if (entity) {\n        return getEntityCenter(entity);\n      }\n    }\n\n    // B. If not visible (collapsed inside a parent), find the parent container\n    const containers: EntityShape[] = Object.values(graph.containersById);\n    const parent = containers.find((c) =>\n      c.nodeIds?.includes(entityId) || c.childContainerIds?.includes(entityId)\n    );\n\n    // If parent is found and visible, the edge connects to the PARENT's center\n    if (parent && GraphLogic.isEntityVisible(graph, parent.id)) {\n      return getEntityCenter(parent);\n    }\n\n    return null;\n  };\n\n  return (\n    <svg\n      style={{\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        overflow: \"visible\",\n        zIndex: 0,\n      }}\n    >\n      {/* 1. Render Existing Edges */}\n      {Object.values(graph.edgesById).map((edge: any) => {\n        const start = getVisualAnchor(edge.sourceNodeId);\n        const end = getVisualAnchor(edge.targetNodeId);\n\n        if (!start || !end) return null;\n\n        return (\n          <line\n            key={edge.id}\n            x1={start.x}\n            y1={start.y}\n            x2={end.x}\n            y2={end.y}\n            stroke=\"black\"\n            strokeWidth=\"2\"\n          />\n        );\n      })}\n\n      {/* 2. Render Temporary \"Creating\" Edge */}\n      {mode === \"edge-create\" && creatingEdge && (\n        <line\n          // Line starts at the mouse position (drag point)\n          x1={creatingEdge.position.x}\n          y1={creatingEdge.position.y}\n          \n          // Line ends at the center of the Source Entity (Node OR Container)\n          x2={(() => {\n            const source = getEntity(creatingEdge.sourceNodeId);\n            return source ? getEntityCenter(source).x : creatingEdge.position.x;\n          })()}\n          y2={(() => {\n             const source = getEntity(creatingEdge.sourceNodeId);\n             return source ? getEntityCenter(source).y : creatingEdge.position.y;\n          })()}\n          \n          stroke=\"black\"\n          strokeWidth=\"2\"\n          strokeDasharray=\"5,5\"\n        />\n      )}\n    </svg>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}