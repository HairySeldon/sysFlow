{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nexport const useGraphClipboard = ({\n  graph,\n  selectedNodes,\n  selectedContainerIds,\n  onGraphChange,\n  clearSelection,\n  setSelectedNodes,\n  setSelectedContainerIds\n}) => {\n  _s();\n  const [clipboard, setClipboard] = useState(null);\n  const selectAll = () => {\n    const allNodesIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersByIds));\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerId(allContainerIds);\n  };\n  const deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n    const newGraph = graph.clone();\n    selectedNodes.forEach(id => newGraph.removeNode(id));\n    selectedContainerIds.forEach(id => newGraph.removeContainer(id));\n    onGraphChange(newGraph);\n    clearSelection();\n  };\n  const copy = e => {\n    e.preventDefault();\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n\n    // Only copy edges if both ends are selected\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge => allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId));\n    const clipboardData = {\n      nodes: nodesToCopy,\n      containers: containersToCopy,\n      edges: edgesToCopy\n    };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n  const paste = e => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      const idMap = new Map();\n      const newSelectedNodes = new Set();\n      const newSelectedContainers = new Set();\n\n      // ... [Insert your existing Paste Logic here, reused exactly] ...\n      // 1. Paste Containers\n      data.containers.forEach(c => {\n        const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(c.id, newId);\n        newGraph.containersById[newId] = {\n          ...c,\n          id: newId,\n          position: {\n            x: c.position.x + 20,\n            y: c.position.y + 20\n          },\n          nodeIds: [],\n          childContainerIds: []\n        };\n        newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach(n => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = {\n          ...n,\n          id: newId,\n          position: {\n            x: n.position.x + 20,\n            y: n.position.y + 20\n          },\n          parentId: n.parentId ? idMap.get(n.parentId) : undefined\n        };\n        newSelectedNodes.add(newId);\n        if (n.parentId && idMap.has(n.parentId)) {\n          var _newGraph$containersB;\n          (_newGraph$containersB = newGraph.containersById[idMap.get(n.parentId)]) === null || _newGraph$containersB === void 0 ? void 0 : _newGraph$containersB.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges\n      data.edges.forEach(e => {\n        const newSource = idMap.get(e.sourceNodeId);\n        const newTarget = idMap.get(e.targetNodeId);\n        if (newSource && newTarget) {\n          const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n          newGraph.edgesById[newEdgeId] = {\n            ...e,\n            id: newEdgeId,\n            sourceNodeId: newSource,\n            targetNodeId: newTarget\n          };\n        }\n      });\n      onGraphChange(newGraph);\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n    } catch (err) {\n      console.error(\"Paste failed\", err);\n    }\n  };\n\n  // Keyboard Listener\n  useEffect(() => {\n    const handleKeyDown = e => {\n      if (e.target.tagName === \"INPUT\") return;\n      if (e.key === \"Delete\" || e.key === \"Backspace\") deleteSelected();\n      if (e.key === \"Escape\") clearAllStates();\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") selectAll();\n        if (e.key === \"c\") copy(e);\n        if (e.key === \"x\") {\n          copy(e);\n          deleteSelected();\n        }\n        if (e.key === \"v\") paste(e);\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, clipboard]); // Dependencies\n\n  return {\n    deleteSelected,\n    copy,\n    paste\n  };\n};\n_s(useGraphClipboard, \"1H+Q2r5p85WO+8m7YfmWK/uQKVg=\");","map":{"version":3,"names":["useState","useEffect","useGraphClipboard","graph","selectedNodes","selectedContainerIds","onGraphChange","clearSelection","setSelectedNodes","setSelectedContainerIds","_s","clipboard","setClipboard","selectAll","allNodesIds","Set","Object","keys","nodesById","allContainerIds","containersByIds","allNodeIds","setSelectedContainerId","deleteSelected","size","newGraph","clone","forEach","id","removeNode","removeContainer","copy","e","preventDefault","nodesToCopy","values","filter","n","has","containersToCopy","containersById","c","allSelectedIds","edgesToCopy","edgesById","edge","sourceNodeId","targetNodeId","clipboardData","nodes","containers","edges","JSON","stringify","paste","data","parse","idMap","Map","newSelectedNodes","newSelectedContainers","newId","crypto","randomUUID","slice","set","position","x","y","nodeIds","childContainerIds","add","parentId","get","undefined","_newGraph$containersB","push","newSource","newTarget","newEdgeId","err","console","error","handleKeyDown","target","tagName","key","clearAllStates","ctrlKey","metaKey","window","addEventListener","removeEventListener"],"sources":["/home/belac/sysFlow/src/hooks/useGraphClipboard.ts"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\n\ninterface UseGraphClipboardProps {\n  graph: GraphModel;\n  selectedNodes: Set<string>;\n  selectedContainerIds: Set<string>;\n  onGraphChange: (newGraph: GraphModel) => void;\n  clearSelection: () => void;\n  setSelectedNodes: (ids: Set<string>) => void;\n  setSelectedContainerIds: (ids: Set<string>) => void;\n}\n\nexport const useGraphClipboard = ({\n  graph,\n  selectedNodes,\n  selectedContainerIds,\n  onGraphChange,\n  clearSelection,\n  setSelectedNodes,\n  setSelectedContainerIds,\n}: UseGraphClipboardProps) => {\n  const [clipboard, setClipboard] = useState<string | null>(null);\n\n  const selectAll = () => {\n    const allNodesIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersByIds));\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerId(allContainerIds);\n  };\n\n  const deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n    const newGraph = graph.clone();\n    selectedNodes.forEach((id) => newGraph.removeNode(id));\n    selectedContainerIds.forEach((id) => newGraph.removeContainer(id));\n    onGraphChange(newGraph);\n    clearSelection();\n  };\n\n  const copy = (e: KeyboardEvent) => {\n    e.preventDefault();\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n    \n    // Only copy edges if both ends are selected\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge =>\n      allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId)\n    );\n\n    const clipboardData = { nodes: nodesToCopy, containers: containersToCopy, edges: edgesToCopy };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n\n  const paste = (e: KeyboardEvent) => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      const idMap = new Map<string, string>();\n      const newSelectedNodes = new Set<string>();\n      const newSelectedContainers = new Set<string>();\n\n      // ... [Insert your existing Paste Logic here, reused exactly] ...\n      // 1. Paste Containers\n      data.containers.forEach((c: any) => {\n          const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n          idMap.set(c.id, newId);\n          newGraph.containersById[newId] = { ...c, id: newId, position: { x: c.position.x + 20, y: c.position.y + 20 }, nodeIds: [], childContainerIds: [] };\n          newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach((n: any) => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = { ...n, id: newId, position: { x: n.position.x + 20, y: n.position.y + 20 }, parentId: n.parentId ? idMap.get(n.parentId) : undefined };\n        newSelectedNodes.add(newId);\n        if (n.parentId && idMap.has(n.parentId)) {\n            newGraph.containersById[idMap.get(n.parentId)!]?.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges\n      data.edges.forEach((e: any) => {\n        const newSource = idMap.get(e.sourceNodeId);\n        const newTarget = idMap.get(e.targetNodeId);\n        if (newSource && newTarget) {\n            const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n            newGraph.edgesById[newEdgeId] = { ...e, id: newEdgeId, sourceNodeId: newSource, targetNodeId: newTarget };\n        }\n      });\n\n      onGraphChange(newGraph);\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n    } catch (err) { console.error(\"Paste failed\", err); }\n  };\n\n  // Keyboard Listener\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if ((e.target as HTMLElement).tagName === \"INPUT\") return;\n      if (e.key === \"Delete\" || e.key === \"Backspace\") deleteSelected();\n      if (e.key === \"Escape\") clearAllStates();\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") selectAll();\n        if (e.key === \"c\") copy(e);\n        if (e.key === \"x\") { copy(e); deleteSelected(); }\n        if (e.key === \"v\") paste(e);\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, clipboard]); // Dependencies\n\n  return { deleteSelected, copy, paste };\n\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}