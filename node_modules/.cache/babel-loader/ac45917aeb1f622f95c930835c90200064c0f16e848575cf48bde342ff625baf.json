{"ast":null,"code":"var _jsxFileName = \"/home/belac/sysFlow/src/components/GraphCanvas.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef } from \"react\";\nimport { GraphNode } from \"./GraphNode\";\nimport { GraphContainer } from \"./GraphContainer\";\nimport { Lasso } from \"./Lasso\";\nimport { EntityEditor } from \"./EntityEditor\";\nimport { GraphContextMenu } from \"./GraphContextMenu\";\nimport { GraphEdgeLayer } from \"./GraphEdgeLayer\";\nimport { GraphPortLayer } from \"./GraphPortLayer\";\n\n// --- HOOKS ---\nimport { useGraphView } from \"../hooks/useGraphView\";\nimport { useGraphSelection } from \"../hooks/useGraphSelection\";\nimport { useGraphClipboard } from \"../hooks/useGraphClipboard\";\n\n// --- IMPORT THE LOGIC ---\nimport * as GraphLogic from \"../utils/GraphLogic\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const GraphCanvas = ({\n  graph,\n  onGraphChange,\n  renderNode,\n  renderContainer,\n  enablePorts,\n  renderEditor\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const [selectedEdgeId, setSelectedEdgeId] = useState(null);\n\n  // 1. Hooks\n  const view = useGraphView(containerRef);\n  const selection = useGraphSelection(graph);\n  const clipboard = useGraphClipboard({\n    graph,\n    onGraphChange,\n    selectedNodes: selection.selectedNodes,\n    selectedContainerIds: selection.selectedContainerIds,\n    selectedEdgeId: selectedEdgeId,\n    clearSelection: selection.clearSelection,\n    setSelectedNodes: selection.setSelectedNodes,\n    setSelectedContainerIds: selection.setSelectedContainerIds,\n    setSelectedEdgeId: setSelectedEdgeId // Move to selection\n  });\n\n  // 3. Local Interaction State (Things that are too transient for their own hooks yet)\n  const [mode, setMode] = useState(\"idle\");\n\n  // Dragging Entities\n  const [dragStartMouse, setDragStartMouse] = useState(null);\n  const [dragStartPositions, setDragStartPositions] = useState(new Map());\n\n  // Creating Edges\n  const [creatingEdge, setCreatingEdge] = useState(null);\n  const [hoveredPort, setHoveredPort] = useState(null);\n\n  // Resize\n  const [resizingState, setResizingState] = useState(null);\n\n  // Menus\n  const [editingEntityId, setEditingEntityId] = useState(null);\n  const [editorPosition, setEditorPosition] = useState(null);\n  const [canvasMenu, setCanvasMenu] = useState(null);\n\n  // --- Handlers ---\n\n  const handleMouseDown = e => {\n    // 0. Pan Start (Middle Mouse or Space)\n    if (e.button === 1 || e.button === 0 && e.nativeEvent.getModifierState(\"Space\")) {\n      e.preventDefault();\n      view.startPan(e);\n      return;\n    }\n\n    // 1. Context Menu (Right Click)\n    if (e.button === 2) {\n      const screenPos = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      const graphPos = view.getMousePos(e); // The \"world\" coordinates\n\n      // Set the state with BOTH\n      setCanvasMenu({\n        position: screenPos,\n        graphPosition: graphPos\n      });\n      return;\n    }\n    const pos = view.getGlobPos(e);\n\n    // 2. Canvas Click (Left) -> Start Lasso\n    if (e.button === 0) {\n      selection.clearSelection();\n      setEditingEntityId(null);\n      setCanvasMenu(null);\n      setMode(\"lasso\");\n      selection.setLassoStart(pos);\n      selection.setLassoEnd(pos);\n    }\n  };\n  const handleMouseMove = e => {\n    // 0. Panning\n    if (view.isPanning) {\n      view.updatePan(e);\n      return;\n    }\n    const mousePos = view.getMousePos(e);\n\n    // 1. Dragging Entities\n    if (mode === \"drag\" && dragStartMouse) {\n      const dx = mousePos.x - dragStartMouse.x;\n      const dy = mousePos.y - dragStartMouse.y;\n      const newGraph = graph.clone();\n      let changed = false;\n      dragStartPositions.forEach((startPos, id) => {\n        const node = newGraph.nodesById[id];\n        const container = newGraph.containersById[id];\n        if (node) {\n          node.position = {\n            x: startPos.x + dx,\n            y: startPos.y + dy\n          };\n          changed = true;\n        }\n        if (container) {\n          container.position = {\n            x: startPos.x + dx,\n            y: startPos.y + dy\n          };\n          changed = true;\n        }\n      });\n      if (changed) onGraphChange(newGraph);\n    }\n\n    // 2. Lasso\n    if (mode === \"lasso\") {\n      const lassoPos = view.getGlobPos(e);\n      selection.setLassoEnd(lassoPos);\n    }\n\n    // 3. Edge Create\n    if (mode === \"edge-create\" && creatingEdge) {\n      setCreatingEdge({\n        ...creatingEdge,\n        position: mousePos\n      });\n    }\n\n    // 4. Resize\n    if (mode === \"resize\" && resizingState) {\n      const dx = mousePos.x - resizingState.startMouse.x;\n      const dy = mousePos.y - resizingState.startMouse.y;\n      const newGraph = graph.clone();\n      const c = newGraph.containersById[resizingState.id];\n      if (c) {\n        c.size = {\n          width: Math.max(100, resizingState.startSize.width + dx),\n          height: Math.max(50, resizingState.startSize.height + dy)\n        };\n        onGraphChange(newGraph);\n      }\n    }\n  };\n  const handleMouseUp = e => {\n    if (view.isPanning) {\n      view.endPan();\n      return;\n    }\n    const pos = view.getMousePos(e);\n    const isClick = dragStartMouse && Math.abs(pos.x - dragStartMouse.x) < 5 && Math.abs(pos.y - dragStartMouse.y) < 5;\n\n    // 1. Open Editor (Click without drag)\n    if (mode === \"idle\" || mode === \"drag\" && isClick) {\n      const targetId = GraphLogic.hitTestEntity(graph, pos);\n      if (targetId) {\n        setEditingEntityId(targetId);\n        setEditorPosition({\n          x: pos.x,\n          y: pos.y\n        });\n        setMode(\"idle\");\n        return;\n      }\n    }\n\n    // 2. Lasso Finish\n    if (mode === \"lasso\") {\n      selection.completeLasso(view.zoom);\n    }\n\n    // 3. Drag Finish\n    if (mode === \"drag\" && dragStartMouse) {\n      // Re-parenting logic here (Drag Drop into Container)\n      const newGraph = graph.clone();\n      dragStartPositions.forEach((_, id) => {\n        var _newGraph$nodesById$i, _newGraph$containersB;\n        GraphLogic.assignEntityToContainer(newGraph, id);\n        const parent = ((_newGraph$nodesById$i = newGraph.nodesById[id]) === null || _newGraph$nodesById$i === void 0 ? void 0 : _newGraph$nodesById$i.parentId) || ((_newGraph$containersB = newGraph.containersById[id]) === null || _newGraph$containersB === void 0 ? void 0 : _newGraph$containersB.parentId);\n        if (parent) GraphLogic.recomputeContainerSize(newGraph, parent);\n      });\n      onGraphChange(newGraph);\n      setDragStartMouse(null);\n      setDragStartPositions(new Map());\n    }\n\n    // 4. Edge Create Finish\n    if (mode === \"edge-create\" && creatingEdge) {\n      const targetNodeId = hoveredPort ? hoveredPort.nodeId : GraphLogic.hitTestEntity(graph, pos);\n\n      // Only proceed if we hit a valid target different from source\n      if (targetNodeId && targetNodeId !== creatingEdge.sourceNodeId) {\n        // START TRANSACTION (We might need to modify the graph multiple times)\n        let finalGraph = graph.clone();\n        let finalSourcePortId = creatingEdge.sourcePortId;\n        let finalTargetPortId = hoveredPort ? hoveredPort.portId : undefined;\n\n        // --- STEP 1: Handle Missing SOURCE Port ---\n        if (!finalSourcePortId && enablePorts) {\n          const label = window.prompt(\"Name the New Source Port:\", \"out-1\");\n          if (label) {\n            const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n            const sourceNode = finalGraph.nodesById[creatingEdge.sourceNodeId] || finalGraph.containersById[creatingEdge.sourceNodeId];\n            if (!sourceNode.ports) sourceNode.ports = [];\n            sourceNode.ports.push({\n              id: newPortId,\n              label\n            });\n            finalSourcePortId = newPortId;\n          } else {\n            setCreatingEdge(null);\n            setMode(\"idle\");\n            return;\n          }\n        }\n\n        // --- STEP 2: Handle Missing TARGET Port ---\n        if (!finalTargetPortId && enablePorts) {\n          const label = window.prompt(\"Name the New Target Port:\", \"in-1\");\n          if (label) {\n            const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n            const targetNode = finalGraph.nodesById[targetNodeId] || finalGraph.containersById[targetNodeId];\n            if (!targetNode.ports) targetNode.ports = [];\n            targetNode.ports.push({\n              id: newPortId,\n              label\n            });\n            finalTargetPortId = newPortId;\n          } else {\n            setCreatingEdge(null);\n            setMode(\"idle\");\n            return;\n          }\n        }\n\n        // --- STEP 3: Create the Edge ---\n        if (!enablePorts || finalSourcePortId && finalTargetPortId) {\n          const edgeId = `e_${crypto.randomUUID()}`;\n          finalGraph.edgesById[edgeId] = {\n            id: edgeId,\n            sourceNodeId: creatingEdge.sourceNodeId,\n            sourcePortId: finalSourcePortId,\n            targetNodeId: targetNodeId,\n            targetPortId: finalTargetPortId\n          };\n          onGraphChange(finalGraph);\n        }\n      }\n\n      // Cleanup\n      setCreatingEdge(null);\n      setMode(\"idle\");\n    }\n    setMode(\"idle\");\n  };\n  const createPortAndStartDrag = entityId => {\n    if (!enablePorts) return;\n\n    // 1. Prompt for Port Name\n    const label = window.prompt(\"Enter Source Port Name:\", \"out-1\");\n    if (!label) {\n      // User cancelled, cancel the edge creation\n      setCreatingEdge(null);\n      setMode(\"idle\");\n      return;\n    }\n\n    // 2. Create the Port in the Model\n    const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n    const newGraph = graph.clone();\n\n    // Find the entity (Node or Container)\n    const target = newGraph.nodesById[entityId] || newGraph.containersById[entityId];\n    if (target) {\n      if (!target.ports) target.ports = [];\n      target.ports.push({\n        id: newPortId,\n        label\n      });\n      onGraphChange(newGraph);\n\n      // 3. Link the currently creating edge to this new specific port\n      setCreatingEdge(prev => prev ? {\n        ...prev,\n        sourcePortId: newPortId\n      } : null);\n    }\n  };\n\n  // --- Entity Event Wrappers ---\n  const handleEntityMouseDown = (e, id, type) => {\n    e.stopPropagation();\n\n    // 1. Right Click -> Create Edge\n    if (e.button === 2) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Logic from your snippet: Start creating an edge\n      const mousePos = view.getMousePos(e);\n      setMode(\"edge-create\");\n      setCreatingEdge({\n        sourceNodeId: id,\n        // Assuming containers can also be sources if passed here\n        position: mousePos\n      });\n\n      // Initialize the drag ghost/port\n      // Ensure this function exists in your scope and handles the entity type passed\n      createPortAndStartDrag(id);\n      return;\n    }\n\n    // 2. Left Click -> Select & Prepare Drag\n    selection.handleEntityClick(e, id, type);\n    if (e.button === 0) {\n      setMode(\"drag\");\n      setDragStartMouse(view.getMousePos(e));\n\n      // --- FIX START ---\n      // Check if the item we clicked was ALREADY part of the selection\n      const isAlreadySelected = type === \"node\" ? selection.selectedNodes.has(id) : selection.selectedContainerIds.has(id);\n\n      // Check for modifier keys (Shift/Ctrl/Meta)\n      const isMultiSelect = e.shiftKey || e.metaKey || e.ctrlKey;\n\n      // Start with the EXISTING selection (stale state)\n      let nodesToDrag = new Set(selection.selectedNodes);\n      let containersToDrag = new Set(selection.selectedContainerIds);\n\n      // CRITICAL LOGIC: \n      // If we clicked a NEW item (not already selected) AND we aren't holding Shift...\n      // We must ignore the old selection and drag ONLY the new item.\n      if (!isAlreadySelected && !isMultiSelect) {\n        nodesToDrag.clear();\n        containersToDrag.clear();\n      }\n\n      // Always ensure the clicked item is included in the drag\n      if (type === \"node\") nodesToDrag.add(id);else containersToDrag.add(id);\n      // --- FIX END ---\n\n      setDragStartPositions(GraphLogic.collectDragStartPositions([...nodesToDrag, ...containersToDrag], new Map(), graph));\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"graph-canvas\",\n    style: {\n      position: \"relative\",\n      width: \"100%\",\n      height: \"100%\",\n      overflow: \"hidden\",\n      userSelect: \"none\",\n      cursor: view.isPanning ? \"grabbing\" : \"default\"\n    }\n    //onWheel={view.handleWheel}\n    ,\n    onMouseDown: handleMouseDown,\n    onMouseMove: handleMouseMove,\n    onMouseUp: handleMouseUp,\n    onContextMenu: e => e.preventDefault(),\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        transform: `translate(${view.view.x}px, ${view.view.y}px) scale(${view.view.zoom})`,\n        transformOrigin: \"0 0\",\n        width: \"100%\",\n        height: \"100%\",\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      },\n      children: [Object.values(graph.containersById)\n      // 1. SORT: Render largest containers first (bottom layer), smallest last (top layer)\n      .sort((a, b) => b.size.width * b.size.height - a.size.width * a.size.height).map(c => GraphLogic.isEntityVisible(graph, c.id) && /*#__PURE__*/_jsxDEV(GraphContainer, {\n        container: c,\n        selected: selection.selectedContainerIds.has(c.id),\n        onMouseDown: e => handleEntityMouseDown(e, c.id, \"container\"),\n        onResizeMouseDown: e => {\n          e.stopPropagation();\n          setMode(\"resize\");\n          setResizingState({\n            id: c.id,\n            startMouse: view.getMousePos(e),\n            startSize: {\n              ...c.size\n            }\n          });\n        },\n        onDoubleClick: e => {\n          e.stopPropagation();\n          // 1. Clone the graph\n          const newGraph = graph.clone();\n\n          // 2. Find and toggle the container\n          const container = newGraph.containersById[c.id];\n          if (container) {\n            container.collapsed = !container.collapsed;\n            onGraphChange(newGraph);\n          }\n        }\n      }, c.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 401,\n        columnNumber: 12\n      }, this)), Object.values(graph.nodesById).map(n => GraphLogic.isEntityVisible(graph, n.id) && /*#__PURE__*/_jsxDEV(GraphNode, {\n        node: n,\n        selected: selection.selectedNodes.has(n.id),\n        onMouseDown: e => handleEntityMouseDown(e, n.id, \"node\")\n      }, n.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 428,\n        columnNumber: 12\n      }, this)), /*#__PURE__*/_jsxDEV(GraphEdgeLayer, {\n        graph: graph,\n        mode: mode,\n        creatingEdge: creatingEdge,\n        selectedEdgeId: selectedEdgeId,\n        onEdgeClick: (e, edgeId) => {\n          setSelectedEdgeId(edgeId);\n          selection.clearSelection();\n\n          // Optional: Detect Double Click for Editing\n          if (e.detail === 2) {\n            setEditingEntityId(edgeId);\n            setEditorPosition(view.getMousePos(e));\n          }\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 437,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(GraphPortLayer, {\n        graph: graph,\n        enablePorts: enablePorts,\n        hoveredPort: hoveredPort,\n        onHoverPort: setHoveredPort,\n        onPortMouseDown: (e, nodeId, portId, label, pos) => {\n          e.stopPropagation();\n          setCreatingEdge({\n            sourceNodeId: nodeId,\n            sourcePortId: portId,\n            position: pos\n          });\n          setMode(\"edge-create\");\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 454,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 389,\n      columnNumber: 7\n    }, this), mode === \"lasso\" && selection.lassoStart && selection.lassoEnd && /*#__PURE__*/_jsxDEV(Lasso, {\n      start: selection.lassoStart,\n      end: selection.lassoEnd\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 470,\n      columnNumber: 9\n    }, this), editingEntityId && editorPosition && /*#__PURE__*/_jsxDEV(EntityEditor, {\n      entityId: editingEntityId,\n      graph: graph,\n      position: editorPosition,\n      onClose: () => setEditingEntityId(null),\n      onGraphChange: onGraphChange,\n      enablePorts: enablePorts,\n      renderCustomContent: renderEditor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 475,\n      columnNumber: 9\n    }, this), canvasMenu && /*#__PURE__*/_jsxDEV(GraphContextMenu, {\n      canvasMenu: {\n        ...canvasMenu,\n        targetId: undefined\n      },\n      graph: graph,\n      onGraphChange: onGraphChange,\n      onClose: () => setCanvasMenu(null)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 488,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 376,\n    columnNumber: 5\n  }, this);\n};\n_s(GraphCanvas, \"a9FLydCpl7/0sE1wv33tN/uas50=\", false, function () {\n  return [useGraphView, useGraphSelection, useGraphClipboard];\n});\n_c = GraphCanvas;\nvar _c;\n$RefreshReg$(_c, \"GraphCanvas\");","map":{"version":3,"names":["React","useState","useRef","GraphNode","GraphContainer","Lasso","EntityEditor","GraphContextMenu","GraphEdgeLayer","GraphPortLayer","useGraphView","useGraphSelection","useGraphClipboard","GraphLogic","jsxDEV","_jsxDEV","GraphCanvas","graph","onGraphChange","renderNode","renderContainer","enablePorts","renderEditor","_s","containerRef","selectedEdgeId","setSelectedEdgeId","view","selection","clipboard","selectedNodes","selectedContainerIds","clearSelection","setSelectedNodes","setSelectedContainerIds","mode","setMode","dragStartMouse","setDragStartMouse","dragStartPositions","setDragStartPositions","Map","creatingEdge","setCreatingEdge","hoveredPort","setHoveredPort","resizingState","setResizingState","editingEntityId","setEditingEntityId","editorPosition","setEditorPosition","canvasMenu","setCanvasMenu","handleMouseDown","e","button","nativeEvent","getModifierState","preventDefault","startPan","screenPos","x","clientX","y","clientY","graphPos","getMousePos","position","graphPosition","pos","getGlobPos","setLassoStart","setLassoEnd","handleMouseMove","isPanning","updatePan","mousePos","dx","dy","newGraph","clone","changed","forEach","startPos","id","node","nodesById","container","containersById","lassoPos","startMouse","c","size","width","Math","max","startSize","height","handleMouseUp","endPan","isClick","abs","targetId","hitTestEntity","completeLasso","zoom","_","_newGraph$nodesById$i","_newGraph$containersB","assignEntityToContainer","parent","parentId","recomputeContainerSize","targetNodeId","nodeId","sourceNodeId","finalGraph","finalSourcePortId","sourcePortId","finalTargetPortId","portId","undefined","label","window","prompt","newPortId","crypto","randomUUID","slice","sourceNode","ports","push","targetNode","edgeId","edgesById","targetPortId","createPortAndStartDrag","entityId","target","prev","handleEntityMouseDown","type","stopPropagation","handleEntityClick","isAlreadySelected","has","isMultiSelect","shiftKey","metaKey","ctrlKey","nodesToDrag","Set","containersToDrag","clear","add","collectDragStartPositions","ref","className","style","overflow","userSelect","cursor","onMouseDown","onMouseMove","onMouseUp","onContextMenu","children","transform","transformOrigin","top","left","Object","values","sort","a","b","map","isEntityVisible","selected","onResizeMouseDown","onDoubleClick","collapsed","fileName","_jsxFileName","lineNumber","columnNumber","n","onEdgeClick","detail","onHoverPort","onPortMouseDown","lassoStart","lassoEnd","start","end","onClose","renderCustomContent","_c","$RefreshReg$"],"sources":["/home/belac/sysFlow/src/components/GraphCanvas.tsx"],"sourcesContent":["import React, { useState, useRef } from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\nimport { Node } from \"../models/Node\";\nimport { Container } from \"../models/Container\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { GraphNode } from \"./GraphNode\";\nimport { GraphContainer } from \"./GraphContainer\";\nimport { GraphEdge } from \"./GraphEdge\";\nimport { Lasso } from \"./Lasso\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport { EntityEditor } from \"./EntityEditor\";\nimport { getPortPosition } from \"../utils/Geometry\";\nimport { GraphContextMenu } from \"./GraphContextMenu\";\nimport { GraphEdgeLayer } from \"./GraphEdgeLayer\";\nimport { GraphPortLayer } from \"./GraphPortLayer\";\n\n// --- HOOKS ---\nimport { useGraphView } from \"../hooks/useGraphView\";\nimport { useGraphSelection } from \"../hooks/useGraphSelection\";\nimport { useGraphClipboard } from \"../hooks/useGraphClipboard\";\n\n// --- IMPORT THE LOGIC ---\nimport * as GraphLogic from \"../utils/GraphLogic\";\n\ntype InteractionMode = \"idle\" | \"drag\" | \"lasso\" | \"edge-create\" | \"resize\";\n\ninterface GraphCanvasProps {\n  graph: GraphModel;\n  onGraphChange: (newGraph: GraphModel) => void;\n  renderNode?: (node: Node, selected: boolean) => React.ReactNode;\n  renderContainer?: (container: Container, collapsed: boolean) => React.ReactNode;\n  enablePorts: boolean;\n  renderEditor: (entity: Entity, update: (u: Partial<Entity>) => void) => React.ReactNode;\n}\n\nexport const GraphCanvas = ({ graph, onGraphChange, renderNode, renderContainer, enablePorts, renderEditor }: GraphCanvasProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const [selectedEdgeId, setSelectedEdgeId] = useState<string | null>(null);\n\n  // 1. Hooks\n  const view = useGraphView(containerRef);\n  const selection = useGraphSelection(graph);\n  const clipboard = useGraphClipboard({\n    graph,\n    onGraphChange,\n    selectedNodes: selection.selectedNodes,\n    selectedContainerIds: selection.selectedContainerIds,\n    selectedEdgeId: selectedEdgeId,\n    clearSelection: selection.clearSelection,\n    setSelectedNodes: selection.setSelectedNodes,\n    setSelectedContainerIds: selection.setSelectedContainerIds,\n    setSelectedEdgeId: setSelectedEdgeId // Move to selection\n  });\n\n  // 3. Local Interaction State (Things that are too transient for their own hooks yet)\n  const [mode, setMode] = useState<InteractionMode>(\"idle\");\n  \n  // Dragging Entities\n  const [dragStartMouse, setDragStartMouse] = useState<Vec2 | null>(null);\n  const [dragStartPositions, setDragStartPositions] = useState<Map<ID, Vec2>>(new Map());\n  \n  // Creating Edges\n  const [creatingEdge, setCreatingEdge] = useState<{ sourceNodeId: ID; sourcePortId?: ID; position: Vec2 } | null>(null);\n  const [hoveredPort, setHoveredPort] = useState<{ nodeId: ID, portId: ID } | null>(null);\n\n  // Resize\n  const [resizingState, setResizingState] = useState<{ id: ID; startMouse: Vec2; startSize: any } | null>(null);\n  \n  // Menus\n  const [editingEntityId, setEditingEntityId] = useState<string | null>(null);\n  const [editorPosition, setEditorPosition] = useState<{ x: number, y: number } | null>(null);\n  const [canvasMenu, setCanvasMenu] = useState<{ \n    position: { x: number, y: number },      // For the HTML Menu (Screen UI)\n    graphPosition: { x: number, y: number }  // For the Node Logic (World Coords)\n  } | null>(null);\n\n\n  // --- Handlers ---\n\n  const handleMouseDown = (e: React.MouseEvent) => {\n    // 0. Pan Start (Middle Mouse or Space)\n    if (e.button === 1 || (e.button === 0 && e.nativeEvent.getModifierState(\"Space\"))) {\n      e.preventDefault();\n      view.startPan(e);\n      return;\n    }\n\n    // 1. Context Menu (Right Click)\n    if (e.button === 2) {\n      const screenPos = { x: e.clientX, y: e.clientY };\n      const graphPos = view.getMousePos(e); // The \"world\" coordinates\n\n      // Set the state with BOTH\n      setCanvasMenu({ \n        position: screenPos, \n        graphPosition: graphPos \n      });\n      return;\n    }\n\n    const pos = view.getGlobPos(e);\n\n    // 2. Canvas Click (Left) -> Start Lasso\n    if (e.button === 0) {\n      selection.clearSelection();\n      setEditingEntityId(null);\n      setCanvasMenu(null);\n      \n      setMode(\"lasso\");\n      selection.setLassoStart(pos);\n      selection.setLassoEnd(pos);\n    }\n  };\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    // 0. Panning\n    if (view.isPanning) {\n      view.updatePan(e);\n      return;\n    }\n\n    const mousePos = view.getMousePos(e);\n\n    // 1. Dragging Entities\n    if (mode === \"drag\" && dragStartMouse) {\n      const dx = mousePos.x - dragStartMouse.x;\n      const dy = mousePos.y - dragStartMouse.y;\n      const newGraph = graph.clone();\n      let changed = false;\n\n      dragStartPositions.forEach((startPos, id) => {\n        const node = newGraph.nodesById[id];\n        const container = newGraph.containersById[id];\n        if (node) { node.position = { x: startPos.x + dx, y: startPos.y + dy }; changed = true; }\n        if (container) { container.position = { x: startPos.x + dx, y: startPos.y + dy }; changed = true; }\n      });\n\n      if (changed) onGraphChange(newGraph);\n    }\n\n    // 2. Lasso\n    if (mode === \"lasso\") {\n      const lassoPos = view.getGlobPos(e);\n      selection.setLassoEnd(lassoPos);\n    }\n\n    // 3. Edge Create\n    if (mode === \"edge-create\" && creatingEdge) {\n      setCreatingEdge({ ...creatingEdge, position: mousePos });\n    }\n\n    // 4. Resize\n    if (mode === \"resize\" && resizingState) {\n       const dx = mousePos.x - resizingState.startMouse.x;\n       const dy = mousePos.y - resizingState.startMouse.y;\n       const newGraph = graph.clone();\n       const c = newGraph.containersById[resizingState.id];\n       if (c) {\n         c.size = { width: Math.max(100, resizingState.startSize.width + dx), height: Math.max(50, resizingState.startSize.height + dy) };\n         onGraphChange(newGraph);\n       }\n    }\n  };\n\n  const handleMouseUp = (e: React.MouseEvent) => {\n    if (view.isPanning) {\n      view.endPan();\n      return;\n    }\n\n    const pos = view.getMousePos(e);\n\n    const isClick = dragStartMouse && \n      Math.abs(pos.x - dragStartMouse.x) < 5 && \n      Math.abs(pos.y - dragStartMouse.y) < 5;\n\n    // 1. Open Editor (Click without drag)\n    if (mode === \"idle\" || (mode === \"drag\" && isClick)) {\n       const targetId = GraphLogic.hitTestEntity(graph, pos);\n       if (targetId) {\n          setEditingEntityId(targetId);\n          setEditorPosition({ x: pos.x, y: pos.y });\n          setMode(\"idle\");\n          return;\n       }\n    }\n\n    // 2. Lasso Finish\n    if (mode === \"lasso\") {\n      selection.completeLasso(view.zoom);\n    }\n\n    // 3. Drag Finish\n    if (mode === \"drag\" && dragStartMouse) {\n      // Re-parenting logic here (Drag Drop into Container)\n      const newGraph = graph.clone();\n      dragStartPositions.forEach((_, id) => {\n          GraphLogic.assignEntityToContainer(newGraph, id);\n          const parent = newGraph.nodesById[id]?.parentId || newGraph.containersById[id]?.parentId;\n          if (parent) GraphLogic.recomputeContainerSize(newGraph, parent);\n      });\n      onGraphChange(newGraph);\n      setDragStartMouse(null);\n      setDragStartPositions(new Map());\n    }\n\n    // 4. Edge Create Finish\n    if (mode === \"edge-create\" && creatingEdge) {\n        const targetNodeId = hoveredPort ? hoveredPort.nodeId : GraphLogic.hitTestEntity(graph, pos);\n\n        // Only proceed if we hit a valid target different from source\n        if (targetNodeId && targetNodeId !== creatingEdge.sourceNodeId) {\n\n            // START TRANSACTION (We might need to modify the graph multiple times)\n            let finalGraph = graph.clone();\n            let finalSourcePortId = creatingEdge.sourcePortId;\n            let finalTargetPortId = hoveredPort ? hoveredPort.portId : undefined;\n\n            // --- STEP 1: Handle Missing SOURCE Port ---\n            if (!finalSourcePortId && enablePorts) {\n                const label = window.prompt(\"Name the New Source Port:\", \"out-1\");\n                if (label) {\n                    const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n                    const sourceNode = finalGraph.nodesById[creatingEdge.sourceNodeId] || finalGraph.containersById[creatingEdge.sourceNodeId];\n\n                    if (!sourceNode.ports) sourceNode.ports = [];\n                    sourceNode.ports.push({ id: newPortId, label });\n\n                    finalSourcePortId = newPortId;\n                } else {\n                    setCreatingEdge(null);\n                    setMode(\"idle\");\n                    return;\n                }\n            }\n\n            // --- STEP 2: Handle Missing TARGET Port ---\n            if (!finalTargetPortId && enablePorts) {\n                const label = window.prompt(\"Name the New Target Port:\", \"in-1\");\n                if (label) {\n                    const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n                    const targetNode = finalGraph.nodesById[targetNodeId] || finalGraph.containersById[targetNodeId];\n\n                    if (!targetNode.ports) targetNode.ports = [];\n                    targetNode.ports.push({ id: newPortId, label });\n\n                    finalTargetPortId = newPortId;\n                } else {\n                    setCreatingEdge(null);\n                    setMode(\"idle\");\n                    return;\n                }\n            }\n\n            // --- STEP 3: Create the Edge ---\n            if ((!enablePorts) || (finalSourcePortId && finalTargetPortId)) {\n                const edgeId = `e_${crypto.randomUUID()}`;\n                finalGraph.edgesById[edgeId] = {\n                    id: edgeId,\n                    sourceNodeId: creatingEdge.sourceNodeId,\n                    sourcePortId: finalSourcePortId,\n                    targetNodeId: targetNodeId,\n                    targetPortId: finalTargetPortId\n                };\n\n                onGraphChange(finalGraph);\n            }\n        }\n\n        // Cleanup\n        setCreatingEdge(null);\n        setMode(\"idle\");\n    }\n\n    setMode(\"idle\");\n  };\n\n  const createPortAndStartDrag = (entityId: ID) => {\n    if (!enablePorts) return;\n\n    // 1. Prompt for Port Name\n    const label = window.prompt(\"Enter Source Port Name:\", \"out-1\");\n    if (!label) {\n      // User cancelled, cancel the edge creation\n      setCreatingEdge(null);\n      setMode(\"idle\");\n      return;\n    }\n\n    // 2. Create the Port in the Model\n    const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n    const newGraph = graph.clone();\n    \n    // Find the entity (Node or Container)\n    const target = newGraph.nodesById[entityId] || newGraph.containersById[entityId];\n    \n    if (target) {\n      if (!target.ports) target.ports = [];\n      target.ports.push({ id: newPortId, label });\n      onGraphChange(newGraph);\n\n      // 3. Link the currently creating edge to this new specific port\n      setCreatingEdge(prev => prev ? { ...prev, sourcePortId: newPortId } : null);\n    }\n  };\n\n  // --- Entity Event Wrappers ---\n  const handleEntityMouseDown = (e: React.MouseEvent, id: ID, type: \"node\" | \"container\") => {\n    e.stopPropagation();\n\n    // 1. Right Click -> Create Edge\n    if (e.button === 2) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Logic from your snippet: Start creating an edge\n      const mousePos = view.getMousePos(e);\n      \n      setMode(\"edge-create\");\n      setCreatingEdge({\n        sourceNodeId: id, // Assuming containers can also be sources if passed here\n        position: mousePos\n      });\n      \n      // Initialize the drag ghost/port\n      // Ensure this function exists in your scope and handles the entity type passed\n      createPortAndStartDrag(id); \n      \n      return;\n    }\n\n    // 2. Left Click -> Select & Prepare Drag\n    selection.handleEntityClick(e, id, type);\n    if (e.button === 0) {\n      setMode(\"drag\");\n      setDragStartMouse(view.getMousePos(e));\n\n      // --- FIX START ---\n      // Check if the item we clicked was ALREADY part of the selection\n      const isAlreadySelected = type === \"node\" \n        ? selection.selectedNodes.has(id) \n        : selection.selectedContainerIds.has(id);\n\n      // Check for modifier keys (Shift/Ctrl/Meta)\n      const isMultiSelect = e.shiftKey || e.metaKey || e.ctrlKey;\n\n      // Start with the EXISTING selection (stale state)\n      let nodesToDrag = new Set(selection.selectedNodes);\n      let containersToDrag = new Set(selection.selectedContainerIds);\n\n      // CRITICAL LOGIC: \n      // If we clicked a NEW item (not already selected) AND we aren't holding Shift...\n      // We must ignore the old selection and drag ONLY the new item.\n      if (!isAlreadySelected && !isMultiSelect) {\n         nodesToDrag.clear();\n         containersToDrag.clear();\n      }\n\n      // Always ensure the clicked item is included in the drag\n      if (type === \"node\") nodesToDrag.add(id);\n      else containersToDrag.add(id);\n      // --- FIX END ---\n\n      setDragStartPositions(\n        GraphLogic.collectDragStartPositions(\n           [...nodesToDrag, ...containersToDrag], \n           new Map(), \n           graph\n        )\n      ); \n    }\n  };\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"graph-canvas\"\n      style={{\n        position: \"relative\", width: \"100%\", height: \"100%\", overflow: \"hidden\",\n        userSelect: \"none\", cursor: view.isPanning ? \"grabbing\" : \"default\"\n      }}\n      //onWheel={view.handleWheel}\n      onMouseDown={handleMouseDown}\n      onMouseMove={handleMouseMove}\n      onMouseUp={handleMouseUp}\n      onContextMenu={(e) => e.preventDefault()}\n    >\n      <div style={{\n          transform: `translate(${view.view.x}px, ${view.view.y}px) scale(${view.view.zoom})`,\n          transformOrigin: \"0 0\", width: \"100%\", height: \"100%\", position: \"absolute\", top: 0, left: 0\n      }}>\n\n        \n        {/* Render Containers */}\n        {/*Object.values(graph.containersById).map(c => GraphLogic.isEntityVisible(graph, c.id) && (*/}\n        {Object.values(graph.containersById)\n        // 1. SORT: Render largest containers first (bottom layer), smallest last (top layer)\n          .sort((a, b) => (b.size.width * b.size.height) - (a.size.width * a.size.height))\n          .map(c => GraphLogic.isEntityVisible(graph, c.id) && (\n           <GraphContainer\n             key={c.id}\n             container={c}\n             selected={selection.selectedContainerIds.has(c.id)}\n             onMouseDown={(e) => handleEntityMouseDown(e, c.id, \"container\")}\n             onResizeMouseDown={(e) => {\n               e.stopPropagation();\n               setMode(\"resize\");\n               setResizingState({ id: c.id, startMouse: view.getMousePos(e), startSize: {...c.size} });\n             }}\n            onDoubleClick={(e) => {\n              e.stopPropagation();\n                // 1. Clone the graph\n                const newGraph = graph.clone();\n                \n                // 2. Find and toggle the container\n                const container = newGraph.containersById[c.id];\n                if (container) {\n                  container.collapsed = !container.collapsed;\n                  onGraphChange(newGraph);\n                }\n            }}\n           />\n        ))}\n\n        {/* Render Nodes */}\n        {Object.values(graph.nodesById).map(n => GraphLogic.isEntityVisible(graph, n.id) && (\n           <GraphNode\n             key={n.id}\n             node={n}\n             selected={selection.selectedNodes.has(n.id)}\n             onMouseDown={(e) => handleEntityMouseDown(e, n.id, \"node\")}\n           />\n        ))}\n\n        {/* Edges */}\n        <GraphEdgeLayer \n          graph={graph} \n          mode={mode} \n          creatingEdge={creatingEdge} \n          selectedEdgeId={selectedEdgeId}\n          onEdgeClick={(e, edgeId) => {\n            setSelectedEdgeId(edgeId);\n            selection.clearSelection();\n            \n            // Optional: Detect Double Click for Editing\n            if (e.detail === 2) {\n               setEditingEntityId(edgeId);\n               setEditorPosition(view.getMousePos(e));\n            }\n          }}\n        />\n        {/* Ports */}\n        <GraphPortLayer \n           graph={graph} \n           enablePorts={enablePorts} \n           hoveredPort={hoveredPort}\n           onHoverPort={setHoveredPort}\n           onPortMouseDown={(e, nodeId, portId, label, pos) => {\n              e.stopPropagation();\n              setCreatingEdge({ sourceNodeId: nodeId, sourcePortId: portId, position: pos });\n              setMode(\"edge-create\");\n           }}\n        />\n\n      </div>\n\n      {/* Lasso */}\n      {mode === \"lasso\" && selection.lassoStart && selection.lassoEnd && (\n        <Lasso start={selection.lassoStart} end={selection.lassoEnd} />\n      )}\n\n      {/* Popups */}\n      {editingEntityId && editorPosition && (\n        <EntityEditor \n          entityId={editingEntityId} \n          graph={graph} \n          position={editorPosition} \n          onClose={() => setEditingEntityId(null)} \n          onGraphChange={onGraphChange} \n          enablePorts={enablePorts} \n          renderCustomContent={renderEditor}\n        />\n      )}\n      \n      {/* CanvasMenu */}\n      {canvasMenu && (\n        <GraphContextMenu \n           canvasMenu={{...canvasMenu, targetId: undefined}}\n           graph={graph}\n           onGraphChange={onGraphChange}\n           onClose={() => setCanvasMenu(null)}\n        />\n      )}\n    </div>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}