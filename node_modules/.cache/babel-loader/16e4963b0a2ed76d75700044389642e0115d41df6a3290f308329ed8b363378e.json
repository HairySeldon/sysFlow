{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from \"react\";\nexport const useGraphView = containerRef => {\n  _s();\n  const [view, setView] = useState({\n    x: 0,\n    y: 0,\n    zoom: 1\n  });\n  const [isPanning, setIsPanning] = useState(false);\n  const [panStartMouse, setPanStartMouse] = useState(null);\n\n  // Helper: Convert Screen (Mouse) coords to World (Graph) coords\n  const getGlobPos = useCallback(e => {\n    if (!containerRef.current) return {\n      x: 0,\n      y: 0\n    };\n    const rect = containerRef.current.getBoundingClientRect();\n\n    // 2. Calculate coordinates relative to that container (0,0 is top-left of the canvas view)\n    const globX = e.clientX - containerRect.left;\n    const globY = e.clientY - containerRect.top;\n    return {\n      x: globX,\n      y: globY\n    };\n  }, [view, containerRef]);\n  const getMousePos = useCallback(e => {\n    const glob = getGlobPos(e);\n    return {\n      x: (glob.x - view.x) / view.zoom,\n      y: (glob.y - view.y) / view.zoom\n    };\n  }, [view, containerRef]);\n\n  // Handle Zoom and Pan via Wheel\n  const handleWheel = useCallback(e => {\n    // Ctrl+Scroll -> Zoom\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault();\n      if (!containerRef.current) return;\n      const rect = containerRef.current.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n\n      // World position before zoom\n      const worldX = (screenX - view.x) / view.zoom;\n      const worldY = (screenY - view.y) / view.zoom;\n\n      // Calc new zoom\n      const delta = -e.deltaY * 0.001;\n      const newZoom = Math.min(Math.max(0.1, view.zoom * (1 + delta)), 5);\n\n      // Adjust Pan to keep mouse over same world point\n      const newX = screenX - worldX * newZoom;\n      const newY = screenY - worldY * newZoom;\n      setView({\n        x: newX,\n        y: newY,\n        zoom: newZoom\n      });\n    } else {\n      // Standard Pan (Shift+Scroll or Trackpad)\n      setView(prev => ({\n        ...prev,\n        x: prev.x - e.deltaX,\n        y: prev.y - e.deltaY\n      }));\n    }\n  }, [view]);\n\n  // Manual Panning Handlers (Middle Mouse / Spacebar)\n  const startPan = e => {\n    setIsPanning(true);\n    setPanStartMouse({\n      x: e.clientX,\n      y: e.clientY\n    });\n  };\n  const updatePan = e => {\n    if (!isPanning || !panStartMouse) return;\n    const dx = e.clientX - panStartMouse.x;\n    const dy = e.clientY - panStartMouse.y;\n    setView(prev => ({\n      ...prev,\n      x: prev.x + dx,\n      y: prev.y + dy\n    }));\n    setPanStartMouse({\n      x: e.clientX,\n      y: e.clientY\n    });\n  };\n  const endPan = () => {\n    setIsPanning(false);\n    setPanStartMouse(null);\n  };\n  return {\n    view,\n    setView,\n    isPanning,\n    getMousePos,\n    getGlobPos,\n    handleWheel,\n    startPan,\n    updatePan,\n    endPan\n  };\n};\n_s(useGraphView, \"eS/IgtRaC58+ctzHpzYWLhmQ2Ks=\");","map":{"version":3,"names":["useState","useCallback","useGraphView","containerRef","_s","view","setView","x","y","zoom","isPanning","setIsPanning","panStartMouse","setPanStartMouse","getGlobPos","e","current","rect","getBoundingClientRect","globX","clientX","containerRect","left","globY","clientY","top","getMousePos","glob","handleWheel","ctrlKey","metaKey","preventDefault","screenX","screenY","worldX","worldY","delta","deltaY","newZoom","Math","min","max","newX","newY","prev","deltaX","startPan","updatePan","dx","dy","endPan"],"sources":["/home/belac/sysFlow/src/hooks/useGraphView.ts"],"sourcesContent":["import { useState, useCallback } from \"react\";\nimport { Vec2 } from \"../models/Entity\";\n\nexport const useGraphView = (containerRef: React.RefObject<HTMLDivElement | null>) => {\n  const [view, setView] = useState({ x: 0, y: 0, zoom: 1 });\n  const [isPanning, setIsPanning] = useState(false);\n  const [panStartMouse, setPanStartMouse] = useState<Vec2 | null>(null);\n\n  // Helper: Convert Screen (Mouse) coords to World (Graph) coords\n  const getGlobPos = useCallback((e: React.MouseEvent | MouseEvent): Vec2 => {\n    if (!containerRef.current) return { x: 0, y: 0 };\n    const rect = containerRef.current.getBoundingClientRect();\n\n    // 2. Calculate coordinates relative to that container (0,0 is top-left of the canvas view)\n    const globX = e.clientX - containerRect.left;\n    const globY = e.clientY - containerRect.top;\n    return { x: globX, y: globY};\n  }, [view, containerRef]);\n\n  const getMousePos = useCallback((e: React.MouseEvent | MouseEvent): Vec2 => {\n    const glob = getGlobPos(e);\n    return {\n      x: (glob.x - view.x) / view.zoom,\n      y: (glob.y - view.y) / view.zoom\n    };\n  }, [view, containerRef]);\n\n  // Handle Zoom and Pan via Wheel\n  const handleWheel = useCallback((e: React.WheelEvent) => {\n    // Ctrl+Scroll -> Zoom\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault();\n      if (!containerRef.current) return;\n\n      const rect = containerRef.current.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n\n      // World position before zoom\n      const worldX = (screenX - view.x) / view.zoom;\n      const worldY = (screenY - view.y) / view.zoom;\n\n      // Calc new zoom\n      const delta = -e.deltaY * 0.001;\n      const newZoom = Math.min(Math.max(0.1, view.zoom * (1 + delta)), 5);\n\n      // Adjust Pan to keep mouse over same world point\n      const newX = screenX - (worldX * newZoom);\n      const newY = screenY - (worldY * newZoom);\n\n      setView({ x: newX, y: newY, zoom: newZoom });\n    } else {\n      // Standard Pan (Shift+Scroll or Trackpad)\n      setView(prev => ({\n        ...prev,\n        x: prev.x - e.deltaX,\n        y: prev.y - e.deltaY\n      }));\n    }\n  }, [view]);\n\n  // Manual Panning Handlers (Middle Mouse / Spacebar)\n  const startPan = (e: React.MouseEvent) => {\n    setIsPanning(true);\n    setPanStartMouse({ x: e.clientX, y: e.clientY });\n  };\n\n  const updatePan = (e: React.MouseEvent) => {\n    if (!isPanning || !panStartMouse) return;\n    const dx = e.clientX - panStartMouse.x;\n    const dy = e.clientY - panStartMouse.y;\n    setView(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));\n    setPanStartMouse({ x: e.clientX, y: e.clientY });\n  };\n\n  const endPan = () => {\n    setIsPanning(false);\n    setPanStartMouse(null);\n  };\n\n  return {\n    view,\n    setView,\n    isPanning,\n    getMousePos,\n    getGlobPos,\n    handleWheel,\n    startPan,\n    updatePan,\n    endPan\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}