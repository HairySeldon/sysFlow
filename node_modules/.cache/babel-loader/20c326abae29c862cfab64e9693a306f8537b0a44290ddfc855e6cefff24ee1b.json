{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from \"react\";\nexport const useGraphClipboard = ({\n  graph,\n  selectedNodes,\n  selectedContainerIds,\n  onGraphChange,\n  clearSelection,\n  setSelectedNodes,\n  setSelectedContainerIds,\n  selectedEdgeId,\n  setSelectedEdgeId,\n  onStartEditing\n}) => {\n  _s();\n  const [clipboard, setClipboard] = useState(null);\n  const selectAll = () => {\n    const allNodesIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodesIds);\n    setSelectedContainerIds(allContainerIds);\n  };\n  const deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n    const newGraph = graph.clone();\n    selectedNodes.forEach(id => newGraph.removeNode(id));\n    selectedContainerIds.forEach(id => newGraph.removeContainer(id));\n    onGraphChange(newGraph);\n    clearSelection();\n  };\n  const copy = e => {\n    e.preventDefault();\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n\n    // Only copy edges if both ends are selected\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge => allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId));\n    const clipboardData = {\n      nodes: nodesToCopy,\n      containers: containersToCopy,\n      edges: edgesToCopy\n    };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n  const paste = e => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      const idMap = new Map();\n      const newSelectedNodes = new Set();\n      const newSelectedContainers = new Set();\n\n      // ... [Insert your existing Paste Logic here, reused exactly] ...\n      // 1. Paste Containers\n      data.containers.forEach(c => {\n        const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(c.id, newId);\n        newGraph.containersById[newId] = {\n          ...c,\n          id: newId,\n          position: {\n            x: c.position.x + 20,\n            y: c.position.y + 20\n          },\n          nodeIds: [],\n          childContainerIds: []\n        };\n        newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach(n => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = {\n          ...n,\n          id: newId,\n          position: {\n            x: n.position.x + 20,\n            y: n.position.y + 20\n          },\n          parentId: n.parentId ? idMap.get(n.parentId) : undefined\n        };\n        newSelectedNodes.add(newId);\n        if (n.parentId && idMap.has(n.parentId)) {\n          var _newGraph$containersB;\n          (_newGraph$containersB = newGraph.containersById[idMap.get(n.parentId)]) === null || _newGraph$containersB === void 0 ? void 0 : _newGraph$containersB.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges\n      data.edges.forEach(e => {\n        const newSource = idMap.get(e.sourceNodeId);\n        const newTarget = idMap.get(e.targetNodeId);\n        if (newSource && newTarget) {\n          const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n          newGraph.edgesById[newEdgeId] = {\n            ...e,\n            id: newEdgeId,\n            sourceNodeId: newSource,\n            targetNodeId: newTarget\n          };\n        }\n      });\n      onGraphChange(newGraph);\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n    } catch (err) {\n      console.error(\"Paste failed\", err);\n    }\n  };\n\n  // Keyboard Listener\n  useEffect(() => {\n    const handleKeyDown = e => {\n      if (e.target.tagName === \"INPUT\") return;\n      if (e.key === \"Delete\" || e.key === \"Backspace\") deleteSelected();\n      if (e.key === \"Escape\") clearSelection();\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") selectAll();\n        if (e.key === \"c\") copy(e);\n        if (e.key === \"x\") {\n          copy(e);\n          deleteSelected();\n        }\n        if (e.key === \"v\") paste(e);\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, clipboard]); // Dependencies\n\n  return {\n    deleteSelected,\n    copy,\n    paste\n  };\n};\n_s(useGraphClipboard, \"1H+Q2r5p85WO+8m7YfmWK/uQKVg=\");","map":{"version":3,"names":["useState","useEffect","useGraphClipboard","graph","selectedNodes","selectedContainerIds","onGraphChange","clearSelection","setSelectedNodes","setSelectedContainerIds","selectedEdgeId","setSelectedEdgeId","onStartEditing","_s","clipboard","setClipboard","selectAll","allNodesIds","Set","Object","keys","nodesById","allContainerIds","containersById","deleteSelected","size","newGraph","clone","forEach","id","removeNode","removeContainer","copy","e","preventDefault","nodesToCopy","values","filter","n","has","containersToCopy","c","allSelectedIds","edgesToCopy","edgesById","edge","sourceNodeId","targetNodeId","clipboardData","nodes","containers","edges","JSON","stringify","paste","data","parse","idMap","Map","newSelectedNodes","newSelectedContainers","newId","crypto","randomUUID","slice","set","position","x","y","nodeIds","childContainerIds","add","parentId","get","undefined","_newGraph$containersB","push","newSource","newTarget","newEdgeId","err","console","error","handleKeyDown","target","tagName","key","ctrlKey","metaKey","window","addEventListener","removeEventListener"],"sources":["/home/belac/sysFlow/src/hooks/useGraphClipboard.ts"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\n\ninterface UseGraphClipboardProps {\n  graph: GraphModel;\n  selectedNodes: Set<string>;\n  selectedContainerIds: Set<string>;\n  onGraphChange: (newGraph: GraphModel) => void;\n  clearSelection: () => void;\n  setSelectedNodes: (ids: Set<string>) => void;\n  setSelectedContainerIds: (ids: Set<string>) => void;\n}\n\nexport const useGraphClipboard = ({\n  graph,\n  selectedNodes,\n  selectedContainerIds,\n  onGraphChange,\n  clearSelection,\n  setSelectedNodes,\n  setSelectedContainerIds,\n  selectedEdgeId,\n  setSelectedEdgeId,\n  onStartEditing\n}: UseGraphClipboardProps) => {\n  const [clipboard, setClipboard] = useState<string | null>(null);\n\n  const selectAll = () => {\n    const allNodesIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodesIds);\n    setSelectedContainerIds(allContainerIds);\n  };\n\n  const deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n    const newGraph = graph.clone();\n    selectedNodes.forEach((id) => newGraph.removeNode(id));\n    selectedContainerIds.forEach((id) => newGraph.removeContainer(id));\n    onGraphChange(newGraph);\n    clearSelection();\n  };\n\n  const copy = (e: KeyboardEvent) => {\n    e.preventDefault();\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n    \n    // Only copy edges if both ends are selected\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge =>\n      allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId)\n    );\n\n    const clipboardData = { nodes: nodesToCopy, containers: containersToCopy, edges: edgesToCopy };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n\n  const paste = (e: KeyboardEvent) => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      const idMap = new Map<string, string>();\n      const newSelectedNodes = new Set<string>();\n      const newSelectedContainers = new Set<string>();\n\n      // ... [Insert your existing Paste Logic here, reused exactly] ...\n      // 1. Paste Containers\n      data.containers.forEach((c: any) => {\n          const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n          idMap.set(c.id, newId);\n          newGraph.containersById[newId] = { ...c, id: newId, position: { x: c.position.x + 20, y: c.position.y + 20 }, nodeIds: [], childContainerIds: [] };\n          newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach((n: any) => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = { ...n, id: newId, position: { x: n.position.x + 20, y: n.position.y + 20 }, parentId: n.parentId ? idMap.get(n.parentId) : undefined };\n        newSelectedNodes.add(newId);\n        if (n.parentId && idMap.has(n.parentId)) {\n            newGraph.containersById[idMap.get(n.parentId)!]?.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges\n      data.edges.forEach((e: any) => {\n        const newSource = idMap.get(e.sourceNodeId);\n        const newTarget = idMap.get(e.targetNodeId);\n        if (newSource && newTarget) {\n            const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n            newGraph.edgesById[newEdgeId] = { ...e, id: newEdgeId, sourceNodeId: newSource, targetNodeId: newTarget };\n        }\n      });\n\n      onGraphChange(newGraph);\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n    } catch (err) { console.error(\"Paste failed\", err); }\n  };\n\n  // Keyboard Listener\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if ((e.target as HTMLElement).tagName === \"INPUT\") return;\n      if (e.key === \"Delete\" || e.key === \"Backspace\") deleteSelected();\n      if (e.key === \"Escape\") clearSelection();\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") selectAll();\n        if (e.key === \"c\") copy(e);\n        if (e.key === \"x\") { copy(e); deleteSelected(); }\n        if (e.key === \"v\") paste(e);\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, clipboard]); // Dependencies\n\n  return { deleteSelected, copy, paste };\n\n};\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAa3C,OAAO,MAAMC,iBAAiB,GAAGA,CAAC;EAChCC,KAAK;EACLC,aAAa;EACbC,oBAAoB;EACpBC,aAAa;EACbC,cAAc;EACdC,gBAAgB;EAChBC,uBAAuB;EACvBC,cAAc;EACdC,iBAAiB;EACjBC;AACsB,CAAC,KAAK;EAAAC,EAAA;EAC5B,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGf,QAAQ,CAAgB,IAAI,CAAC;EAE/D,MAAMgB,SAAS,GAAGA,CAAA,KAAM;IACtB,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAACC,MAAM,CAACC,IAAI,CAACjB,KAAK,CAACkB,SAAS,CAAC,CAAC;IACzD,MAAMC,eAAe,GAAG,IAAIJ,GAAG,CAACC,MAAM,CAACC,IAAI,CAACjB,KAAK,CAACoB,cAAc,CAAC,CAAC;IAClEf,gBAAgB,CAACS,WAAW,CAAC;IAC7BR,uBAAuB,CAACa,eAAe,CAAC;EAC1C,CAAC;EAED,MAAME,cAAc,GAAGA,CAAA,KAAM;IAC3B,IAAIpB,aAAa,CAACqB,IAAI,KAAK,CAAC,IAAIpB,oBAAoB,CAACoB,IAAI,KAAK,CAAC,EAAE;IACjE,MAAMC,QAAQ,GAAGvB,KAAK,CAACwB,KAAK,CAAC,CAAC;IAC9BvB,aAAa,CAACwB,OAAO,CAAEC,EAAE,IAAKH,QAAQ,CAACI,UAAU,CAACD,EAAE,CAAC,CAAC;IACtDxB,oBAAoB,CAACuB,OAAO,CAAEC,EAAE,IAAKH,QAAQ,CAACK,eAAe,CAACF,EAAE,CAAC,CAAC;IAClEvB,aAAa,CAACoB,QAAQ,CAAC;IACvBnB,cAAc,CAAC,CAAC;EAClB,CAAC;EAED,MAAMyB,IAAI,GAAIC,CAAgB,IAAK;IACjCA,CAAC,CAACC,cAAc,CAAC,CAAC;IAClB,MAAMC,WAAW,GAAGhB,MAAM,CAACiB,MAAM,CAACjC,KAAK,CAACkB,SAAS,CAAC,CAACgB,MAAM,CAACC,CAAC,IAAIlC,aAAa,CAACmC,GAAG,CAACD,CAAC,CAACT,EAAE,CAAC,CAAC;IACvF,MAAMW,gBAAgB,GAAGrB,MAAM,CAACiB,MAAM,CAACjC,KAAK,CAACoB,cAAc,CAAC,CAACc,MAAM,CAACI,CAAC,IAAIpC,oBAAoB,CAACkC,GAAG,CAACE,CAAC,CAACZ,EAAE,CAAC,CAAC;;IAExG;IACA,MAAMa,cAAc,GAAG,IAAIxB,GAAG,CAAC,CAAC,GAAGd,aAAa,EAAE,GAAGC,oBAAoB,CAAC,CAAC;IAC3E,MAAMsC,WAAW,GAAGxB,MAAM,CAACiB,MAAM,CAACjC,KAAK,CAACyC,SAAS,CAAC,CAACP,MAAM,CAACQ,IAAI,IAC5DH,cAAc,CAACH,GAAG,CAACM,IAAI,CAACC,YAAY,CAAC,IAAIJ,cAAc,CAACH,GAAG,CAACM,IAAI,CAACE,YAAY,CAC/E,CAAC;IAED,MAAMC,aAAa,GAAG;MAAEC,KAAK,EAAEd,WAAW;MAAEe,UAAU,EAAEV,gBAAgB;MAAEW,KAAK,EAAER;IAAY,CAAC;IAC9F5B,YAAY,CAACqC,IAAI,CAACC,SAAS,CAACL,aAAa,CAAC,CAAC;EAC7C,CAAC;EAED,MAAMM,KAAK,GAAIrB,CAAgB,IAAK;IAClCA,CAAC,CAACC,cAAc,CAAC,CAAC;IAClB,IAAI,CAACpB,SAAS,EAAE;IAChB,IAAI;MACF,MAAMyC,IAAI,GAAGH,IAAI,CAACI,KAAK,CAAC1C,SAAS,CAAC;MAClC,MAAMY,QAAQ,GAAGvB,KAAK,CAACwB,KAAK,CAAC,CAAC;MAC9B,MAAM8B,KAAK,GAAG,IAAIC,GAAG,CAAiB,CAAC;MACvC,MAAMC,gBAAgB,GAAG,IAAIzC,GAAG,CAAS,CAAC;MAC1C,MAAM0C,qBAAqB,GAAG,IAAI1C,GAAG,CAAS,CAAC;;MAE/C;MACA;MACAqC,IAAI,CAACL,UAAU,CAACtB,OAAO,CAAEa,CAAM,IAAK;QAChC,MAAMoB,KAAK,GAAG,KAAKC,MAAM,CAACC,UAAU,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;QACpDP,KAAK,CAACQ,GAAG,CAACxB,CAAC,CAACZ,EAAE,EAAEgC,KAAK,CAAC;QACtBnC,QAAQ,CAACH,cAAc,CAACsC,KAAK,CAAC,GAAG;UAAE,GAAGpB,CAAC;UAAEZ,EAAE,EAAEgC,KAAK;UAAEK,QAAQ,EAAE;YAAEC,CAAC,EAAE1B,CAAC,CAACyB,QAAQ,CAACC,CAAC,GAAG,EAAE;YAAEC,CAAC,EAAE3B,CAAC,CAACyB,QAAQ,CAACE,CAAC,GAAG;UAAG,CAAC;UAAEC,OAAO,EAAE,EAAE;UAAEC,iBAAiB,EAAE;QAAG,CAAC;QAClJV,qBAAqB,CAACW,GAAG,CAACV,KAAK,CAAC;MACpC,CAAC,CAAC;;MAEF;MACAN,IAAI,CAACN,KAAK,CAACrB,OAAO,CAAEU,CAAM,IAAK;QAC7B,MAAMuB,KAAK,GAAG,KAAKC,MAAM,CAACC,UAAU,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;QACpDP,KAAK,CAACQ,GAAG,CAAC3B,CAAC,CAACT,EAAE,EAAEgC,KAAK,CAAC;QACtBnC,QAAQ,CAACL,SAAS,CAACwC,KAAK,CAAC,GAAG;UAAE,GAAGvB,CAAC;UAAET,EAAE,EAAEgC,KAAK;UAAEK,QAAQ,EAAE;YAAEC,CAAC,EAAE7B,CAAC,CAAC4B,QAAQ,CAACC,CAAC,GAAG,EAAE;YAAEC,CAAC,EAAE9B,CAAC,CAAC4B,QAAQ,CAACE,CAAC,GAAG;UAAG,CAAC;UAAEI,QAAQ,EAAElC,CAAC,CAACkC,QAAQ,GAAGf,KAAK,CAACgB,GAAG,CAACnC,CAAC,CAACkC,QAAQ,CAAC,GAAGE;QAAU,CAAC;QACnKf,gBAAgB,CAACY,GAAG,CAACV,KAAK,CAAC;QAC3B,IAAIvB,CAAC,CAACkC,QAAQ,IAAIf,KAAK,CAAClB,GAAG,CAACD,CAAC,CAACkC,QAAQ,CAAC,EAAE;UAAA,IAAAG,qBAAA;UACrC,CAAAA,qBAAA,GAAAjD,QAAQ,CAACH,cAAc,CAACkC,KAAK,CAACgB,GAAG,CAACnC,CAAC,CAACkC,QAAQ,CAAC,CAAE,cAAAG,qBAAA,uBAA/CA,qBAAA,CAAiDN,OAAO,CAACO,IAAI,CAACf,KAAK,CAAC;QACxE;MACF,CAAC,CAAC;;MAEF;MACAN,IAAI,CAACJ,KAAK,CAACvB,OAAO,CAAEK,CAAM,IAAK;QAC7B,MAAM4C,SAAS,GAAGpB,KAAK,CAACgB,GAAG,CAACxC,CAAC,CAACa,YAAY,CAAC;QAC3C,MAAMgC,SAAS,GAAGrB,KAAK,CAACgB,GAAG,CAACxC,CAAC,CAACc,YAAY,CAAC;QAC3C,IAAI8B,SAAS,IAAIC,SAAS,EAAE;UACxB,MAAMC,SAAS,GAAG,KAAKjB,MAAM,CAACC,UAAU,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;UACxDtC,QAAQ,CAACkB,SAAS,CAACmC,SAAS,CAAC,GAAG;YAAE,GAAG9C,CAAC;YAAEJ,EAAE,EAAEkD,SAAS;YAAEjC,YAAY,EAAE+B,SAAS;YAAE9B,YAAY,EAAE+B;UAAU,CAAC;QAC7G;MACF,CAAC,CAAC;MAEFxE,aAAa,CAACoB,QAAQ,CAAC;MACvBlB,gBAAgB,CAACmD,gBAAgB,CAAC;MAClClD,uBAAuB,CAACmD,qBAAqB,CAAC;IAChD,CAAC,CAAC,OAAOoB,GAAG,EAAE;MAAEC,OAAO,CAACC,KAAK,CAAC,cAAc,EAAEF,GAAG,CAAC;IAAE;EACtD,CAAC;;EAED;EACA/E,SAAS,CAAC,MAAM;IACd,MAAMkF,aAAa,GAAIlD,CAAgB,IAAK;MAC1C,IAAKA,CAAC,CAACmD,MAAM,CAAiBC,OAAO,KAAK,OAAO,EAAE;MACnD,IAAIpD,CAAC,CAACqD,GAAG,KAAK,QAAQ,IAAIrD,CAAC,CAACqD,GAAG,KAAK,WAAW,EAAE9D,cAAc,CAAC,CAAC;MACjE,IAAIS,CAAC,CAACqD,GAAG,KAAK,QAAQ,EAAE/E,cAAc,CAAC,CAAC;MACxC,IAAI0B,CAAC,CAACsD,OAAO,IAAItD,CAAC,CAACuD,OAAO,EAAE;QAC1B,IAAIvD,CAAC,CAACqD,GAAG,KAAK,GAAG,EAAEtE,SAAS,CAAC,CAAC;QAC9B,IAAIiB,CAAC,CAACqD,GAAG,KAAK,GAAG,EAAEtD,IAAI,CAACC,CAAC,CAAC;QAC1B,IAAIA,CAAC,CAACqD,GAAG,KAAK,GAAG,EAAE;UAAEtD,IAAI,CAACC,CAAC,CAAC;UAAET,cAAc,CAAC,CAAC;QAAE;QAChD,IAAIS,CAAC,CAACqD,GAAG,KAAK,GAAG,EAAEhC,KAAK,CAACrB,CAAC,CAAC;MAC7B;IACF,CAAC;IACDwD,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEP,aAAa,CAAC;IACjD,OAAO,MAAMM,MAAM,CAACE,mBAAmB,CAAC,SAAS,EAAER,aAAa,CAAC;EACnE,CAAC,EAAE,CAAChF,KAAK,EAAEC,aAAa,EAAEC,oBAAoB,EAAES,SAAS,CAAC,CAAC,CAAC,CAAC;;EAE7D,OAAO;IAAEU,cAAc;IAAEQ,IAAI;IAAEsB;EAAM,CAAC;AAExC,CAAC;AAACzC,EAAA,CA9GWX,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}