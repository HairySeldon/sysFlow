{"ast":null,"code":"// utils/Geometry.ts\n\n// Assuming you have a Graph model export\n\n/**\n * Calculates the exact (x,y) screen coordinate for a specific port on an entity.\n */\nexport const getPortPosition = (entity, portId, graph, entitySize) => {\n  const center = getCenter(entity.position, entitySize);\n\n  // 1. Find if this port is connected to an edge\n  // We need to look for an edge where this port is either source or target\n  const connectedEdge = Object.values(graph.edgesById).find(e => e.sourceNodeId === entity.id && e.sourcePortId === portId || e.targetNodeId === entity.id && e.targetPortId === portId);\n  if (connectedEdge) {\n    // --- CASE A: Connected (Dynamic Position) ---\n    // The port should \"slide\" to face the other node.\n\n    // Determine the ID of the *other* node\n    const isSource = connectedEdge.sourceNodeId === entity.id;\n    const targetNodeId = isSource ? connectedEdge.targetNodeId : connectedEdge.sourceNodeId;\n    const targetEntity = graph.nodesById[targetNodeId] || graph.containersById[targetNodeId];\n    if (!targetEntity) return center; // Fallback\n\n    // Get the center of the target (approximate, since we don't have target size easily here. \n    // In a real app, you might pass a lookup or store size on Entity).\n    // For now, let's assume target position + 50 offset if size unknown, \n    // or you can pass a full entity map with sizes.\n    // simpler: Just use targetEntity.position for calculation direction\n    const targetCenter = {\n      x: targetEntity.position.x + 50,\n      y: targetEntity.position.y + 20\n    };\n\n    // Use the intersection logic to find the edge point\n    return getRectIntersection(center, entitySize, targetCenter);\n  } else {\n    // --- CASE B: Unconnected (Static Distribution) ---\n    // Distribute unconnected ports along the LEFT edge.\n\n    // Find index of this port among ALL unconnected ports to space them out\n    const unconnectedPorts = (entity.ports || []).filter(p => {\n      return !Object.values(graph.edgesById).some(e => e.sourceNodeId === entity.id && e.sourcePortId === p.id || e.targetNodeId === entity.id && e.targetPortId === p.id);\n    });\n    const index = unconnectedPorts.findIndex(p => p.id === portId);\n    if (index === -1) return center; // Should not happen\n\n    // Space them evenly\n    const step = entitySize.height / (unconnectedPorts.length + 1);\n    return {\n      x: entity.position.x,\n      // Left edge\n      y: entity.position.y + step * (index + 1)\n    };\n  }\n};\n\n/**\n * Calculates the intersection point between a line (from center to target)\n * and the bounding box of the source node.\n */\nexport const getRectIntersection = (center, size, target,\n// The point we are connecting TO\npadding = 0 // Offset for the port circle (e.g. half its radius)\n) => {\n  const dx = target.x - center.x;\n  const dy = target.y - center.y;\n\n  // Avoid division by zero\n  if (dx === 0 && dy === 0) return {\n    ...center\n  };\n\n  // Half dimensions\n  const hw = size.width / 2;\n  const hh = size.height / 2;\n\n  // Calculate the \"scale\" needed to stretch the vector (dx, dy) \n  // until it hits the box wall.\n  // We check both X and Y constraints and pick the smaller scale (the one hit first).\n  const scaleX = hw / Math.abs(dx);\n  const scaleY = hh / Math.abs(dy);\n  const scale = Math.min(scaleX, scaleY);\n  return {\n    x: center.x + dx * scale,\n    y: center.y + dy * scale\n  };\n};\n\n// Helper to get center of a node/container\nexport const getCenter = (pos, size) => ({\n  x: pos.x + size.width / 2,\n  y: pos.y + size.height / 2\n});","map":{"version":3,"names":["getPortPosition","entity","portId","graph","entitySize","center","getCenter","position","connectedEdge","Object","values","edgesById","find","e","sourceNodeId","id","sourcePortId","targetNodeId","targetPortId","isSource","targetEntity","nodesById","containersById","targetCenter","x","y","getRectIntersection","unconnectedPorts","ports","filter","p","some","index","findIndex","step","height","length","size","target","padding","dx","dy","hw","width","hh","scaleX","Math","abs","scaleY","scale","min","pos"],"sources":["/home/belac/sysFlow/src/utils/Geometry.ts"],"sourcesContent":["// utils/Geometry.ts\nimport { Entity, Vec2, SIZE, Port, ID } from \"../models/Entity\";\nimport { Edge } from \"../models/Edge\";\nimport { GraphModel } from \"../models/GraphModel\"; // Assuming you have a Graph model export\n\n/**\n * Calculates the exact (x,y) screen coordinate for a specific port on an entity.\n */\nexport const getPortPosition = (\n  entity: Entity,\n  portId: ID,\n  graph: GraphModel,\n  entitySize: SIZE\n): Vec2 => {\n  const center = getCenter(entity.position, entitySize);\n  \n  // 1. Find if this port is connected to an edge\n  // We need to look for an edge where this port is either source or target\n  const connectedEdge = Object.values(graph.edgesById).find(\n    (e) => \n      (e.sourceNodeId === entity.id && e.sourcePortId === portId) || \n      (e.targetNodeId === entity.id && e.targetPortId === portId)\n  );\n\n  if (connectedEdge) {\n    // --- CASE A: Connected (Dynamic Position) ---\n    // The port should \"slide\" to face the other node.\n    \n    // Determine the ID of the *other* node\n    const isSource = connectedEdge.sourceNodeId === entity.id;\n    const targetNodeId = isSource ? connectedEdge.targetNodeId : connectedEdge.sourceNodeId;\n    const targetEntity = graph.nodesById[targetNodeId] || graph.containersById[targetNodeId];\n\n    if (!targetEntity) return center; // Fallback\n\n    // Get the center of the target (approximate, since we don't have target size easily here. \n    // In a real app, you might pass a lookup or store size on Entity).\n    // For now, let's assume target position + 50 offset if size unknown, \n    // or you can pass a full entity map with sizes.\n    // simpler: Just use targetEntity.position for calculation direction\n    const targetCenter = { x: targetEntity.position.x + 50, y: targetEntity.position.y + 20 };\n    \n    // Use the intersection logic to find the edge point\n    return getRectIntersection(center, entitySize, targetCenter);\n  } else {\n    // --- CASE B: Unconnected (Static Distribution) ---\n    // Distribute unconnected ports along the LEFT edge.\n    \n    // Find index of this port among ALL unconnected ports to space them out\n    const unconnectedPorts = (entity.ports || []).filter(p => {\n       return !Object.values(graph.edgesById).some(e => \n        (e.sourceNodeId === entity.id && e.sourcePortId === p.id) ||\n        (e.targetNodeId === entity.id && e.targetPortId === p.id)\n       );\n    });\n\n    const index = unconnectedPorts.findIndex(p => p.id === portId);\n    if (index === -1) return center; // Should not happen\n\n    // Space them evenly\n    const step = entitySize.height / (unconnectedPorts.length + 1);\n    return {\n      x: entity.position.x, // Left edge\n      y: entity.position.y + step * (index + 1)\n    };\n  }\n};\n\n/**\n * Calculates the intersection point between a line (from center to target)\n * and the bounding box of the source node.\n */\nexport const getRectIntersection = (\n  center: Vec2,      // Center of the source node\n  size: { width: number; height: number },\n  target: Vec2,      // The point we are connecting TO\n  padding: number = 0 // Offset for the port circle (e.g. half its radius)\n): Vec2 => {\n  const dx = target.x - center.x;\n  const dy = target.y - center.y;\n\n  // Avoid division by zero\n  if (dx === 0 && dy === 0) return { ...center };\n\n  // Half dimensions\n  const hw = size.width / 2;\n  const hh = size.height / 2;\n\n  // Calculate the \"scale\" needed to stretch the vector (dx, dy) \n  // until it hits the box wall.\n  // We check both X and Y constraints and pick the smaller scale (the one hit first).\n  const scaleX = hw / Math.abs(dx);\n  const scaleY = hh / Math.abs(dy);\n  \n  const scale = Math.min(scaleX, scaleY);\n\n  return {\n    x: center.x + dx * scale,\n    y: center.y + dy * scale,\n  };\n};\n\n// Helper to get center of a node/container\nexport const getCenter = (pos: Vec2, size: { width: number; height: number }): Vec2 => ({\n  x: pos.x + size.width / 2,\n  y: pos.y + size.height / 2,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}