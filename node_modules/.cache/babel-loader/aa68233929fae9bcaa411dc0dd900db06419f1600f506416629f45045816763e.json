{"ast":null,"code":"export class GraphModel {\n  constructor() {\n    this.nodesById = {};\n    this.containersById = {};\n    this.edgesById = {};\n  }\n  addNode(node) {\n    this.nodesById[node.id] = node;\n  }\n  addContainer(container) {\n    this.containersById[container.id] = container;\n  }\n  addEdge(edge) {\n    this.edgesById[edge.id] = edge;\n  }\n  getNode(id) {\n    return this.nodesById[id];\n  }\n  getContainer(id) {\n    return this.containersById[id];\n  }\n  moveNode(id, pos) {\n    const n = this.getNode(id);\n    if (n) n.position = pos;\n  }\n  moveContainer(id, pos) {\n    const c = this.getContainer(id);\n    if (c) c.position = pos;\n  }\n\n  // --- SAFE REMOVAL METHODS ---\n\n  // UPDATED: Safely remove a node, its edges, and its reference from parents\n  removeNode(id) {\n    const node = this.nodesById[id];\n    if (!node) return;\n\n    // 1. Remove all edges connected to this node\n    Object.values(this.edgesById).forEach(edge => {\n      if (edge.sourceNodeId === id || edge.targetNodeId === id) {\n        delete this.edgesById[edge.id];\n      }\n    });\n\n    // 2. Remove node from its parent container (if it has one)\n    if (node.parentId) {\n      const parent = this.containersById[node.parentId];\n      if (parent) {\n        parent.nodeIds = parent.nodeIds.filter(nid => nid !== id);\n      }\n    }\n\n    // 3. Finally, delete the node\n    delete this.nodesById[id];\n  }\n  removeEdge(id) {\n    delete this.edgesById[id];\n  }\n\n  // ADDED: The missing method required by GraphCanvas\n  removeContainer(id) {\n    const container = this.containersById[id];\n    if (!container) return;\n\n    // 1. Remove this container from its parent's list (if nested)\n    if (container.parentId) {\n      const parent = this.containersById[container.parentId];\n      if (parent && parent.childContainerIds) {\n        parent.childContainerIds = parent.childContainerIds.filter(cid => cid !== id);\n      }\n    }\n\n    // 2. Recursively delete everything inside it\n    this.removeContainerRecursive(id);\n  }\n\n  // Existing recursive helper (called by removeContainer)\n  removeContainerRecursive(id) {\n    const c = this.containersById[id];\n    if (!c) return;\n\n    // Delete child nodes (this now calls the SAFE removeNode above)\n    if (c.nodeIds) {\n      [...c.nodeIds].forEach(nid => this.removeNode(nid));\n    }\n\n    // Delete child containers recursively\n    if (c.childContainerIds) {\n      [...c.childContainerIds].forEach(cid => this.removeContainerRecursive(cid));\n    }\n\n    // Delete container itself\n    delete this.containersById[id];\n  }\n\n  // --- PORT MANAGEMENT ---\n\n  addPortToEntity(entityId, port) {\n    const node = this.nodesById[entityId];\n    if (node) {\n      if (!node.ports) node.ports = [];\n      node.ports.push(port);\n      return;\n    }\n    const container = this.containersById[entityId];\n    if (container) {\n      if (!container.ports) container.ports = [];\n      container.ports.push(port);\n      return;\n    }\n    console.warn(`Could not find entity with ID ${entityId} to add port.`);\n  }\n  removePortAndEdges(entityId, portId) {\n    const entity = this.nodesById[entityId] || this.containersById[entityId];\n    if (!entity || !entity.ports) return;\n\n    // Remove the Port from the Entity\n    entity.ports = entity.ports.filter(p => p.id !== portId);\n\n    // Remove all Edges connected to this Port\n    const edgeIdsToRemove = [];\n    Object.values(this.edgesById).forEach(edge => {\n      if (edge.sourceNodeId === entityId && edge.sourcePortId === portId || edge.targetNodeId === entityId && edge.targetPortId === portId) {\n        edgeIdsToRemove.push(edge.id);\n      }\n    });\n    edgeIdsToRemove.forEach(id => delete this.edgesById[id]);\n  }\n  toggleContainerCollapsed(id) {\n    const c = this.getContainer(id);\n    if (c) c.collapsed = !c.collapsed;\n  }\n  clone() {\n    const copy = new GraphModel();\n    // Deep copy is safer for objects, but spread is okay if you don't mutate nested arrays directly without cloning them first\n    // ideally you might want structuredClone, but this works for basic levels\n    copy.nodesById = JSON.parse(JSON.stringify(this.nodesById));\n    copy.containersById = JSON.parse(JSON.stringify(this.containersById));\n    copy.edgesById = JSON.parse(JSON.stringify(this.edgesById));\n    return copy;\n  }\n  exportJSON() {\n    return JSON.stringify({\n      nodes: this.nodesById,\n      containers: this.containersById,\n      edges: this.edgesById\n    }, null, 2); // Pretty print\n  }\n}","map":{"version":3,"names":["GraphModel","constructor","nodesById","containersById","edgesById","addNode","node","id","addContainer","container","addEdge","edge","getNode","getContainer","moveNode","pos","n","position","moveContainer","c","removeNode","Object","values","forEach","sourceNodeId","targetNodeId","parentId","parent","nodeIds","filter","nid","removeEdge","removeContainer","childContainerIds","cid","removeContainerRecursive","addPortToEntity","entityId","port","ports","push","console","warn","removePortAndEdges","portId","entity","p","edgeIdsToRemove","sourcePortId","targetPortId","toggleContainerCollapsed","collapsed","clone","copy","JSON","parse","stringify","exportJSON","nodes","containers","edges"],"sources":["/home/belac/sysFlow/src/models/GraphModel.ts"],"sourcesContent":["import { Node } from \"./Node\";\nimport { Container } from \"./Container\";\nimport { Edge } from \"./Edge\";\nimport { Port, ID, Vec2 } from \"./Entity\";\n\nexport class GraphModel {\n  nodesById: Record<ID, Node> = {};\n  containersById: Record<ID, Container> = {};\n  edgesById: Record<ID, Edge> = {};\n\n  addNode(node: Node) { this.nodesById[node.id] = node; }\n  addContainer(container: Container) { this.containersById[container.id] = container; }\n  addEdge(edge: Edge) { this.edgesById[edge.id] = edge; }\n\n  getNode(id: ID) { return this.nodesById[id]; }\n  getContainer(id: ID) { return this.containersById[id]; }\n\n  moveNode(id: ID, pos: Vec2) { const n = this.getNode(id); if (n) n.position = pos; }\n  moveContainer(id: ID, pos: Vec2) { const c = this.getContainer(id); if (c) c.position = pos; }\n\n  // --- SAFE REMOVAL METHODS ---\n\n  // UPDATED: Safely remove a node, its edges, and its reference from parents\n  removeNode(id: ID) {\n    const node = this.nodesById[id];\n    if (!node) return;\n\n    // 1. Remove all edges connected to this node\n    Object.values(this.edgesById).forEach(edge => {\n      if (edge.sourceNodeId === id || edge.targetNodeId === id) {\n        delete this.edgesById[edge.id];\n      }\n    });\n\n    // 2. Remove node from its parent container (if it has one)\n    if (node.parentId) {\n      const parent = this.containersById[node.parentId];\n      if (parent) {\n        parent.nodeIds = parent.nodeIds.filter(nid => nid !== id);\n      }\n    }\n\n    // 3. Finally, delete the node\n    delete this.nodesById[id];\n  }\n\n  removeEdge(id: ID) { delete this.edgesById[id]; }\n\n  // ADDED: The missing method required by GraphCanvas\n  removeContainer(id: ID) {\n    const container = this.containersById[id];\n    if (!container) return;\n\n    // 1. Remove this container from its parent's list (if nested)\n    if (container.parentId) {\n      const parent = this.containersById[container.parentId];\n      if (parent && parent.childContainerIds) {\n        parent.childContainerIds = parent.childContainerIds.filter(cid => cid !== id);\n      }\n    }\n\n    // 2. Recursively delete everything inside it\n    this.removeContainerRecursive(id);\n  }\n\n  // Existing recursive helper (called by removeContainer)\n  removeContainerRecursive(id: ID) {\n    const c = this.containersById[id];\n    if (!c) return;\n    \n    // Delete child nodes (this now calls the SAFE removeNode above)\n    if (c.nodeIds) {\n        [...c.nodeIds].forEach(nid => this.removeNode(nid));\n    }\n    \n    // Delete child containers recursively\n    if (c.childContainerIds) {\n        [...c.childContainerIds].forEach(cid => this.removeContainerRecursive(cid));\n    }\n    \n    // Delete container itself\n    delete this.containersById[id];\n  }\n\n  // --- PORT MANAGEMENT ---\n\n  addPortToEntity(entityId: string, port: Port): void {\n    const node = this.nodesById[entityId];\n    if (node) {\n      if (!node.ports) node.ports = [];\n      node.ports.push(port);\n      return;\n    }\n\n    const container = this.containersById[entityId];\n    if (container) {\n      if (!container.ports) container.ports = [];\n      container.ports.push(port);\n      return;\n    }\n    console.warn(`Could not find entity with ID ${entityId} to add port.`);\n  }\n\n  removePortAndEdges(entityId: string, portId: string): void {\n    const entity = this.nodesById[entityId] || this.containersById[entityId];\n    if (!entity || !entity.ports) return;\n\n    // Remove the Port from the Entity\n    entity.ports = entity.ports.filter(p => p.id !== portId);\n\n    // Remove all Edges connected to this Port\n    const edgeIdsToRemove: string[] = [];\n    Object.values(this.edgesById).forEach(edge => {\n      if (\n        (edge.sourceNodeId === entityId && edge.sourcePortId === portId) ||\n        (edge.targetNodeId === entityId && edge.targetPortId === portId)\n      ) {\n        edgeIdsToRemove.push(edge.id);\n      }\n    });\n\n    edgeIdsToRemove.forEach(id => delete this.edgesById[id]);\n  }\n\n  toggleContainerCollapsed(id: ID) {\n    const c = this.getContainer(id);\n    if (c) c.collapsed = !c.collapsed;\n  }\n\n  clone(): GraphModel {\n    const copy = new GraphModel();\n    // Deep copy is safer for objects, but spread is okay if you don't mutate nested arrays directly without cloning them first\n    // ideally you might want structuredClone, but this works for basic levels\n    copy.nodesById = JSON.parse(JSON.stringify(this.nodesById));\n    copy.containersById = JSON.parse(JSON.stringify(this.containersById));\n    copy.edgesById = JSON.parse(JSON.stringify(this.edgesById));\n    return copy;\n  }\n\n  exportJSON() {\n    return JSON.stringify({\n      nodes: this.nodesById,\n      containers: this.containersById,\n      edges: this.edgesById\n    }, null, 2); // Pretty print\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}