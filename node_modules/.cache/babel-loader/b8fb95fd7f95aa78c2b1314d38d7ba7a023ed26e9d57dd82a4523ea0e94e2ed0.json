{"ast":null,"code":"// Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\nconst selectAll = () => {\n  const allNodeIds = new Set(Object.keys(graph.nodesById));\n  const allContainerIds = new Set(Object.keys(graph.containersById));\n  setSelectedNodes(allNodeIds);\n  setSelectedContainerIds(allContainerIds);\n};\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph, id) => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container === null || container === void 0 ? void 0 : container.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph, pos) => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 && pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width && pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nexport const isContainerEntity = e => {\n  return e.size !== undefined;\n};\nexport const recomputeContainerSize = (graph, id) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n    const n = graph.getNode(nId);\n    if (!n) return;\n    hasChildren = true;\n    minX = Math.min(minX, n.position.x);\n    minY = Math.min(minY, n.position.y);\n    maxX = Math.max(maxX, n.position.x + 100);\n    maxY = Math.max(maxY, n.position.y + 50);\n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n    const ch = graph.containersById[childId];\n    if (!ch) return;\n    hasChildren = true;\n    minX = Math.min(minX, ch.position.x);\n    minY = Math.min(minY, ch.position.y);\n    maxX = Math.max(maxX, ch.position.x + ch.size.width);\n    maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n  if (!hasChildren) return;\n  const requiredWidth = maxX - minX + CONTAINER_PADDING * 2;\n  const requiredHeight = maxY - minY + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\nexport const assignEntityToContainer = (graph, entityId, skipContainerId) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n  for (const c of containers) {\n    if (c.id === entityId || skipContainerId && c.id === skipContainerId) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside = entity.position.x >= c.position.x && entity.position.y >= c.position.y && entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width && entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n          const oldParent = graph.containersById[entity.parentId];\n          if (oldParent) {\n            var _oldParent$childConta;\n            if (isContainer) oldParent.childContainerIds = (_oldParent$childConta = oldParent.childContainerIds) === null || _oldParent$childConta === void 0 ? void 0 : _oldParent$childConta.filter(id => id !== entityId);else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n          }\n        }\n\n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n    const prev = graph.containersById[entity.parentId];\n    if (prev) {\n      var _prev$childContainerI;\n      if (isContainer) prev.childContainerIds = (_prev$childContainerI = prev.childContainerIds) === null || _prev$childContainerI === void 0 ? void 0 : _prev$childContainerI.filter(id => id !== entityId);else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n    }\n    entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph, container) => {\n  const containerPorts = container.ports || [];\n  if (!container.collapsed) return containerPorts;\n  const proxyPorts = [];\n  const childNodeIds = new Set(container.nodeIds || []);\n  Object.values(graph.edgesById).forEach(edge => {\n    const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n    const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n    // Edge goes OUT\n    if (isSourceInside && !isTargetInside) {\n      var _sourceNode$ports;\n      const sourceNode = graph.nodesById[edge.sourceNodeId];\n      const internalPort = sourceNode === null || sourceNode === void 0 ? void 0 : (_sourceNode$ports = sourceNode.ports) === null || _sourceNode$ports === void 0 ? void 0 : _sourceNode$ports.find(p => p.id === edge.sourcePortId);\n      proxyPorts.push({\n        id: edge.sourcePortId || `proxy-src-${edge.id}`,\n        label: internalPort ? `${sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.label}.${internalPort.label}` : \"out\"\n      });\n    }\n    // Edge comes IN\n    else if (!isSourceInside && isTargetInside) {\n      var _targetNode$ports;\n      const targetNode = graph.nodesById[edge.targetNodeId];\n      const internalPort = targetNode === null || targetNode === void 0 ? void 0 : (_targetNode$ports = targetNode.ports) === null || _targetNode$ports === void 0 ? void 0 : _targetNode$ports.find(p => p.id === edge.targetPortId);\n      proxyPorts.push({\n        id: edge.targetPortId || `proxy-tgt-${edge.id}`,\n        label: internalPort ? `${targetNode === null || targetNode === void 0 ? void 0 : targetNode.label}.${internalPort.label}` : \"in\"\n      });\n    }\n  });\n  return [...containerPorts, ...proxyPorts];\n};\nexport const collectDragStartPositions = (rootIds, map, graph) => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...n.position\n        });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...c.position\n        });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n        c.nodeIds.forEach(nid => {\n          const child = graph.nodesById[nid];\n          if (child && !map.has(nid)) map.set(nid, {\n            ...child.position\n          });\n        });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};","map":{"version":3,"names":["CONTAINER_HEADER_HEIGHT","CONTAINER_PADDING","MIN_CONTAINER_WIDTH","MIN_CONTAINER_HEIGHT","selectAll","allNodeIds","Set","Object","keys","graph","nodesById","allContainerIds","containersById","setSelectedNodes","setSelectedContainerIds","isEntityVisible","id","node","container","currentParentId","parentId","parent","collapsed","hitTestEntity","pos","nodes","values","containers","n","x","position","y","c","reverse","size","width","height","isContainerEntity","e","undefined","recomputeContainerSize","minX","Infinity","minY","maxX","maxY","hasChildren","nodeIds","forEach","nId","getNode","Math","min","max","childContainerIds","childId","ch","requiredWidth","requiredHeight","assignEntityToContainer","entityId","skipContainerId","entity","isContainer","inside","oldParent","_oldParent$childConta","filter","includes","push","prev","_prev$childContainerI","getRenderablePorts","containerPorts","ports","proxyPorts","childNodeIds","edgesById","edge","isSourceInside","has","sourceNodeId","isTargetInside","targetNodeId","_sourceNode$ports","sourceNode","internalPort","find","p","sourcePortId","label","_targetNode$ports","targetNode","targetPortId","collectDragStartPositions","rootIds","map","set","nid","child"],"sources":["/home/belac/sysFlow/src/utils/GraphLogic.ts"],"sourcesContent":["import { GraphModel } from \"../models/GraphModel\";\nimport { Container } from \"../models/Container\";\nimport { Node } from \"../models/Node\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { getPortPosition } from \"./Geometry\"; // Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\nconst selectAll = () => {\n    const allNodeIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerIds(allContainerIds);\n};\n\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph: GraphModel, id: ID): boolean => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container?.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph: GraphModel, pos: Vec2): ID | null => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 &&\n        pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width &&\n        pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nexport const isContainerEntity = (e: Entity): e is Container => {\n  return (e as Container).size !== undefined;\n};\n\nexport const recomputeContainerSize = (graph: GraphModel, id: ID) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n      const n = graph.getNode(nId);\n      if (!n) return;\n      hasChildren = true;\n      minX = Math.min(minX, n.position.x);\n      minY = Math.min(minY, n.position.y);\n      maxX = Math.max(maxX, n.position.x + 100);\n      maxY = Math.max(maxY, n.position.y + 50); \n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n      const ch = graph.containersById[childId];\n      if (!ch) return;\n      hasChildren = true;\n      minX = Math.min(minX, ch.position.x);\n      minY = Math.min(minY, ch.position.y);\n      maxX = Math.max(maxX, ch.position.x + ch.size.width);\n      maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n\n  if (!hasChildren) return; \n\n  const requiredWidth = (maxX - minX) + CONTAINER_PADDING * 2;\n  const requiredHeight = (maxY - minY) + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\n\nexport const assignEntityToContainer = (graph: GraphModel, entityId: ID, skipContainerId?: ID) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n\n  for (const c of containers) {\n    if (c.id === entityId || (skipContainerId && c.id === skipContainerId)) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside =\n      entity.position.x >= c.position.x &&\n      entity.position.y >= c.position.y &&\n      entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width &&\n      entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n             const oldParent = graph.containersById[entity.parentId];\n             if (oldParent) {\n                 if(isContainer) oldParent.childContainerIds = oldParent.childContainerIds?.filter(id => id !== entityId);\n                 else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n             }\n        }\n        \n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n      const prev = graph.containersById[entity.parentId];\n      if (prev) {\n        if (isContainer) prev.childContainerIds = prev.childContainerIds?.filter(id => id !== entityId);\n        else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n      }\n      entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph: GraphModel, container: Container): Port[] => {\n    const containerPorts = container.ports || [];\n    if (!container.collapsed) return containerPorts;\n\n    const proxyPorts: Port[] = [];\n    const childNodeIds = new Set(container.nodeIds || []); \n\n    Object.values(graph.edgesById).forEach(edge => {\n      const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n      const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n      // Edge goes OUT\n      if (isSourceInside && !isTargetInside) {\n        const sourceNode = graph.nodesById[edge.sourceNodeId];\n        const internalPort = sourceNode?.ports?.find(p => p.id === edge.sourcePortId);\n        proxyPorts.push({\n          id: edge.sourcePortId || `proxy-src-${edge.id}`, \n          label: internalPort ? `${sourceNode?.label}.${internalPort.label}` : \"out\"\n        });\n      } \n      // Edge comes IN\n      else if (!isSourceInside && isTargetInside) {\n        const targetNode = graph.nodesById[edge.targetNodeId];\n        const internalPort = targetNode?.ports?.find(p => p.id === edge.targetPortId);\n        proxyPorts.push({\n          id: edge.targetPortId || `proxy-tgt-${edge.id}`, \n          label: internalPort ? `${targetNode?.label}.${internalPort.label}` : \"in\"\n        });\n      }\n    });\n\n    return [...containerPorts, ...proxyPorts];\n};\n\nexport const collectDragStartPositions = (\n  rootIds: ID[],\n  map: Map<ID, Vec2>,\n  graph: GraphModel\n): Map<ID, Vec2> => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, { ...n.position });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, { ...c.position });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n          c.nodeIds.forEach(nid => {\n              const child = graph.nodesById[nid];\n              if(child && !map.has(nid)) map.set(nid, {...child.position});\n          });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}