{"ast":null,"code":"var _jsxFileName = \"/home/belac/sysFlow/src/components/GraphCanvas.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef } from \"react\";\nimport { GraphNode } from \"./GraphNode\";\nimport { GraphContainer } from \"./GraphContainer\";\nimport { Lasso } from \"./Lasso\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport { EntityEditor } from \"./EntityEditor\";\nimport { getPortPosition } from \"../utils/Geometry\";\n\n// --- IMPORT THE LOGIC ---\nimport * as GraphLogic from \"../utils/GraphLogic\";\n\n// Config\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst ENABLE_EXPLICIT_PORTS = true;\nexport const GraphCanvas = ({\n  graph,\n  onGraphChange,\n  renderNode,\n  renderContainer\n}) => {\n  _s();\n  const containerRef = useRef(null);\n\n  // State\n  const [selectedNodes, setSelectedNodes] = useState(new Set());\n  const [selectedContainerIds, setSelectedContainerIds] = useState(new Set());\n  const [mode, setMode] = useState(\"idle\");\n  const [dragStartMouse, setDragStartMouse] = useState(null);\n  const [dragStartPositions, setDragStartPositions] = useState(new Map());\n  const [lassoStart, setLassoStart] = useState(null);\n  const [lassoEnd, setLassoEnd] = useState(null);\n  const [creatingEdge, setCreatingEdge] = useState(null);\n  const [canvasMenu, setCanvasMenu] = useState(null);\n  const [resizingState, setResizingState] = useState(null);\n\n  // Port State\n  const [hoveredPort, setHoveredPort] = useState(null);\n  const [dragStartPortId, setDragStartPortId] = useState(null);\n  const [pendingSourcePortLabel, setPendingSourcePortLabel] = useState(null);\n\n  // Editor State\n  const [editingEntityId, setEditingEntityId] = useState(null);\n  const [editorPosition, setEditorPosition] = useState(null);\n  const [clipboard, setClipboard] = useState(null);\n  const selectAll = () => {\n    // Create a Set of ALL node IDs\n    const allNodeIds = new Set(Object.keys(graph.nodesById));\n\n    // Create a Set of ALL container IDs\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n\n    // Update State\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerIds(allContainerIds);\n  };\n  const copy = () => {\n    e.preventDefault();\n\n    // 1. Gather data\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n\n    // 2. Gather edges (only if both source/target are being copied)\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge => allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId));\n\n    // 3. Save to internal clipboard state\n    const clipboardData = {\n      nodes: nodesToCopy,\n      containers: containersToCopy,\n      edges: edgesToCopy\n    };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n\n  // --- Keyboard Handling (Delete) ---\n  React.useEffect(() => {\n    const handleKeyDown = e => {\n      // Ignore if user is typing in a text input\n      if (e.target.tagName === \"INPUT\") return;\n      if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n        const newGraph = graph.clone();\n        selectedNodes.forEach(id => newGraph.removeNode(id));\n        selectedContainerIds.forEach(id => newGraph.removeContainer(id));\n        onGraphChange(newGraph);\n        setSelectedNodes(new Set());\n        setSelectedContainerIds(new Set());\n      }\n      if (e.key === \"Escape\") {\n        clearAllStates();\n      }\n      if (e.ctrlKey || e.metaKey) {\n        // Select All\n        if (e.key === \"a\") {\n          selectAll();\n        }\n\n        //        // Undo\n        //        if (e.key === \"z\"){\n        //        }\n        //\n        //        // Redo\n        //        if (e.key === \"y\"){\n        //        }\n\n        // --- COPY (Ctrl + C) ---\n        if (e.key === \"c\") {\n          copy();\n        }\n\n        // --- PASTE (Ctrl + V) ---\n        if (e.key === \"v\") {\n          e.preventDefault();\n          if (!clipboard) return;\n          try {\n            const data = JSON.parse(clipboard);\n            const newGraph = graph.clone();\n\n            // Mappings to track Old ID -> New ID\n            const idMap = new Map();\n            const newSelectedNodes = new Set();\n            const newSelectedContainers = new Set();\n\n            // 1. Paste Containers\n            data.containers.forEach(c => {\n              const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n              idMap.set(c.id, newId);\n              newGraph.containersById[newId] = {\n                ...c,\n                id: newId,\n                position: {\n                  x: c.position.x + 20,\n                  y: c.position.y + 20\n                },\n                // Offset slightly\n                nodeIds: [],\n                // Will rebuild these\n                childContainerIds: []\n              };\n              newSelectedContainers.add(newId);\n            });\n\n            // 2. Paste Nodes\n            data.nodes.forEach(n => {\n              const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n              idMap.set(n.id, newId);\n              newGraph.nodesById[newId] = {\n                ...n,\n                id: newId,\n                position: {\n                  x: n.position.x + 20,\n                  y: n.position.y + 20\n                },\n                parentId: n.parentId ? idMap.get(n.parentId) : undefined // Remap parent if it was also copied\n              };\n              newSelectedNodes.add(newId);\n\n              // If this node belongs to a container we just pasted, register it there\n              if (n.parentId && idMap.has(n.parentId)) {\n                var _newGraph$containersB;\n                const newParentId = idMap.get(n.parentId);\n                (_newGraph$containersB = newGraph.containersById[newParentId]) === null || _newGraph$containersB === void 0 ? void 0 : _newGraph$containersB.nodeIds.push(newId);\n              }\n            });\n\n            // 3. Paste Edges (Only if start/end exist in the paste)\n            data.edges.forEach(e => {\n              const newSource = idMap.get(e.sourceNodeId);\n              const newTarget = idMap.get(e.targetNodeId);\n              if (newSource && newTarget) {\n                const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n                newGraph.edgesById[newEdgeId] = {\n                  ...e,\n                  id: newEdgeId,\n                  sourceNodeId: newSource,\n                  targetNodeId: newTarget\n                };\n              }\n            });\n\n            // 4. Update State\n            onGraphChange(newGraph);\n            // Select the newly pasted items so user can immediately drag them\n            setSelectedNodes(newSelectedNodes);\n            setSelectedContainerIds(newSelectedContainers);\n          } catch (err) {\n            console.error(\"Paste failed\", err);\n          }\n        }\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, onGraphChange]);\n  const getMousePos = e => {\n    const rect = containerRef.current.getBoundingClientRect();\n    return {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n  };\n  const clearAllStates = () => {\n    setSelectedNodes(new Set());\n    setSelectedContainerIds(new Set());\n    setCanvasMenu(null);\n  };\n  const toggleContainer = cid => {\n    const newGraph = graph.clone();\n    newGraph.toggleContainerCollapsed(cid);\n    onGraphChange(newGraph);\n  };\n\n  // --- Rendering Helpers ---\n\n  const renderPorts = entity => {\n    // USE LOGIC: Calculate which ports to show (proxies or real)\n    const portsToRender = \"nodeIds\" in entity ? GraphLogic.getRenderablePorts(graph, entity) : entity.ports || [];\n    return portsToRender.map(port => {\n      // Geometry Calculation\n      // 1. Get Absolute Position from Geometry helper\n      const absPos = getPortPosition(entity, port.id, graph, \"nodeIds\" in entity ? entity.size : {\n        width: 100,\n        height: 50\n      });\n\n      // 2. FIX: Convert to Relative Position if inside a Container\n      let pos = {\n        x: absPos.x,\n        y: absPos.y\n      };\n      if (\"nodeIds\" in entity) {\n        // It is a container\n        pos.x = absPos.x - entity.position.x;\n        pos.y = absPos.y - entity.position.y;\n      }\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        title: port.label,\n        style: {\n          position: \"absolute\",\n          left: pos.x - 6,\n          top: pos.y - 6,\n          width: 12,\n          height: 12,\n          borderRadius: \"50%\",\n          backgroundColor: \"#fff\",\n          border: \"2px solid #333\",\n          zIndex: 100,\n          cursor: \"pointer\"\n        },\n        onMouseEnter: () => setHoveredPort({\n          nodeId: entity.id,\n          portId: port.id\n        }),\n        onMouseLeave: () => setHoveredPort(null),\n        onMouseDown: e => {\n          e.stopPropagation();\n          setCreatingEdge({\n            sourceNodeId: entity.id,\n            position: pos\n          });\n          setDragStartPortId(port.id);\n          setPendingSourcePortLabel(port.label);\n          setMode(\"edge-create\");\n          setDragStartMouse(getMousePos(e));\n        }\n      }, port.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 255,\n        columnNumber: 9\n      }, this);\n    });\n  };\n\n  // --- Event Handlers ---\n\n  const handleMouseDown = e => {\n    const pos = getMousePos(e);\n\n    // 1. Port Interaction\n    if (ENABLE_EXPLICIT_PORTS && hoveredPort) {\n      // Logic handled in renderPorts onMouseDown\n      return;\n    }\n\n    // 2. Right Click\n    if (e.button === 2 && e.target === e.currentTarget) {\n      const hitId = GraphLogic.hitTestEntity(graph, pos);\n      if (!hitId) {\n        e.preventDefault();\n        setCanvasMenu({\n          position: {\n            x: pos.x,\n            y: pos.y\n          },\n          targetId: undefined,\n          type: undefined\n        });\n        return;\n      }\n      return;\n    }\n\n    // 3. Canvas Click (Clear)\n    if (e.target === e.currentTarget) {\n      clearAllStates();\n      setMode(\"lasso\");\n      setLassoStart(pos);\n      setLassoEnd(pos);\n      setEditingEntityId(null);\n    }\n  };\n  const handleMouseMove = e => {\n    const mousePos = getMousePos(e);\n\n    // 1. Handle Dragging Entities\n    if (mode === \"drag\" && dragStartMouse) {\n      const dx = mousePos.x - dragStartMouse.x;\n      const dy = mousePos.y - dragStartMouse.y;\n      const newGraph = graph.clone();\n      let changed = false;\n      dragStartPositions.forEach((startPos, id) => {\n        // Update Node Positions\n        const node = newGraph.nodesById[id];\n        if (node) {\n          node.position = {\n            x: startPos.x + dx,\n            y: startPos.y + dy\n          };\n          changed = true;\n        }\n        // Update Container Positions\n        const container = newGraph.containersById[id];\n        if (container) {\n          container.position = {\n            x: startPos.x + dx,\n            y: startPos.y + dy\n          };\n          changed = true;\n        }\n      });\n      if (changed) onGraphChange(newGraph);\n    }\n\n    // 2. Handle Edge Creation (Update the \"rubber band\" line)\n    if (mode === \"edge-create\" && creatingEdge) {\n      setCreatingEdge({\n        ...creatingEdge,\n        position: mousePos\n      });\n    }\n\n    // 3. Handle Lasso\n    if (mode === \"lasso\") {\n      setLassoEnd(mousePos);\n    }\n    if (mode === \"resize\" && resizingState) {\n      const dx = mousePos.x - resizingState.startMouse.x;\n      const dy = mousePos.y - resizingState.startMouse.y;\n\n      // Update locally to avoid massive re-renders, or update graph directly\n      const newGraph = graph.clone();\n      const container = newGraph.containersById[resizingState.id];\n      if (container) {\n        container.size = {\n          width: Math.max(100, resizingState.startSize.width + dx),\n          height: Math.max(50, resizingState.startSize.height + dy)\n        };\n        onGraphChange(newGraph);\n      }\n    }\n  };\n  const handleMouseUp = e => {\n    const pos = getMousePos(e);\n    if (mode === \"edge-create\" && creatingEdge) {\n      // USE LOGIC: Hit test via the helper\n      let targetNodeId = hoveredPort ? hoveredPort.nodeId : GraphLogic.hitTestEntity(graph, pos);\n      let targetPortId = hoveredPort ? hoveredPort.portId : null;\n      if (targetNodeId && targetNodeId !== creatingEdge.sourceNodeId) {\n        // ... Perform your edge creation logic here ...\n        // (This is where you'd use graph.addEdge)\n        // Check if explicit ports are enabled, create ports if missing, etc.\n        const newGraph = graph.clone();\n\n        // Example simple edge add for brevity (Replace with your robust logic):\n        const edgeId = `e_${crypto.randomUUID()}`;\n        newGraph.addEdge({\n          id: edgeId,\n          sourceNodeId: creatingEdge.sourceNodeId,\n          // <--- Fixed\n          sourcePortId: creatingEdge.sourcePortId,\n          targetNodeId: targetNodeId,\n          // <--- Fixed\n          targetPortId: targetPortId || undefined\n        });\n        onGraphChange(newGraph);\n      }\n      setCreatingEdge(null);\n      setMode(\"idle\");\n    }\n    if (mode === \"drag\") {\n      // USE LOGIC: When dropping, check containment\n      const newGraph = graph.clone();\n\n      // Check every node/container that was dragged\n      // We only check the \"roots\" of the drag to avoid double processing\n      dragStartPositions.forEach((_, id) => {\n        var _newGraph$nodesById$i, _newGraph$containersB2;\n        GraphLogic.assignEntityToContainer(newGraph, id);\n        // Also recompute sizes of parents that might have grown\n        const parent = ((_newGraph$nodesById$i = newGraph.nodesById[id]) === null || _newGraph$nodesById$i === void 0 ? void 0 : _newGraph$nodesById$i.parentId) || ((_newGraph$containersB2 = newGraph.containersById[id]) === null || _newGraph$containersB2 === void 0 ? void 0 : _newGraph$containersB2.parentId);\n        if (parent) GraphLogic.recomputeContainerSize(newGraph, parent);\n      });\n      onGraphChange(newGraph);\n      setMode(\"idle\");\n      setDragStartMouse(null);\n      setDragStartPositions(new Map());\n    }\n    if (mode === \"lasso\" && lassoStart && lassoEnd) {\n      // Calculate selection box\n      const x1 = Math.min(lassoStart.x, lassoEnd.x);\n      const x2 = Math.max(lassoStart.x, lassoEnd.x);\n      const y1 = Math.min(lassoStart.y, lassoEnd.y);\n      const y2 = Math.max(lassoStart.y, lassoEnd.y);\n\n      // Don't select if the box is tiny (accidental click)\n      if (Math.abs(x2 - x1) > 5 && Math.abs(y2 - y1) > 5) {\n        const newSelectedNodes = new Set();\n        const newSelectedContainers = new Set();\n\n        // Find nodes inside\n        Object.values(graph.nodesById).forEach(node => {\n          if (GraphLogic.isEntityVisible(graph, node.id) && node.position.x >= x1 && node.position.x + 100 <= x2 &&\n          // Assuming width 100\n          node.position.y >= y1 && node.position.y + 50 <= y2) {\n            // Assuming height 50\n            newSelectedNodes.add(node.id);\n          }\n        });\n\n        // Find containers inside\n        Object.values(graph.containersById).forEach(container => {\n          if (GraphLogic.isEntityVisible(graph, container.id) && container.position.x >= x1 && container.position.x + container.size.width <= x2 && container.position.y >= y1 && container.position.y + container.size.height <= y2) {\n            newSelectedContainers.add(container.id);\n          }\n        });\n        setSelectedNodes(newSelectedNodes);\n        setSelectedContainerIds(newSelectedContainers);\n      }\n      setLassoStart(null);\n      setLassoEnd(null);\n    }\n    setMode(\"idle\");\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"graph-canvas\",\n    style: {\n      position: \"relative\",\n      width: \"100%\",\n      height: \"100%\",\n      overflow: \"hidden\",\n      userSelect: \"none\"\n    },\n    onMouseDown: handleMouseDown,\n    onMouseMove: handleMouseMove,\n    onMouseUp: handleMouseUp,\n    onContextMenu: e => e.preventDefault(),\n    children: [Object.values(graph.containersById).map(c => {\n      if (!GraphLogic.isEntityVisible(graph, c.id)) return null;\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: /*#__PURE__*/_jsxDEV(GraphContainer, {\n          container: c,\n          selected: selectedContainerIds.has(c.id),\n          onMouseDown: e => {\n            e.stopPropagation();\n            // Select logic\n            if (!e.shiftKey) {\n              setSelectedNodes(new Set());\n              setSelectedContainerIds(new Set([c.id]));\n            } else {\n              const newSet = new Set(selectedContainerIds);\n              newSet.has(c.id) ? newSet.delete(c.id) : newSet.add(c.id);\n              setSelectedContainerIds(newSet);\n            }\n            // Start dragging\n            setMode(\"drag\");\n            setDragStartMouse(getMousePos(e));\n            setDragStartPositions(GraphLogic.collectDragStartPositions([c.id], new Map(), graph));\n          },\n          onDoubleClick: e => {\n            toggleContainer(c.id);\n          },\n          onContextMenu: e => {},\n          onResizeMouseDown: e => {\n            setResizingState({\n              id: c.id,\n              startMouse: getMousePos(e),\n              startSize: {\n                ...c.size\n              }\n            });\n            setMode(\"resize\");\n          },\n          children: renderPorts(c)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 476,\n          columnNumber: 13\n        }, this)\n      }, c.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 475,\n        columnNumber: 9\n      }, this);\n    }), Object.values(graph.nodesById).map(n => {\n      if (!GraphLogic.isEntityVisible(graph, n.id)) return null;\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(GraphNode, {\n          node: n,\n          selected: selectedNodes.has(n.id),\n          onMouseDown: e => {\n            e.stopPropagation();\n            // Select logic\n            if (!e.shiftKey) {\n              setSelectedContainerIds(new Set());\n              setSelectedNodes(new Set([n.id]));\n            } else {\n              const newSet = new Set(selectedNodes);\n              newSet.has(n.id) ? newSet.delete(n.id) : newSet.add(n.id);\n              setSelectedNodes(newSet);\n            }\n\n            // Right click check for menu\n            if (e.button === 2) {\n              //        setCanvasMenu({ targetId: n.id, type: \"node\", position: { x: e.clientX, y: e.clientY } });\n              e.preventDefault();\n              e.stopPropagation(); // Stop canvas from panning\n\n              // Start Edge Creation Mode manually here\n              const mousePos = getMousePos(e);\n              setMode(\"edge-create\");\n              setCreatingEdge({\n                sourceNodeId: n.id,\n                position: mousePos\n              });\n              return;\n            }\n\n            // Start dragging\n            setMode(\"drag\");\n            setDragStartMouse(getMousePos(e));\n            setDragStartPositions(GraphLogic.collectDragStartPositions([n.id], new Map(), graph));\n          },\n          onDoubleClick: e => {\n            e.stopPropagation();\n            setEditingEntityId(n.id);\n            const pos = getMousePos(e);\n            setEditorPosition({\n              x: pos.x,\n              y: pos.y\n            });\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 518,\n          columnNumber: 21\n        }, this), renderPorts(n)]\n      }, n.id, true, {\n        fileName: _jsxFileName,\n        lineNumber: 517,\n        columnNumber: 21\n      }, this);\n    }), /*#__PURE__*/_jsxDEV(\"svg\", {\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        overflow: \"visible\",\n        zIndex: 1 // Below nodes (zIndex 10) but above background\n      },\n      children: (() => {\n        const getVisualPosition = entityId => {\n          // 1. If the entity is directly visible, return its position\n          if (GraphLogic.isEntityVisible(graph, entityId)) {\n            var _graph$nodesById$enti, _graph$containersById;\n            return ((_graph$nodesById$enti = graph.nodesById[entityId]) === null || _graph$nodesById$enti === void 0 ? void 0 : _graph$nodesById$enti.position) || ((_graph$containersById = graph.containersById[entityId]) === null || _graph$containersById === void 0 ? void 0 : _graph$containersById.position);\n          }\n          // 2. If hidden, look for its parent container\n          // (This is a simplified lookup; for deep nesting, you'd recurse)\n          const parent = Object.values(graph.containersById).find(c => {\n            var _c$childContainerIds;\n            return c.nodeIds.includes(entityId) || ((_c$childContainerIds = c.childContainerIds) === null || _c$childContainerIds === void 0 ? void 0 : _c$childContainerIds.includes(entityId));\n          });\n\n          // If parent exists and is visible, snap to parent\n          if (parent && GraphLogic.isEntityVisible(graph, parent.id)) {\n            return {\n              x: parent.position.x + parent.size.width / 2,\n              // Snap to center of container\n              y: parent.position.y + parent.size.height / 2\n            };\n          }\n          return null;\n        };\n        return /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [Object.values(graph.edgesById).map(edge => {\n            const start = getVisualPosition(edge.sourceNodeId);\n            const end = getVisualPosition(edge.targetNodeId);\n            if (!start || !end) return null; // Both ends hidden deep inside collapsed structures\n\n            return /*#__PURE__*/_jsxDEV(\"line\", {\n              x1: start.x + (graph.nodesById[edge.sourceNodeId] ? 50 : 0) // Offset center if it's a node\n              ,\n              y1: start.y + (graph.nodesById[edge.sourceNodeId] ? 25 : 0),\n              x2: end.x + (graph.nodesById[edge.targetNodeId] ? 50 : 0),\n              y2: end.y + (graph.nodesById[edge.targetNodeId] ? 25 : 0),\n              stroke: \"black\",\n              strokeWidth: \"2\"\n            }, edge.id, false, {\n              fileName: _jsxFileName,\n              lineNumber: 612,\n              columnNumber: 21\n            }, this);\n          }), mode === \"edge-create\" && creatingEdge && /*#__PURE__*/_jsxDEV(\"line\", {\n            x1: creatingEdge.position.x // Mouse Position\n            ,\n            y1: creatingEdge.position.y\n            // Calculate start from the source node center\n            ,\n            x2: (() => {\n              const n = graph.nodesById[creatingEdge.sourceNodeId];\n              return n ? n.position.x + 50 : 0;\n            })(),\n            y2: (() => {\n              const n = graph.nodesById[creatingEdge.sourceNodeId];\n              return n ? n.position.y + 25 : 0;\n            })(),\n            stroke: \"black\",\n            strokeWidth: \"2\",\n            strokeDasharray: \"5,5\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 626,\n            columnNumber: 20\n          }, this)]\n        }, void 0, true);\n      })()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 567,\n      columnNumber: 9\n    }, this), mode === \"lasso\" && lassoStart && lassoEnd && (Math.abs(lassoStart.x - lassoEnd.x) > 5 || Math.abs(lassoStart.y - lassoEnd.y) > 5) && /*#__PURE__*/_jsxDEV(Lasso, {\n      start: lassoStart,\n      end: lassoEnd\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 651,\n      columnNumber: 14\n    }, this), editingEntityId && editorPosition && /*#__PURE__*/_jsxDEV(EntityEditor, {\n      entityId: editingEntityId,\n      graph: graph,\n      position: editorPosition,\n      onClose: () => setEditingEntityId(null),\n      onGraphChange: onGraphChange\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 655,\n      columnNumber: 14\n    }, this), canvasMenu && /*#__PURE__*/_jsxDEV(ContextMenu, {\n      position: canvasMenu.position,\n      options: (() => {\n        // 1. Menu for CANVAS (Background) -> Create New Items\n        if (!canvasMenu.targetId) {\n          return [{\n            label: \"Add Node\",\n            onClick: () => {\n              const newGraph = graph.clone();\n              const id = `n_${crypto.randomUUID().slice(0, 4)}`;\n              newGraph.addNode({\n                id,\n                label: \"New Node\",\n                position: canvasMenu.position,\n                ports: [],\n                size: {\n                  width: 100,\n                  height: 50\n                }\n              });\n              onGraphChange(newGraph);\n              setCanvasMenu(null); // Close menu\n            }\n          }, {\n            label: \"Add Container\",\n            onClick: () => {\n              const newGraph = graph.clone();\n              const id = `c_${crypto.randomUUID().slice(0, 4)}`;\n              newGraph.addContainer({\n                id,\n                label: \"New Container\",\n                position: canvasMenu.position,\n                size: {\n                  width: 300,\n                  height: 200\n                },\n                // Default size\n                nodeIds: [],\n                childContainerIds: [],\n                collapsed: false\n              });\n              onGraphChange(newGraph);\n              setCanvasMenu(null);\n            }\n          }];\n        }\n\n        // 2. Menu for NODES\n        if (canvasMenu.type === \"node\") {\n          return [{\n            label: \"Rename\",\n            onClick: () => {\n              setEditingEntityId(canvasMenu.targetId || null);\n              setEditorPosition(canvasMenu.position);\n              setCanvasMenu(null);\n            }\n          }, {\n            label: \"Delete Node\",\n            onClick: () => {\n              if (canvasMenu.targetId) {\n                const newGraph = graph.clone();\n                newGraph.removeNode(canvasMenu.targetId);\n                onGraphChange(newGraph);\n              }\n              setCanvasMenu(null);\n            }\n          }];\n        }\n\n        // 3. Menu for CONTAINERS\n        if (canvasMenu.type === \"container\") {\n          return [{\n            label: \"Rename\",\n            onClick: () => {\n              setEditingEntityId(canvasMenu.targetId || null);\n              setEditorPosition(canvasMenu.position);\n              setCanvasMenu(null);\n            }\n          }, {\n            label: \"Toggle Collapse\",\n            onClick: () => {\n              if (canvasMenu.targetId) {\n                toggleContainer(canvasMenu.targetId);\n              }\n              setCanvasMenu(null);\n            }\n          }, {\n            label: \"Delete Container\",\n            onClick: () => {\n              if (canvasMenu.targetId) {\n                const newGraph = graph.clone();\n                newGraph.removeContainer(canvasMenu.targetId);\n                onGraphChange(newGraph);\n              }\n              setCanvasMenu(null);\n            }\n          }];\n        }\n        return []; // Fallback\n      })()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 666,\n      columnNumber: 7\n    }, this), canvasMenu && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        zIndex: 999\n      },\n      onMouseDown: () => setCanvasMenu(null),\n      onContextMenu: e => {\n        e.preventDefault();\n        setCanvasMenu(null);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 775,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 463,\n    columnNumber: 5\n  }, this);\n};\n_s(GraphCanvas, \"OnM7QYiF0kVNRhlGCIUmrJKNy4M=\");\n_c = GraphCanvas;\nvar _c;\n$RefreshReg$(_c, \"GraphCanvas\");","map":{"version":3,"names":["React","useState","useRef","GraphNode","GraphContainer","Lasso","ContextMenu","EntityEditor","getPortPosition","GraphLogic","jsxDEV","_jsxDEV","Fragment","_Fragment","ENABLE_EXPLICIT_PORTS","GraphCanvas","graph","onGraphChange","renderNode","renderContainer","_s","containerRef","selectedNodes","setSelectedNodes","Set","selectedContainerIds","setSelectedContainerIds","mode","setMode","dragStartMouse","setDragStartMouse","dragStartPositions","setDragStartPositions","Map","lassoStart","setLassoStart","lassoEnd","setLassoEnd","creatingEdge","setCreatingEdge","canvasMenu","setCanvasMenu","resizingState","setResizingState","hoveredPort","setHoveredPort","dragStartPortId","setDragStartPortId","pendingSourcePortLabel","setPendingSourcePortLabel","editingEntityId","setEditingEntityId","editorPosition","setEditorPosition","clipboard","setClipboard","selectAll","allNodeIds","Object","keys","nodesById","allContainerIds","containersById","copy","e","preventDefault","nodesToCopy","values","filter","n","has","id","containersToCopy","c","allSelectedIds","edgesToCopy","edgesById","edge","sourceNodeId","targetNodeId","clipboardData","nodes","containers","edges","JSON","stringify","useEffect","handleKeyDown","target","tagName","key","size","newGraph","clone","forEach","removeNode","removeContainer","clearAllStates","ctrlKey","metaKey","data","parse","idMap","newSelectedNodes","newSelectedContainers","newId","crypto","randomUUID","slice","set","position","x","y","nodeIds","childContainerIds","add","parentId","get","undefined","_newGraph$containersB","newParentId","push","newSource","newTarget","newEdgeId","err","console","error","window","addEventListener","removeEventListener","getMousePos","rect","current","getBoundingClientRect","clientX","left","clientY","top","toggleContainer","cid","toggleContainerCollapsed","renderPorts","entity","portsToRender","getRenderablePorts","ports","map","port","absPos","width","height","pos","title","label","style","borderRadius","backgroundColor","border","zIndex","cursor","onMouseEnter","nodeId","portId","onMouseLeave","onMouseDown","stopPropagation","fileName","_jsxFileName","lineNumber","columnNumber","handleMouseDown","button","currentTarget","hitId","hitTestEntity","targetId","type","handleMouseMove","mousePos","dx","dy","changed","startPos","node","container","startMouse","Math","max","startSize","handleMouseUp","targetPortId","edgeId","addEdge","sourcePortId","_","_newGraph$nodesById$i","_newGraph$containersB2","assignEntityToContainer","parent","recomputeContainerSize","x1","min","x2","y1","y2","abs","isEntityVisible","ref","className","overflow","userSelect","onMouseMove","onMouseUp","onContextMenu","children","selected","shiftKey","newSet","delete","collectDragStartPositions","onDoubleClick","onResizeMouseDown","pointerEvents","getVisualPosition","entityId","_graph$nodesById$enti","_graph$containersById","find","_c$childContainerIds","includes","start","end","stroke","strokeWidth","strokeDasharray","onClose","options","onClick","addNode","addContainer","collapsed","_c","$RefreshReg$"],"sources":["/home/belac/sysFlow/src/components/GraphCanvas.tsx"],"sourcesContent":["import React, { useState, useRef } from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\nimport { Node } from \"../models/Node\";\nimport { Container } from \"../models/Container\";\nimport { ID, Vec2, Port } from \"../models/Entity\";\nimport { GraphNode } from \"./GraphNode\";\nimport { GraphContainer } from \"./GraphContainer\";\nimport { GraphEdge } from \"./GraphEdge\";\nimport { Lasso } from \"./Lasso\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport { EntityEditor } from \"./EntityEditor\";\nimport { getPortPosition } from \"../utils/Geometry\";\n\n// --- IMPORT THE LOGIC ---\nimport * as GraphLogic from \"../utils/GraphLogic\";\n\n// Config\nconst ENABLE_EXPLICIT_PORTS = true;\n\ntype InteractionMode = \"idle\" | \"drag\" | \"lasso\" | \"edge-create\" | \"resize\";\n\ninterface GraphCanvasProps {\n  graph: GraphModel;\n  onGraphChange: (newGraph: GraphModel) => void;\n  renderNode?: (node: Node, selected: boolean) => React.ReactNode;\n  renderContainer?: (container: Container, collapsed: boolean) => React.ReactNode;\n}\n\nexport const GraphCanvas = ({ graph, onGraphChange, renderNode, renderContainer }: GraphCanvasProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // State\n  const [selectedNodes, setSelectedNodes] = useState<Set<ID>>(new Set());\n  const [selectedContainerIds, setSelectedContainerIds] = useState<Set<ID>>(new Set());\n  const [mode, setMode] = useState<InteractionMode>(\"idle\");\n  const [dragStartMouse, setDragStartMouse] = useState<Vec2 | null>(null);\n  const [dragStartPositions, setDragStartPositions] = useState<Map<ID, Vec2>>(new Map());\n  const [lassoStart, setLassoStart] = useState<Vec2 | null>(null);\n  const [lassoEnd, setLassoEnd] = useState<Vec2 | null>(null);\n  const [creatingEdge, setCreatingEdge] = useState<{sourceNodeId: ID; sourcePortId?: ID; position: Vec2} | null>(null);\n  const [canvasMenu, setCanvasMenu] = useState<{ targetId?: ID; type?: string; position: Vec2 } | null>(null);\n  const [resizingState, setResizingState] = useState<{ id: ID; startMouse: Vec2; startSize: { width: number; height: number };} | null>(null);\n  \n  // Port State\n  const [hoveredPort, setHoveredPort] = useState<{nodeId: ID, portId: ID } | null>(null);\n  const [dragStartPortId, setDragStartPortId] = useState<ID | null>(null);\n  const [pendingSourcePortLabel, setPendingSourcePortLabel] = useState<string | null>(null);\n\n  // Editor State\n  const [editingEntityId, setEditingEntityId] = useState<string | null>(null);\n  const [editorPosition, setEditorPosition] = useState<{x: number, y: number} | null>(null);\n\n  const [clipboard, setClipboard] = useState<string | null>(null);\n\n  const selectAll = () => {\n    // Create a Set of ALL node IDs\n    const allNodeIds = new Set(Object.keys(graph.nodesById));\n    \n    // Create a Set of ALL container IDs\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n\n    // Update State\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerIds(allContainerIds);\n  };\n\n  const copy = () => {\n      e.preventDefault();\n      \n      // 1. Gather data\n      const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n      const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n      \n      // 2. Gather edges (only if both source/target are being copied)\n      const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n      const edgesToCopy = Object.values(graph.edgesById).filter(edge => \n        allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId)\n      );\n\n      // 3. Save to internal clipboard state\n      const clipboardData = {\n        nodes: nodesToCopy,\n        containers: containersToCopy,\n        edges: edgesToCopy\n      };\n      \n      setClipboard(JSON.stringify(clipboardData));\n  }\n\n// --- Keyboard Handling (Delete) ---\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if user is typing in a text input\n      if ((e.target as HTMLElement).tagName === \"INPUT\") return;\n\n      if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n\n        const newGraph = graph.clone();\n        selectedNodes.forEach((id) => newGraph.removeNode(id));\n        selectedContainerIds.forEach((id) => newGraph.removeContainer(id));\n\n        onGraphChange(newGraph);\n        setSelectedNodes(new Set());\n        setSelectedContainerIds(new Set());\n      }\n\n      if (e.key === \"Escape\") {\n        clearAllStates();    \n      }\n\n      if (e.ctrlKey || e.metaKey){\n\n        // Select All\n        if (e.key === \"a\"){\n          selectAll();\n        }\n\n//        // Undo\n//        if (e.key === \"z\"){\n//        }\n//\n//        // Redo\n//        if (e.key === \"y\"){\n//        }\n\n        // --- COPY (Ctrl + C) ---\n        if (e.key === \"c\") {\n          copy();\n        }\n\n        // --- PASTE (Ctrl + V) ---\n        if (e.key === \"v\") {\n          e.preventDefault();\n          if (!clipboard) return;\n\n          try {\n            const data = JSON.parse(clipboard);\n            const newGraph = graph.clone();\n            \n            // Mappings to track Old ID -> New ID\n            const idMap = new Map<string, string>();\n            const newSelectedNodes = new Set<string>();\n            const newSelectedContainers = new Set<string>();\n\n            // 1. Paste Containers\n            data.containers.forEach((c: any) => {\n              const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n              idMap.set(c.id, newId);\n              newGraph.containersById[newId] = {\n                ...c,\n                id: newId,\n                position: { x: c.position.x + 20, y: c.position.y + 20 }, // Offset slightly\n                nodeIds: [], // Will rebuild these\n                childContainerIds: []\n              };\n              newSelectedContainers.add(newId);\n            });\n\n            // 2. Paste Nodes\n            data.nodes.forEach((n: any) => {\n              const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n              idMap.set(n.id, newId);\n              \n              newGraph.nodesById[newId] = {\n                ...n,\n                id: newId,\n                position: { x: n.position.x + 20, y: n.position.y + 20 },\n                parentId: n.parentId ? idMap.get(n.parentId) : undefined // Remap parent if it was also copied\n              };\n              newSelectedNodes.add(newId);\n\n              // If this node belongs to a container we just pasted, register it there\n              if (n.parentId && idMap.has(n.parentId)) {\n                 const newParentId = idMap.get(n.parentId)!;\n                 newGraph.containersById[newParentId]?.nodeIds.push(newId);\n              }\n            });\n\n            // 3. Paste Edges (Only if start/end exist in the paste)\n            data.edges.forEach((e: any) => {\n              const newSource = idMap.get(e.sourceNodeId);\n              const newTarget = idMap.get(e.targetNodeId);\n              \n              if (newSource && newTarget) {\n                const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n                newGraph.edgesById[newEdgeId] = {\n                  ...e,\n                  id: newEdgeId,\n                  sourceNodeId: newSource,\n                  targetNodeId: newTarget\n                };\n              }\n            });\n\n            // 4. Update State\n            onGraphChange(newGraph);\n            // Select the newly pasted items so user can immediately drag them\n            setSelectedNodes(newSelectedNodes);\n            setSelectedContainerIds(newSelectedContainers);\n\n          } catch (err) {\n            console.error(\"Paste failed\", err);\n          }\n        }\n      }\n  };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, onGraphChange]);\n\n  const getMousePos = (e: React.MouseEvent): Vec2 => {\n    const rect = containerRef.current!.getBoundingClientRect();\n    return { x: e.clientX - rect.left, y: e.clientY - rect.top };\n  };\n\n  const clearAllStates = () => {\n    setSelectedNodes(new Set());\n    setSelectedContainerIds(new Set());\n    setCanvasMenu(null);\n  };\n\n  const toggleContainer = (cid: ID) => { \n      const newGraph = graph.clone();\n      newGraph.toggleContainerCollapsed(cid);\n      onGraphChange(newGraph);\n  };\n\n  // --- Rendering Helpers ---\n\n  const renderPorts = (entity: Node | Container) => {\n    // USE LOGIC: Calculate which ports to show (proxies or real)\n    const portsToRender = \"nodeIds\" in entity \n      ? GraphLogic.getRenderablePorts(graph, entity as Container)\n      : (entity.ports || []);\n\n    return portsToRender.map((port) => {\n      // Geometry Calculation\n      // 1. Get Absolute Position from Geometry helper\n       const absPos = getPortPosition(\n         entity,\n         port.id,\n         graph,\n         \"nodeIds\" in entity ? (entity as Container).size : { width: 100, height: 50 }\n       );\n\n       // 2. FIX: Convert to Relative Position if inside a Container\n       let pos = { x: absPos.x, y: absPos.y };\n       if (\"nodeIds\" in entity) { // It is a container\n           pos.x = absPos.x - entity.position.x;\n           pos.y = absPos.y - entity.position.y;\n       }\n      return (\n        <div\n          key={port.id}\n          title={port.label}\n          style={{\n            position: \"absolute\",\n            left: pos.x - 6, top: pos.y - 6,\n            width: 12, height: 12, borderRadius: \"50%\",\n            backgroundColor: \"#fff\", border: \"2px solid #333\",\n            zIndex: 100, cursor: \"pointer\",\n          }}\n          onMouseEnter={() => setHoveredPort({ nodeId: entity.id, portId: port.id })}\n          onMouseLeave={() => setHoveredPort(null)}\n          onMouseDown={(e) => {\n            e.stopPropagation();\n            setCreatingEdge({ sourceNodeId: entity.id, position: pos}); \n            setDragStartPortId(port.id);\n            setPendingSourcePortLabel(port.label); \n            setMode(\"edge-create\");\n            setDragStartMouse(getMousePos(e));\n          }}\n        />\n      );\n    });\n  };\n\n  // --- Event Handlers ---\n\n  const handleMouseDown = (e: React.MouseEvent) => {\n    const pos = getMousePos(e);\n\n    // 1. Port Interaction\n    if (ENABLE_EXPLICIT_PORTS && hoveredPort) {\n        // Logic handled in renderPorts onMouseDown\n        return;\n    }\n\n    // 2. Right Click\n    if (e.button === 2 && e.target === e.currentTarget) {\n      const hitId = GraphLogic.hitTestEntity(graph, pos);\n       \n       if (!hitId) {\n           e.preventDefault();\n           setCanvasMenu({ \n               position: { x: pos.x, y: pos.y }, \n               targetId: undefined, \n               type: undefined \n           });\n           return;\n       }\n        return;\n    }\n\n    // 3. Canvas Click (Clear)\n    if (e.target === e.currentTarget) {\n        clearAllStates();\n        setMode(\"lasso\");\n        setLassoStart(pos);\n        setLassoEnd(pos);\n        setEditingEntityId(null);\n    }\n  };\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    const mousePos = getMousePos(e);\n\n    // 1. Handle Dragging Entities\n    if (mode === \"drag\" && dragStartMouse) {\n      const dx = mousePos.x - dragStartMouse.x;\n      const dy = mousePos.y - dragStartMouse.y;\n\n      const newGraph = graph.clone();\n      let changed = false;\n\n      dragStartPositions.forEach((startPos, id) => {\n        // Update Node Positions\n        const node = newGraph.nodesById[id];\n        if (node) {\n          node.position = { x: startPos.x + dx, y: startPos.y + dy };\n          changed = true;\n        }\n        // Update Container Positions\n        const container = newGraph.containersById[id];\n        if (container) {\n          container.position = { x: startPos.x + dx, y: startPos.y + dy };\n          changed = true;\n        }\n      });\n\n      if (changed) onGraphChange(newGraph);\n    }\n\n    // 2. Handle Edge Creation (Update the \"rubber band\" line)\n    if (mode === \"edge-create\" && creatingEdge) {\n      setCreatingEdge({ ...creatingEdge, position: mousePos });\n    }\n\n    // 3. Handle Lasso\n    if (mode === \"lasso\") {\n      setLassoEnd(mousePos);\n    }\n\n    if (mode === \"resize\" && resizingState) {\n          const dx = mousePos.x - resizingState.startMouse.x;\n        const dy = mousePos.y - resizingState.startMouse.y;\n\n        // Update locally to avoid massive re-renders, or update graph directly\n        const newGraph = graph.clone();\n        const container = newGraph.containersById[resizingState.id];\n        if (container) {\n            container.size = {\n                width: Math.max(100, resizingState.startSize.width + dx),\n                height: Math.max(50, resizingState.startSize.height + dy)\n            };\n            onGraphChange(newGraph);\n        }\n    }\n  };\n\n  const handleMouseUp = (e: React.MouseEvent) => {\n    const pos = getMousePos(e);\n\n    if (mode === \"edge-create\" && creatingEdge) {\n        // USE LOGIC: Hit test via the helper\n        let targetNodeId = hoveredPort ? hoveredPort.nodeId : GraphLogic.hitTestEntity(graph, pos);\n        let targetPortId = hoveredPort ? hoveredPort.portId : null;\n\n        if (targetNodeId && targetNodeId !== creatingEdge.sourceNodeId) {\n             // ... Perform your edge creation logic here ...\n             // (This is where you'd use graph.addEdge)\n             // Check if explicit ports are enabled, create ports if missing, etc.\n             const newGraph = graph.clone();\n             \n             // Example simple edge add for brevity (Replace with your robust logic):\n             const edgeId = `e_${crypto.randomUUID()}`;\n             newGraph.addEdge({\n                 id: edgeId,\n                 sourceNodeId: creatingEdge.sourceNodeId,    // <--- Fixed\n                 sourcePortId: creatingEdge.sourcePortId,\n                 targetNodeId: targetNodeId,                 // <--- Fixed\n                 targetPortId: targetPortId || undefined\n             });\n             onGraphChange(newGraph);\n        }\n        setCreatingEdge(null);\n        setMode(\"idle\");\n    }\n\n    if (mode === \"drag\") {\n        // USE LOGIC: When dropping, check containment\n        const newGraph = graph.clone();\n        \n        // Check every node/container that was dragged\n        // We only check the \"roots\" of the drag to avoid double processing\n        dragStartPositions.forEach((_, id) => {\n             GraphLogic.assignEntityToContainer(newGraph, id);\n             // Also recompute sizes of parents that might have grown\n             const parent = newGraph.nodesById[id]?.parentId || newGraph.containersById[id]?.parentId;\n             if(parent) GraphLogic.recomputeContainerSize(newGraph, parent);\n        });\n        \n        onGraphChange(newGraph);\n        setMode(\"idle\");\n        setDragStartMouse(null);\n        setDragStartPositions(new Map());\n    }\n    \n  if (mode === \"lasso\" && lassoStart && lassoEnd) {\n      // Calculate selection box\n      const x1 = Math.min(lassoStart.x, lassoEnd.x);\n      const x2 = Math.max(lassoStart.x, lassoEnd.x);\n      const y1 = Math.min(lassoStart.y, lassoEnd.y);\n      const y2 = Math.max(lassoStart.y, lassoEnd.y);\n\n      // Don't select if the box is tiny (accidental click)\n      if (Math.abs(x2 - x1) > 5 && Math.abs(y2 - y1) > 5) {\n          const newSelectedNodes = new Set<string>();\n          const newSelectedContainers = new Set<string>();\n\n          // Find nodes inside\n          Object.values(graph.nodesById).forEach(node => {\n              if (GraphLogic.isEntityVisible(graph, node.id) &&\n                  node.position.x >= x1 && node.position.x + 100 <= x2 && // Assuming width 100\n                  node.position.y >= y1 && node.position.y + 50 <= y2) {  // Assuming height 50\n                  newSelectedNodes.add(node.id);\n              }\n          });\n\n          // Find containers inside\n          Object.values(graph.containersById).forEach(container => {\n              if (GraphLogic.isEntityVisible(graph, container.id) &&\n                  container.position.x >= x1 && container.position.x + container.size.width <= x2 &&\n                  container.position.y >= y1 && container.position.y + container.size.height <= y2) {\n                  newSelectedContainers.add(container.id);\n              }\n          });\n\n          setSelectedNodes(newSelectedNodes);\n          setSelectedContainerIds(newSelectedContainers);\n      }\n      \n      setLassoStart(null);\n      setLassoEnd(null);\n    }\n    setMode(\"idle\");\n    \n  };\n\n  return (\n    <div \n        ref={containerRef} \n        className=\"graph-canvas\" \n        style={{ position: \"relative\", width: \"100%\", height: \"100%\", overflow: \"hidden\", userSelect: \"none\" }}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onContextMenu={(e) => e.preventDefault()}\n    >\n{Object.values(graph.containersById).map(c => {\n    if (!GraphLogic.isEntityVisible(graph, c.id)) return null;\n    return (\n        <React.Fragment key={c.id}>\n            <GraphContainer \n                container={c}\n                selected={selectedContainerIds.has(c.id)}\n                onMouseDown={(e) => {\n                    e.stopPropagation();\n                    // Select logic\n                    if (!e.shiftKey) {\n                        setSelectedNodes(new Set());\n                        setSelectedContainerIds(new Set([c.id]));\n                    } else {\n                        const newSet = new Set(selectedContainerIds);\n                        newSet.has(c.id) ? newSet.delete(c.id) : newSet.add(c.id);\n                        setSelectedContainerIds(newSet);\n                    }\n                    // Start dragging\n                    setMode(\"drag\");\n                    setDragStartMouse(getMousePos(e));\n                    setDragStartPositions(GraphLogic.collectDragStartPositions([c.id], new Map(), graph));\n                }}\n                onDoubleClick={(e) => {\n                    toggleContainer(c.id);\n                }}\n                onContextMenu={(e) => {}}\n                onResizeMouseDown={(e: React.MouseEvent) => {\n                  setResizingState({\n                    id: c.id,\n                    startMouse: getMousePos(e),\n                    startSize: { ...c.size }\n                  });\n                  setMode(\"resize\");\n                }}\n            >\n                {renderPorts(c)}\n            </GraphContainer>\n        </React.Fragment>\n    )\n})}\n\n        {Object.values(graph.nodesById).map(n => {\n            if (!GraphLogic.isEntityVisible(graph, n.id)) return null;\n            return (\n                    <React.Fragment key={n.id}>\n                    <GraphNode \n                        node={n}\n                        selected={selectedNodes.has(n.id)}\n                        onMouseDown={(e) => {\n                            e.stopPropagation();\n                            // Select logic\n                            if (!e.shiftKey) {\n                                setSelectedContainerIds(new Set());\n                                setSelectedNodes(new Set([n.id]));\n                            } else {\n                                const newSet = new Set(selectedNodes);\n                                newSet.has(n.id) ? newSet.delete(n.id) : newSet.add(n.id);\n                                setSelectedNodes(newSet);\n                            }\n                            \n                            // Right click check for menu\n                            if (e.button === 2) {\n                        //        setCanvasMenu({ targetId: n.id, type: \"node\", position: { x: e.clientX, y: e.clientY } });\n                              e.preventDefault();\n                              e.stopPropagation(); // Stop canvas from panning\n                              \n                              // Start Edge Creation Mode manually here\n                              const mousePos = getMousePos(e);\n                              setMode(\"edge-create\");\n                              setCreatingEdge({\n                                  sourceNodeId: n.id,\n                                  position: mousePos\n                              });\n                              return;\n                            }\n\n                            // Start dragging\n                            setMode(\"drag\");\n                            setDragStartMouse(getMousePos(e));\n                            setDragStartPositions(GraphLogic.collectDragStartPositions([n.id], new Map(), graph));\n                        }}\n                        onDoubleClick={(e: React.MouseEvent) => {\n                            e.stopPropagation();\n                            setEditingEntityId(n.id);\n                            const pos = getMousePos(e);\n                            setEditorPosition({ x: pos.x, y: pos.y });\n                        }}\n                    />\n                    {renderPorts(n)}\n                    </React.Fragment>\n            )\n        })}\n\n{/* --- SVG LAYER FOR EDGES --- */}\n        <svg\n          style={{\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            width: \"100%\",\n            height: \"100%\",\n            pointerEvents: \"none\",\n            overflow: \"visible\",\n            zIndex: 1 // Below nodes (zIndex 10) but above background\n          }}\n        >\n          {/* Helper to find where an edge should visually start/end */}\n          {(() => {\n            const getVisualPosition = (entityId: string): Vec2 | null => {\n              // 1. If the entity is directly visible, return its position\n              if (GraphLogic.isEntityVisible(graph, entityId)) {\n                return graph.nodesById[entityId]?.position || graph.containersById[entityId]?.position;\n              }\n              // 2. If hidden, look for its parent container\n              // (This is a simplified lookup; for deep nesting, you'd recurse)\n              const parent = Object.values(graph.containersById).find(c => \n                 c.nodeIds.includes(entityId) || c.childContainerIds?.includes(entityId)\n              );\n              \n              // If parent exists and is visible, snap to parent\n              if (parent && GraphLogic.isEntityVisible(graph, parent.id)) {\n                 return { \n                   x: parent.position.x + parent.size.width / 2, // Snap to center of container\n                   y: parent.position.y + parent.size.height / 2 \n                 };\n              }\n              return null;\n            };\n\n            return (\n              <>\n                {/* 1. Render Existing Edges */}\n                {Object.values(graph.edgesById).map((edge) => {\n                  const start = getVisualPosition(edge.sourceNodeId);\n                  const end = getVisualPosition(edge.targetNodeId);\n\n                  if (!start || !end) return null; // Both ends hidden deep inside collapsed structures\n\n                  return (\n                    <line\n                      key={edge.id}\n                      x1={start.x + (graph.nodesById[edge.sourceNodeId] ? 50 : 0)} // Offset center if it's a node\n                      y1={start.y + (graph.nodesById[edge.sourceNodeId] ? 25 : 0)}\n                      x2={end.x + (graph.nodesById[edge.targetNodeId] ? 50 : 0)}\n                      y2={end.y + (graph.nodesById[edge.targetNodeId] ? 25 : 0)}\n                      stroke=\"black\"\n                      strokeWidth=\"2\"\n                    />\n                  );\n                })}\n\n                {/* 2. Render Temporary \"Creating\" Edge */}\n                {mode === \"edge-create\" && creatingEdge && (\n                   <line\n                     x1={creatingEdge.position.x} // Mouse Position\n                     y1={creatingEdge.position.y}\n                     // Calculate start from the source node center\n                     x2={(() => {\n                        const n = graph.nodesById[creatingEdge.sourceNodeId];\n                        return n ? n.position.x + 50 : 0; \n                     })()}\n                     y2={(() => {\n                        const n = graph.nodesById[creatingEdge.sourceNodeId];\n                        return n ? n.position.y + 25 : 0; \n                     })()}\n                     stroke=\"black\"\n                     strokeWidth=\"2\"\n                     strokeDasharray=\"5,5\"\n                   />\n                )}\n              </>\n            );\n          })()}\n        </svg>\n\n        {/* Lasso Selection Box */}\n        {mode === \"lasso\" && lassoStart && lassoEnd && \n          (Math.abs(lassoStart.x - lassoEnd.x) > 5 || Math.abs(lassoStart.y - lassoEnd.y) > 5) && (\n             <Lasso start={lassoStart} end={lassoEnd} />\n        )}\n\n        {editingEntityId && editorPosition && (\n             <EntityEditor \n                entityId={editingEntityId}\n                graph={graph}\n                position={editorPosition}\n                onClose={() => setEditingEntityId(null)}\n                onGraphChange={onGraphChange}\n             />\n        )}\n\n    {/* --- CONTEXT MENU --- */}\n    {canvasMenu && (\n      <ContextMenu\n        position={canvasMenu.position}\n        options={(() => {\n          // 1. Menu for CANVAS (Background) -> Create New Items\n          if (!canvasMenu.targetId) {\n            return [\n              {\n                label: \"Add Node\",\n                onClick: () => {\n                  const newGraph = graph.clone();\n                  const id = `n_${crypto.randomUUID().slice(0, 4)}`;\n                  newGraph.addNode({\n                    id,\n                    label: \"New Node\",\n                    position: canvasMenu.position,\n                    ports: [],\n                    size: { width: 100, height: 50}\n                  });\n                  onGraphChange(newGraph);\n                  setCanvasMenu(null); // Close menu\n                }\n              },\n              {\n                label: \"Add Container\",\n                onClick: () => {\n                  const newGraph = graph.clone();\n                  const id = `c_${crypto.randomUUID().slice(0, 4)}`;\n                  newGraph.addContainer({\n                    id,\n                    label: \"New Container\",\n                    position: canvasMenu.position,\n                    size: { width: 300, height: 200 }, // Default size\n                    nodeIds: [],\n                    childContainerIds: [],\n                    collapsed: false\n                  });\n                  onGraphChange(newGraph);\n                  setCanvasMenu(null);\n                }\n              }\n            ];\n          }\n\n          // 2. Menu for NODES\n          if (canvasMenu.type === \"node\") {\n            return [\n              {\n                label: \"Rename\",\n                onClick: () => {\n                  setEditingEntityId(canvasMenu.targetId || null);\n                  setEditorPosition(canvasMenu.position);\n                  setCanvasMenu(null);\n                }\n              },\n              {\n                label: \"Delete Node\",\n                onClick: () => {\n                  if (canvasMenu.targetId) {\n                    const newGraph = graph.clone();\n                    newGraph.removeNode(canvasMenu.targetId);\n                    onGraphChange(newGraph);\n                  }\n                  setCanvasMenu(null);\n                }\n              }\n            ];\n          }\n\n          // 3. Menu for CONTAINERS\n          if (canvasMenu.type === \"container\") {\n            return [\n              {\n                label: \"Rename\",\n                onClick: () => {\n                  setEditingEntityId(canvasMenu.targetId || null);\n                  setEditorPosition(canvasMenu.position);\n                  setCanvasMenu(null);\n                }\n              },\n              {\n                label: \"Toggle Collapse\",\n                onClick: () => {\n                  if (canvasMenu.targetId) {\n                    toggleContainer(canvasMenu.targetId);\n                  }\n                  setCanvasMenu(null);\n                }\n              },\n              {\n                label: \"Delete Container\",\n                onClick: () => {\n                  if (canvasMenu.targetId) {\n                    const newGraph = graph.clone();\n                    newGraph.removeContainer(canvasMenu.targetId);\n                    onGraphChange(newGraph);\n                  }\n                  setCanvasMenu(null);\n                }\n              }\n            ];\n          }\n\n          return []; // Fallback\n        })()}\n      />\n    )}\n\n    {/* Close menu if clicking elsewhere */ }\n    {canvasMenu && (\n      <div \n         style={{ position: \"fixed\", top: 0, left: 0, width: \"100%\", height: \"100%\", zIndex: 999 }} \n         onMouseDown={() => setCanvasMenu(null)} \n         onContextMenu={(e) => { e.preventDefault(); setCanvasMenu(null); }} \n      />\n    )}\n    </div>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}