{"ast":null,"code":"var _jsxFileName = \"/home/belac/sysFlow/src/components/GraphCanvas.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef } from \"react\";\nimport { GraphNode } from \"./GraphNode\";\nimport { GraphContainer } from \"./GraphContainer\";\nimport { Lasso } from \"./Lasso\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport { EntityEditor } from \"./EntityEditor\";\nimport { getPortPosition } from \"../utils/Geometry\";\n\n// --- IMPORT THE LOGIC ---\nimport * as GraphLogic from \"../utils/GraphLogic\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const GraphCanvas = ({\n  graph,\n  onGraphChange,\n  renderNode,\n  renderContainer,\n  enablePorts\n}) => {\n  _s();\n  const containerRef = useRef(null);\n\n  // State\n  const [selectedNodes, setSelectedNodes] = useState(new Set());\n  const [selectedContainerIds, setSelectedContainerIds] = useState(new Set());\n  const [mode, setMode] = useState(\"idle\");\n  const [dragStartMouse, setDragStartMouse] = useState(null);\n  const [dragStartPositions, setDragStartPositions] = useState(new Map());\n  const [lassoStart, setLassoStart] = useState(null);\n  const [lassoEnd, setLassoEnd] = useState(null);\n  const [creatingEdge, setCreatingEdge] = useState(null);\n  const [canvasMenu, setCanvasMenu] = useState(null);\n  const [resizingState, setResizingState] = useState(null);\n  const [pendingEdgeStart, setPendingEdgeStart] = useState(null);\n  const [view, setView] = useState({\n    x: 0,\n    y: 0,\n    zoom: 1\n  });\n  const [isPanning, setIsPanning] = useState(false); // Track if middle-mouse is held\n\n  // Port State\n  const [hoveredPort, setHoveredPort] = useState(null);\n  const [dragStartPortId, setDragStartPortId] = useState(null);\n  const [pendingSourcePortLabel, setPendingSourcePortLabel] = useState(null);\n\n  // Editor State\n  const [editingEntityId, setEditingEntityId] = useState(null);\n  const [editorPosition, setEditorPosition] = useState(null);\n  const [clipboard, setClipboard] = useState(null);\n  const clearAllStates = () => {\n    setSelectedNodes(new Set());\n    setSelectedContainerIds(new Set());\n    setCanvasMenu(null);\n  };\n  const selectAll = () => {\n    const allNodeIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerIds(allContainerIds);\n  };\n  const deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n    const newGraph = graph.clone();\n    selectedNodes.forEach(id => newGraph.removeNode(id));\n    selectedContainerIds.forEach(id => newGraph.removeContainer(id));\n    onGraphChange(newGraph);\n    clearAllStates();\n  };\n  const copy = e => {\n    e.preventDefault();\n\n    // 1. Gather data\n    const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n    const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n\n    // 2. Gather edges (only if both source/target are being copied)\n    const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n    const edgesToCopy = Object.values(graph.edgesById).filter(edge => allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId));\n\n    // 3. Save to internal clipboard state\n    const clipboardData = {\n      nodes: nodesToCopy,\n      containers: containersToCopy,\n      edges: edgesToCopy\n    };\n    setClipboard(JSON.stringify(clipboardData));\n  };\n  const paste = e => {\n    e.preventDefault();\n    if (!clipboard) return;\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n\n      // Mappings to track Old ID -> New ID\n      const idMap = new Map();\n      const newSelectedNodes = new Set();\n      const newSelectedContainers = new Set();\n\n      // 1. Paste Containers\n      data.containers.forEach(c => {\n        const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(c.id, newId);\n        newGraph.containersById[newId] = {\n          ...c,\n          id: newId,\n          position: {\n            x: c.position.x + 20,\n            y: c.position.y + 20\n          },\n          // Offset slightly\n          nodeIds: [],\n          // Will rebuild these\n          childContainerIds: []\n        };\n        newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach(n => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        newGraph.nodesById[newId] = {\n          ...n,\n          id: newId,\n          position: {\n            x: n.position.x + 20,\n            y: n.position.y + 20\n          },\n          parentId: n.parentId ? idMap.get(n.parentId) : undefined // Remap parent if it was also copied\n        };\n        newSelectedNodes.add(newId);\n\n        // If this node belongs to a container we just pasted, register it there\n        if (n.parentId && idMap.has(n.parentId)) {\n          var _newGraph$containersB;\n          const newParentId = idMap.get(n.parentId);\n          (_newGraph$containersB = newGraph.containersById[newParentId]) === null || _newGraph$containersB === void 0 ? void 0 : _newGraph$containersB.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges (Only if start/end exist in the paste)\n      data.edges.forEach(e => {\n        const newSource = idMap.get(e.sourceNodeId);\n        const newTarget = idMap.get(e.targetNodeId);\n        if (newSource && newTarget) {\n          const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n          newGraph.edgesById[newEdgeId] = {\n            ...e,\n            id: newEdgeId,\n            sourceNodeId: newSource,\n            targetNodeId: newTarget\n          };\n        }\n      });\n\n      // 4. Update State\n      onGraphChange(newGraph);\n      // Select the newly pasted items so user can immediately drag them\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n    } catch (err) {\n      console.error(\"Paste failed\", err);\n    }\n  };\n  const completeExplicitEdge = targetNode => {\n    if (!enablePorts) {\n      return;\n    }\n    // Only run this if we have a pending start\n    if (!pendingEdgeStart) return;\n\n    // 1. Prompt for Target Port Name\n    const label = window.prompt(\"Enter Target Port Name:\", \"in-1\");\n\n    // HANDLE CANCELLATION (User dragged, but changed their mind at the last second)\n    if (!label) {\n      rollbackSourcePort(); // Delete the source port we made in step 1\n      return;\n    }\n    const newGraph = graph.clone();\n\n    // 2. Create Target Port on the Target Node\n    const newTargetPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n    const target = newGraph.nodesById[targetNode.id];\n    if (!target.ports) target.ports = [];\n    target.ports.push({\n      id: newTargetPortId,\n      label\n    });\n\n    // 3. Create the Edge connecting the two ports\n    const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n    newGraph.edgesById[newEdgeId] = {\n      id: newEdgeId,\n      sourceNodeId: pendingEdgeStart.nodeId,\n      sourcePortId: pendingEdgeStart.portId,\n      // <--- Link to specific source port\n      targetNodeId: targetNode.id,\n      targetPortId: newTargetPortId // <--- Link to specific target port\n    };\n    onGraphChange(newGraph);\n    setPendingEdgeStart(null); // Clear state\n  };\n\n  // --- Keyboard Handling ---\n  React.useEffect(() => {\n    const handleKeyDown = e => {\n      // Ignore if user is typing in a text input\n      if (e.target.tagName === \"INPUT\") return;\n      if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        deleteSelected();\n      }\n      if (e.key === \"Escape\") {\n        clearAllStates();\n      }\n      if (e.ctrlKey || e.metaKey) {\n        if (e.key === \"a\") {\n          selectAll();\n        }\n        if (e.key === \"c\") {\n          copy(e);\n        }\n        if (e.key === \"x\") {\n          copy(e);\n          deleteSelected();\n        }\n        if (e.key === \"v\") {\n          paste(e);\n        }\n        //        if (e.key === \"z\"){ undo(); }\n        //        if (e.key === \"y\"){ redo(); }\n      }\n    };\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, onGraphChange]);\n  const getMousePos = e => {\n    const rect = containerRef.current.getBoundingClientRect();\n    const screenX = e.clientX - rect.left;\n    const screenY = e.clientY - rect.top;\n    return {\n      x: (screenX - view.x) / view.zoom,\n      y: (screenY - view.y) / view.zoom\n    };\n  };\n  const getRelativePos = e => {\n    if (!containerRef.current) return {\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    // Get the position of the canvas div on the screen\n    const rect = containerRef.current.getBoundingClientRect();\n    return {\n      x: rect.left - view.x,\n      //e.clientX - rect.left, // Mouse X minus Canvas Left edge\n      y: rect.top - view.y // e.clientY - rect.top   // Mouse Y minus Canvas Top edge\n    };\n  };\n  const toggleContainer = cid => {\n    const newGraph = graph.clone();\n    newGraph.toggleContainerCollapsed(cid);\n    onGraphChange(newGraph);\n  };\n\n  // --- Port functions ----\n\n  const createPortAndStartDrag = entity => {\n    if (enablePorts) {\n      // 1. Prompt for Source Port Name\n      const label = window.prompt(\"Enter Source Port Name:\", \"out-1\");\n      if (!label) return; // User cancelled\n\n      // 2. Create the Port Object\n      const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n      const newPort = {\n        id: newPortId,\n        label\n      };\n\n      // 3. UPDATE GRAPH: Add port to source node immediately\n      const newGraph = graph.clone();\n      const node = newGraph.nodesById[entity.id];\n      if (!node.ports) node.ports = [];\n      node.ports.push(newPort);\n      onGraphChange(newGraph);\n\n      // 4. Save state to track we are currently dragging from this port\n      setPendingEdgeStart({\n        nodeId: entity.id,\n        portId: newPortId\n      });\n\n      // (Optional) Trigger your visual \"Ghost Line\" state here\n      // setInteractionState(\"dragging_edge\");\n    }\n  };\n  const rollbackSourcePort = () => {\n    if (!pendingEdgeStart) return;\n    const newGraph = graph.clone();\n    const node = newGraph.nodesById[pendingEdgeStart.nodeId];\n\n    // Remove the port with the matching ID\n    if (node && node.ports) {\n      node.ports = node.ports.filter(p => p.id !== pendingEdgeStart.portId);\n    }\n    onGraphChange(newGraph);\n    setPendingEdgeStart(null);\n  };\n\n  // --- Rendering Helpers ---\n\n  const renderPorts = entity => {\n    if (enablePorts) {\n      // USE LOGIC: Calculate which ports to show (proxies or real)\n      const portsToRender = \"nodeIds\" in entity ? GraphLogic.getRenderablePorts(graph, entity) : entity.ports || [];\n      return portsToRender.map(port => {\n        // Geometry Calculation\n        // 1. Get Absolute Position from Geometry helper\n        const absPos = getPortPosition(entity, port.id, graph, \"nodeIds\" in entity ? entity.size : {\n          width: 100,\n          height: 50\n        });\n        let pos = {\n          x: absPos.x,\n          y: absPos.y\n        };\n        if (\"nodeIds\" in entity) {\n          // It is a container\n          pos.x = absPos.x - entity.position.x;\n          pos.y = absPos.y - entity.position.y;\n        }\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          title: port.label,\n          style: {\n            position: \"absolute\",\n            left: pos.x - 6,\n            top: pos.y - 6,\n            width: 12,\n            height: 12,\n            borderRadius: \"50%\",\n            backgroundColor: \"#fff\",\n            border: \"2px solid #333\",\n            zIndex: 100,\n            cursor: \"pointer\"\n          },\n          onMouseEnter: () => setHoveredPort({\n            nodeId: entity.id,\n            portId: port.id\n          }),\n          onMouseLeave: () => setHoveredPort(null),\n          onMouseDown: e => {\n            e.stopPropagation();\n            setCreatingEdge({\n              sourceNodeId: entity.id,\n              position: pos\n            });\n            setDragStartPortId(port.id);\n            setPendingSourcePortLabel(port.label);\n            setMode(\"edge-create\");\n            setDragStartMouse(getMousePos(e));\n          }\n        }, port.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 334,\n          columnNumber: 9\n        }, this);\n      });\n    }\n  };\n\n  // --- Event Handlers (on Canvas) ---\n  const handleWheel = e => {\n    // If holding Ctrl, we Zoom. If not, we Pan (standard trackpad behavior)\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault(); // Stop browser zoom\n\n      const rect = containerRef.current.getBoundingClientRect();\n      const screenX = e.clientX - rect.left;\n      const screenY = e.clientY - rect.top;\n\n      // 1. Calculate where the mouse is in the WORLD currently\n      const worldX = (screenX - view.x) / view.zoom;\n      const worldY = (screenY - view.y) / view.zoom;\n\n      // 2. Calculate new Zoom\n      const zoomSensitivity = 0.001;\n      const delta = -e.deltaY * zoomSensitivity;\n      const newZoom = Math.min(Math.max(0.1, view.zoom * (1 + delta)), 5); // Limit 0.1x to 5x\n\n      // 3. Calculate new Pan so the mouse stays over the same world point\n      const newX = screenX - worldX * newZoom;\n      const newY = screenY - worldY * newZoom;\n      setView({\n        x: newX,\n        y: newY,\n        zoom: newZoom\n      });\n    } else {\n      // Standard Pan (Trackpad or Shift+Scroll)\n      setView(prev => ({\n        ...prev,\n        x: prev.x - e.deltaX,\n        y: prev.y - e.deltaY\n      }));\n    }\n  };\n  const handleMouseDown = e => {\n    // 0. PANNING START (Middle Mouse or Space + Left Click)\n    if (e.button === 1 || e.button === 0 && e.nativeEvent.getModifierState(\"Space\")) {\n      e.preventDefault();\n      setIsPanning(true);\n      setDragStartMouse({\n        x: e.clientX,\n        y: e.clientY\n      }); // Use raw screen coords for panning logic\n      return;\n    }\n    const pos = getMousePos(e);\n\n    // 1. Port Interaction\n    if (enablePorts && hoveredPort) {\n      // Logic handled in renderPorts onMouseDown\n      return;\n    }\n\n    // 2. Right Click\n    if (e.button === 2 && e.target === e.currentTarget) {\n      const hitId = GraphLogic.hitTestEntity(graph, pos);\n      const relPos = getRelativePos(e);\n      if (!hitId) {\n        e.preventDefault();\n        setCanvasMenu({\n          position: relPos,\n          targetId: undefined,\n          type: undefined\n        });\n        return;\n      }\n      return;\n    }\n\n    // 3. Canvas Click (Clear)\n    if (e.target === e.currentTarget) {\n      clearAllStates();\n      setMode(\"lasso\");\n      setLassoStart(pos);\n      setLassoEnd(pos);\n      setEditingEntityId(null);\n    }\n  };\n  const handleMouseMove = e => {\n    // 0. HANDLE PANNING\n    if (isPanning && dragStartMouse) {\n      const dx = e.clientX - dragStartMouse.x;\n      const dy = e.clientY - dragStartMouse.y;\n      setView(prev => ({\n        ...prev,\n        x: prev.x + dx,\n        y: prev.y + dy\n      }));\n      setDragStartMouse({\n        x: e.clientX,\n        y: e.clientY\n      }); // Reset for next frame\n      return;\n    }\n    const mousePos = getMousePos(e);\n\n    // 1. Handle Dragging Entities\n    if (mode === \"drag\" && dragStartMouse) {\n      const dx = mousePos.x - dragStartMouse.x;\n      const dy = mousePos.y - dragStartMouse.y;\n      const newGraph = graph.clone();\n      let changed = false;\n      dragStartPositions.forEach((startPos, id) => {\n        // Update Node Positions\n        const node = newGraph.nodesById[id];\n        if (node) {\n          node.position = {\n            x: startPos.x + dx,\n            y: startPos.y + dy\n          };\n          changed = true;\n        }\n        // Update Container Positions\n        const container = newGraph.containersById[id];\n        if (container) {\n          container.position = {\n            x: startPos.x + dx,\n            y: startPos.y + dy\n          };\n          changed = true;\n        }\n      });\n      if (changed) onGraphChange(newGraph);\n    }\n\n    // 2. Handle Edge Creation (Update the \"rubber band\" line)\n    if (mode === \"edge-create\" && creatingEdge) {\n      setCreatingEdge({\n        ...creatingEdge,\n        position: mousePos\n      });\n    }\n\n    // 3. Handle Lasso\n    if (mode === \"lasso\") {\n      setLassoEnd(mousePos);\n    }\n    if (mode === \"resize\" && resizingState) {\n      const dx = mousePos.x - resizingState.startMouse.x;\n      const dy = mousePos.y - resizingState.startMouse.y;\n\n      // Update locally to avoid massive re-renders, or update graph directly\n      const newGraph = graph.clone();\n      const container = newGraph.containersById[resizingState.id];\n      if (container) {\n        container.size = {\n          width: Math.max(100, resizingState.startSize.width + dx),\n          height: Math.max(50, resizingState.startSize.height + dy)\n        };\n        onGraphChange(newGraph);\n      }\n    }\n  };\n  const handleMouseUp = e => {\n    if (isPanning) {\n      setIsPanning(false);\n      setDragStartMouse(null);\n      return;\n    }\n    const pos = getMousePos(e);\n\n    // Inside handleMouseUp or your main event loop\n    if (mode === \"edge-create\" && creatingEdge) {\n      const targetNodeId = hoveredPort ? hoveredPort.nodeId : GraphLogic.hitTestEntity(graph, pos);\n\n      // Only proceed if we hit a valid target different from source\n      if (targetNodeId && targetNodeId !== creatingEdge.sourceNodeId) {\n        // START TRANSACTION (We might need to modify the graph multiple times)\n        let finalGraph = graph.clone();\n        let finalSourcePortId = creatingEdge.sourcePortId;\n        let finalTargetPortId = hoveredPort ? hoveredPort.portId : undefined;\n\n        // --- STEP 1: Handle Missing SOURCE Port ---\n        // User started dragging from a Node Body, not a Port\n        if (!finalSourcePortId && enablePorts) {\n          const label = window.prompt(\"Name the New Source Port:\", \"out-1\");\n          if (label) {\n            // Create port on Source Node\n            const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n            const sourceNode = finalGraph.nodesById[creatingEdge.sourceNodeId] || finalGraph.containersById[creatingEdge.sourceNodeId];\n            if (!sourceNode.ports) sourceNode.ports = [];\n            sourceNode.ports.push({\n              id: newPortId,\n              label\n            });\n            finalSourcePortId = newPortId; // Save for edge creation\n          } else {\n            // User cancelled source port creation -> Cancel entire operation\n            setCreatingEdge(null);\n            setMode(\"idle\");\n            return;\n          }\n        }\n\n        // --- STEP 2: Handle Missing TARGET Port ---\n        // User dropped on a Node Body, not a Port\n        if (!finalTargetPortId && enablePorts) {\n          const label = window.prompt(\"Name the New Target Port:\", \"in-1\");\n          if (label) {\n            // Create port on Target Node\n            const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n            const targetNode = finalGraph.nodesById[targetNodeId] || finalGraph.containersById[targetNodeId];\n            if (!targetNode.ports) targetNode.ports = [];\n            targetNode.ports.push({\n              id: newPortId,\n              label\n            });\n            finalTargetPortId = newPortId; // Save for edge creation\n          } else {\n            // User cancelled target port creation -> Cancel entire operation\n            setCreatingEdge(null);\n            setMode(\"idle\");\n            return;\n          }\n        }\n\n        // --- STEP 3: Create the Edge ---\n        // Only create if we have valid ports (or if we are in simple mode where ports are optional)\n        if (!enablePorts || finalSourcePortId && finalTargetPortId) {\n          const edgeId = `e_${crypto.randomUUID()}`;\n          finalGraph.edgesById[edgeId] = {\n            id: edgeId,\n            sourceNodeId: creatingEdge.sourceNodeId,\n            sourcePortId: finalSourcePortId,\n            // Use the resolved ID\n            targetNodeId: targetNodeId,\n            targetPortId: finalTargetPortId // Use the resolved ID\n          };\n          onGraphChange(finalGraph);\n        }\n      }\n\n      // Cleanup\n      setCreatingEdge(null);\n      setMode(\"idle\");\n    }\n    if (mode === \"drag\") {\n      // USE LOGIC: When dropping, check containment\n      const newGraph = graph.clone();\n\n      // Check every node/container that was dragged\n      // We only check the \"roots\" of the drag to avoid double processing\n      dragStartPositions.forEach((_, id) => {\n        var _newGraph$nodesById$i, _newGraph$containersB2;\n        GraphLogic.assignEntityToContainer(newGraph, id);\n        // Also recompute sizes of parents that might have grown\n        const parent = ((_newGraph$nodesById$i = newGraph.nodesById[id]) === null || _newGraph$nodesById$i === void 0 ? void 0 : _newGraph$nodesById$i.parentId) || ((_newGraph$containersB2 = newGraph.containersById[id]) === null || _newGraph$containersB2 === void 0 ? void 0 : _newGraph$containersB2.parentId);\n        if (parent) GraphLogic.recomputeContainerSize(newGraph, parent);\n      });\n      onGraphChange(newGraph);\n      setMode(\"idle\");\n      setDragStartMouse(null);\n      setDragStartPositions(new Map());\n    }\n    if (mode === \"lasso\" && lassoStart && lassoEnd) {\n      // Calculate selection box\n      const x1 = Math.min(lassoStart.x, lassoEnd.x);\n      const x2 = Math.max(lassoStart.x, lassoEnd.x);\n      const y1 = Math.min(lassoStart.y, lassoEnd.y);\n      const y2 = Math.max(lassoStart.y, lassoEnd.y);\n\n      // Don't select if the box is tiny (accidental click)\n      if (Math.abs(x2 - x1) > 5 && Math.abs(y2 - y1) > 5) {\n        const newSelectedNodes = new Set();\n        const newSelectedContainers = new Set();\n\n        // Find nodes inside\n        Object.values(graph.nodesById).forEach(node => {\n          if (GraphLogic.isEntityVisible(graph, node.id) && node.position.x >= x1 && node.position.x + 100 <= x2 &&\n          // Assuming width 100\n          node.position.y >= y1 && node.position.y + 50 <= y2) {\n            // Assuming height 50\n            newSelectedNodes.add(node.id);\n          }\n        });\n\n        // Find containers inside\n        Object.values(graph.containersById).forEach(container => {\n          if (GraphLogic.isEntityVisible(graph, container.id) && container.position.x >= x1 && container.position.x + container.size.width <= x2 && container.position.y >= y1 && container.position.y + container.size.height <= y2) {\n            newSelectedContainers.add(container.id);\n          }\n        });\n        setSelectedNodes(newSelectedNodes);\n        setSelectedContainerIds(newSelectedContainers);\n      }\n      setLassoStart(null);\n      setLassoEnd(null);\n    }\n    setMode(\"idle\");\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"graph-canvas\",\n    style: {\n      position: \"relative\",\n      width: \"100%\",\n      height: \"100%\",\n      overflow: \"hidden\",\n      userSelect: \"none\",\n      cursor: isPanning ? \"grabbing\" : \"default\"\n    },\n    onWheel: handleWheel,\n    onMouseDown: handleMouseDown,\n    onMouseMove: handleMouseMove,\n    onMouseUp: handleMouseUp,\n    onContextMenu: e => e.preventDefault(),\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        transform: `translate(${view.x}px, ${view.y}px) scale(${view.zoom})`,\n        transformOrigin: \"0 0\",\n        // Important: Scale from top-left, we handle offset manually\n        width: \"100%\",\n        height: \"100%\",\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      },\n      children: [Object.values(graph.containersById).map(c => {\n        if (!GraphLogic.isEntityVisible(graph, c.id)) return null;\n        return /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: /*#__PURE__*/_jsxDEV(GraphContainer, {\n            container: c,\n            selected: selectedContainerIds.has(c.id),\n            onMouseDown: e => {\n              e.stopPropagation();\n              // Select logic\n              if (!e.shiftKey) {\n                setSelectedNodes(new Set());\n                setSelectedContainerIds(new Set([c.id]));\n              } else {\n                const newSet = new Set(selectedContainerIds);\n                newSet.has(c.id) ? newSet.delete(c.id) : newSet.add(c.id);\n                setSelectedContainerIds(newSet);\n              }\n              // Start dragging\n              setMode(\"drag\");\n              setDragStartMouse(getMousePos(e));\n              setDragStartPositions(GraphLogic.collectDragStartPositions([...selectedContainerIds, ...selectedNodes, c.id], new Map(), graph));\n            },\n            onDoubleClick: e => {\n              toggleContainer(c.id);\n            },\n            onContextMenu: e => {},\n            onResizeMouseDown: e => {\n              setResizingState({\n                id: c.id,\n                startMouse: getMousePos(e),\n                startSize: {\n                  ...c.size\n                }\n              });\n              setMode(\"resize\");\n            },\n            children: renderPorts(c)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 681,\n            columnNumber: 13\n          }, this)\n        }, c.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 680,\n          columnNumber: 9\n        }, this);\n      }), Object.values(graph.nodesById).map(n => {\n        if (!GraphLogic.isEntityVisible(graph, n.id)) return null;\n        return /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(GraphNode, {\n            node: n,\n            selected: selectedNodes.has(n.id),\n            onMouseDown: e => {\n              e.stopPropagation();\n              // Select logic\n              if (!e.shiftKey) {\n                setSelectedContainerIds(new Set());\n                setSelectedNodes(new Set([n.id]));\n              } else {\n                const newSet = new Set(selectedNodes);\n                newSet.has(n.id) ? newSet.delete(n.id) : newSet.add(n.id);\n                setSelectedNodes(newSet);\n              }\n\n              // Right click check for menu\n              if (e.button === 2) {\n                //        setCanvasMenu({ targetId: n.id, type: \"node\", position: { x: e.clientX, y: e.clientY } });\n                e.preventDefault();\n                e.stopPropagation(); // Stop canvas from panning\n\n                // Start Edge Creation Mode manually here\n                const mousePos = getMousePos(e);\n                setMode(\"edge-create\");\n                setCreatingEdge({\n                  sourceNodeId: n.id,\n                  position: mousePos\n                });\n                createPortAndStartDrag(n);\n                return;\n              }\n\n              // Start dragging\n              setMode(\"drag\");\n              setDragStartMouse(getMousePos(e));\n              setDragStartPositions(GraphLogic.collectDragStartPositions([...selectedContainerIds, ...selectedNodes, n.id], new Map(), graph));\n            },\n            onDoubleClick: e => {\n              e.stopPropagation();\n              setEditingEntityId(n.id);\n              const pos = getMousePos(e);\n              setEditorPosition({\n                x: pos.x,\n                y: pos.y\n              });\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 723,\n            columnNumber: 21\n          }, this), renderPorts(n)]\n        }, n.id, true, {\n          fileName: _jsxFileName,\n          lineNumber: 722,\n          columnNumber: 21\n        }, this);\n      }), /*#__PURE__*/_jsxDEV(\"svg\", {\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: \"100%\",\n          height: \"100%\",\n          pointerEvents: \"none\",\n          overflow: \"visible\",\n          zIndex: 10 // Below nodes (zIndex 10) but above background\n        },\n        children: (() => {\n          const getVisualPosition = entityId => {\n            // 1. If the entity is directly visible, return its position\n            if (GraphLogic.isEntityVisible(graph, entityId)) {\n              var _graph$nodesById$enti, _graph$containersById;\n              return ((_graph$nodesById$enti = graph.nodesById[entityId]) === null || _graph$nodesById$enti === void 0 ? void 0 : _graph$nodesById$enti.position) || ((_graph$containersById = graph.containersById[entityId]) === null || _graph$containersById === void 0 ? void 0 : _graph$containersById.position);\n            }\n            // 2. If hidden, look for its parent container\n            // (This is a simplified lookup; for deep nesting, you'd recurse)\n            const parent = Object.values(graph.containersById).find(c => {\n              var _c$childContainerIds;\n              return c.nodeIds.includes(entityId) || ((_c$childContainerIds = c.childContainerIds) === null || _c$childContainerIds === void 0 ? void 0 : _c$childContainerIds.includes(entityId));\n            });\n\n            // If parent exists and is visible, snap to parent\n            if (parent && GraphLogic.isEntityVisible(graph, parent.id)) {\n              return {\n                x: parent.position.x + parent.size.width / 2,\n                // Snap to center of container\n                y: parent.position.y + parent.size.height / 2\n              };\n            }\n            return null;\n          };\n          return /*#__PURE__*/_jsxDEV(_Fragment, {\n            children: [Object.values(graph.edgesById).map(edge => {\n              const start = getVisualPosition(edge.sourceNodeId);\n              const end = getVisualPosition(edge.targetNodeId);\n              if (!start || !end) return null; // Both ends hidden deep inside collapsed structures\n\n              return /*#__PURE__*/_jsxDEV(\"line\", {\n                x1: start.x + (graph.nodesById[edge.sourceNodeId] ? 50 : 0) // Offset center if it's a node\n                ,\n                y1: start.y + (graph.nodesById[edge.sourceNodeId] ? 25 : 0),\n                x2: end.x + (graph.nodesById[edge.targetNodeId] ? 50 : 0),\n                y2: end.y + (graph.nodesById[edge.targetNodeId] ? 25 : 0),\n                stroke: \"black\",\n                strokeWidth: \"2\"\n              }, edge.id, false, {\n                fileName: _jsxFileName,\n                lineNumber: 818,\n                columnNumber: 21\n              }, this);\n            }), mode === \"edge-create\" && creatingEdge && /*#__PURE__*/_jsxDEV(\"line\", {\n              x1: creatingEdge.position.x // Mouse Position\n              ,\n              y1: creatingEdge.position.y\n              // Calculate start from the source node center\n              ,\n              x2: (() => {\n                const n = graph.nodesById[creatingEdge.sourceNodeId];\n                return n ? n.position.x + 50 : 0;\n              })(),\n              y2: (() => {\n                const n = graph.nodesById[creatingEdge.sourceNodeId];\n                return n ? n.position.y + 25 : 0;\n              })(),\n              stroke: \"black\",\n              strokeWidth: \"2\",\n              strokeDasharray: \"5,5\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 832,\n              columnNumber: 20\n            }, this)]\n          }, void 0, true);\n        })()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 773,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 667,\n      columnNumber: 7\n    }, this), mode === \"lasso\" && lassoStart && lassoEnd && (Math.abs(lassoStart.x - lassoEnd.x) > 5 || Math.abs(lassoStart.y - lassoEnd.y) > 5) && /*#__PURE__*/_jsxDEV(Lasso, {\n      start: lassoStart,\n      end: lassoEnd\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 862,\n      columnNumber: 14\n    }, this), editingEntityId && editorPosition && /*#__PURE__*/_jsxDEV(EntityEditor, {\n      entityId: editingEntityId,\n      graph: graph,\n      position: editorPosition,\n      onClose: () => setEditingEntityId(null),\n      onGraphChange: onGraphChange,\n      enablePorts: enablePorts\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 866,\n      columnNumber: 14\n    }, this), canvasMenu && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        top: canvasMenu.position.y,\n        left: canvasMenu.position.x,\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(ContextMenu, {\n        position: canvasMenu.position,\n        options: (() => {\n          // 1. Menu for CANVAS (Background) -> Create New Items\n          if (!canvasMenu.targetId) {\n            return [{\n              label: \"Add Node\",\n              onClick: () => {\n                const newGraph = graph.clone();\n                const id = `n_${crypto.randomUUID().slice(0, 4)}`;\n                newGraph.addNode({\n                  id,\n                  label: \"New Node\",\n                  position: canvasMenu.position,\n                  ports: [],\n                  size: {\n                    width: 100,\n                    height: 50\n                  }\n                });\n                onGraphChange(newGraph);\n                setCanvasMenu(null); // Close menu\n              }\n            }, {\n              label: \"Add Container\",\n              onClick: () => {\n                const newGraph = graph.clone();\n                const id = `c_${crypto.randomUUID().slice(0, 4)}`;\n                newGraph.addContainer({\n                  id,\n                  label: \"New Container\",\n                  position: canvasMenu.position,\n                  size: {\n                    width: 300,\n                    height: 200\n                  },\n                  // Default size\n                  nodeIds: [],\n                  childContainerIds: [],\n                  collapsed: false\n                });\n                onGraphChange(newGraph);\n                setCanvasMenu(null);\n              }\n            }];\n          }\n\n          // 2. Menu for NODES\n          if (canvasMenu.type === \"node\") {\n            return [{\n              label: \"Rename\",\n              onClick: () => {\n                setEditingEntityId(canvasMenu.targetId || null);\n                setEditorPosition(canvasMenu.position);\n                setCanvasMenu(null);\n              }\n            }, {\n              label: \"Delete Node\",\n              onClick: () => {\n                if (canvasMenu.targetId) {\n                  const newGraph = graph.clone();\n                  newGraph.removeNode(canvasMenu.targetId);\n                  onGraphChange(newGraph);\n                }\n                setCanvasMenu(null);\n              }\n            }];\n          }\n\n          // 3. Menu for CONTAINERS\n          if (canvasMenu.type === \"container\") {\n            return [{\n              label: \"Rename\",\n              onClick: () => {\n                setEditingEntityId(canvasMenu.targetId || null);\n                setEditorPosition(canvasMenu.position);\n                setCanvasMenu(null);\n              }\n            }, {\n              label: \"Toggle Collapse\",\n              onClick: () => {\n                if (canvasMenu.targetId) {\n                  toggleContainer(canvasMenu.targetId);\n                }\n                setCanvasMenu(null);\n              }\n            }, {\n              label: \"Delete Container\",\n              onClick: () => {\n                if (canvasMenu.targetId) {\n                  const newGraph = graph.clone();\n                  newGraph.removeContainer(canvasMenu.targetId);\n                  onGraphChange(newGraph);\n                }\n                setCanvasMenu(null);\n              }\n            }];\n          }\n          return []; // Fallback\n        })()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 886,\n        columnNumber: 7\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 878,\n      columnNumber: 7\n    }, this), canvasMenu && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        zIndex: 999\n      },\n      onMouseDown: () => setCanvasMenu(null),\n      onContextMenu: e => {\n        e.preventDefault();\n        setCanvasMenu(null);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 996,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 649,\n    columnNumber: 5\n  }, this);\n};\n_s(GraphCanvas, \"BQWLDlt3yt+Rngme2bLyfaXiM7E=\");\n_c = GraphCanvas;\nvar _c;\n$RefreshReg$(_c, \"GraphCanvas\");","map":{"version":3,"names":["React","useState","useRef","GraphNode","GraphContainer","Lasso","ContextMenu","EntityEditor","getPortPosition","GraphLogic","jsxDEV","_jsxDEV","Fragment","_Fragment","GraphCanvas","graph","onGraphChange","renderNode","renderContainer","enablePorts","_s","containerRef","selectedNodes","setSelectedNodes","Set","selectedContainerIds","setSelectedContainerIds","mode","setMode","dragStartMouse","setDragStartMouse","dragStartPositions","setDragStartPositions","Map","lassoStart","setLassoStart","lassoEnd","setLassoEnd","creatingEdge","setCreatingEdge","canvasMenu","setCanvasMenu","resizingState","setResizingState","pendingEdgeStart","setPendingEdgeStart","view","setView","x","y","zoom","isPanning","setIsPanning","hoveredPort","setHoveredPort","dragStartPortId","setDragStartPortId","pendingSourcePortLabel","setPendingSourcePortLabel","editingEntityId","setEditingEntityId","editorPosition","setEditorPosition","clipboard","setClipboard","clearAllStates","selectAll","allNodeIds","Object","keys","nodesById","allContainerIds","containersById","deleteSelected","size","newGraph","clone","forEach","id","removeNode","removeContainer","copy","e","preventDefault","nodesToCopy","values","filter","n","has","containersToCopy","c","allSelectedIds","edgesToCopy","edgesById","edge","sourceNodeId","targetNodeId","clipboardData","nodes","containers","edges","JSON","stringify","paste","data","parse","idMap","newSelectedNodes","newSelectedContainers","newId","crypto","randomUUID","slice","set","position","nodeIds","childContainerIds","add","parentId","get","undefined","_newGraph$containersB","newParentId","push","newSource","newTarget","newEdgeId","err","console","error","completeExplicitEdge","targetNode","label","window","prompt","rollbackSourcePort","newTargetPortId","target","ports","nodeId","sourcePortId","portId","targetPortId","useEffect","handleKeyDown","tagName","key","ctrlKey","metaKey","addEventListener","removeEventListener","getMousePos","rect","current","getBoundingClientRect","screenX","clientX","left","screenY","clientY","top","getRelativePos","toggleContainer","cid","toggleContainerCollapsed","createPortAndStartDrag","entity","newPortId","newPort","node","p","renderPorts","portsToRender","getRenderablePorts","map","port","absPos","width","height","pos","title","style","borderRadius","backgroundColor","border","zIndex","cursor","onMouseEnter","onMouseLeave","onMouseDown","stopPropagation","fileName","_jsxFileName","lineNumber","columnNumber","handleWheel","worldX","worldY","zoomSensitivity","delta","deltaY","newZoom","Math","min","max","newX","newY","prev","deltaX","handleMouseDown","button","nativeEvent","getModifierState","currentTarget","hitId","hitTestEntity","relPos","targetId","type","handleMouseMove","dx","dy","mousePos","changed","startPos","container","startMouse","startSize","handleMouseUp","finalGraph","finalSourcePortId","finalTargetPortId","sourceNode","edgeId","_","_newGraph$nodesById$i","_newGraph$containersB2","assignEntityToContainer","parent","recomputeContainerSize","x1","x2","y1","y2","abs","isEntityVisible","ref","className","overflow","userSelect","onWheel","onMouseMove","onMouseUp","onContextMenu","children","transform","transformOrigin","selected","shiftKey","newSet","delete","collectDragStartPositions","onDoubleClick","onResizeMouseDown","pointerEvents","getVisualPosition","entityId","_graph$nodesById$enti","_graph$containersById","find","_c$childContainerIds","includes","start","end","stroke","strokeWidth","strokeDasharray","onClose","options","onClick","addNode","addContainer","collapsed","_c","$RefreshReg$"],"sources":["/home/belac/sysFlow/src/components/GraphCanvas.tsx"],"sourcesContent":["import React, { useState, useRef } from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\nimport { Node } from \"../models/Node\";\nimport { Container } from \"../models/Container\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { GraphNode } from \"./GraphNode\";\nimport { GraphContainer } from \"./GraphContainer\";\nimport { GraphEdge } from \"./GraphEdge\";\nimport { Lasso } from \"./Lasso\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport { EntityEditor } from \"./EntityEditor\";\nimport { getPortPosition } from \"../utils/Geometry\";\n\n// --- IMPORT THE LOGIC ---\nimport * as GraphLogic from \"../utils/GraphLogic\";\n\ntype InteractionMode = \"idle\" | \"drag\" | \"lasso\" | \"edge-create\" | \"resize\";\n\ninterface GraphCanvasProps {\n  graph: GraphModel;\n  onGraphChange: (newGraph: GraphModel) => void;\n  renderNode?: (node: Node, selected: boolean) => React.ReactNode;\n  renderContainer?: (container: Container, collapsed: boolean) => React.ReactNode;\n  enablePorts: boolean;\n}\n\nexport const GraphCanvas = ({ graph, onGraphChange, renderNode, renderContainer, enablePorts }: GraphCanvasProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // State\n  const [selectedNodes, setSelectedNodes] = useState<Set<ID>>(new Set());\n  const [selectedContainerIds, setSelectedContainerIds] = useState<Set<ID>>(new Set());\n  const [mode, setMode] = useState<InteractionMode>(\"idle\");\n  const [dragStartMouse, setDragStartMouse] = useState<Vec2 | null>(null);\n  const [dragStartPositions, setDragStartPositions] = useState<Map<ID, Vec2>>(new Map());\n  const [lassoStart, setLassoStart] = useState<Vec2 | null>(null);\n  const [lassoEnd, setLassoEnd] = useState<Vec2 | null>(null);\n  const [creatingEdge, setCreatingEdge] = useState<{sourceNodeId: ID; sourcePortId?: ID; position: Vec2} | null>(null);\n  const [canvasMenu, setCanvasMenu] = useState<{ targetId?: ID; type?: string; position: Vec2 } | null>(null);\n  const [resizingState, setResizingState] = useState<{ id: ID; startMouse: Vec2; startSize: { width: number; height: number };} | null>(null);\n  const [pendingEdgeStart, setPendingEdgeStart] = useState<{ nodeId: string, portId: string } | null>(null);\n\n  const [view, setView] = useState({ x: 0, y: 0, zoom: 1 });\n  const [isPanning, setIsPanning] = useState(false); // Track if middle-mouse is held\n  \n  // Port State\n  const [hoveredPort, setHoveredPort] = useState<{nodeId: ID, portId: ID } | null>(null);\n  const [dragStartPortId, setDragStartPortId] = useState<ID | null>(null);\n  const [pendingSourcePortLabel, setPendingSourcePortLabel] = useState<string | null>(null);\n\n  // Editor State\n  const [editingEntityId, setEditingEntityId] = useState<string | null>(null);\n  const [editorPosition, setEditorPosition] = useState<{x: number, y: number} | null>(null);\n\n  const [clipboard, setClipboard] = useState<string | null>(null);\n\n  const clearAllStates = () => {\n    setSelectedNodes(new Set());\n    setSelectedContainerIds(new Set());\n    setCanvasMenu(null);\n  };\n\n  const selectAll = () => {\n    const allNodeIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerIds(allContainerIds);\n  };\n\n  const deleteSelected = () => {\n      if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n\n      const newGraph = graph.clone();\n      selectedNodes.forEach((id) => newGraph.removeNode(id));\n      selectedContainerIds.forEach((id) => newGraph.removeContainer(id));\n\n      onGraphChange(newGraph);\n\n      clearAllStates();\n  };\n\n  const copy = (e: KeyboardEvent) => {\n      e.preventDefault();\n      \n      // 1. Gather data\n      const nodesToCopy = Object.values(graph.nodesById).filter(n => selectedNodes.has(n.id));\n      const containersToCopy = Object.values(graph.containersById).filter(c => selectedContainerIds.has(c.id));\n      \n      // 2. Gather edges (only if both source/target are being copied)\n      const allSelectedIds = new Set([...selectedNodes, ...selectedContainerIds]);\n      const edgesToCopy = Object.values(graph.edgesById).filter(edge => \n        allSelectedIds.has(edge.sourceNodeId) && allSelectedIds.has(edge.targetNodeId)\n      );\n\n      // 3. Save to internal clipboard state\n      const clipboardData = {\n        nodes: nodesToCopy,\n        containers: containersToCopy,\n        edges: edgesToCopy\n      };\n      \n      setClipboard(JSON.stringify(clipboardData));\n  };\n\n  const paste = (e: KeyboardEvent) => {\n    e.preventDefault();\n    if (!clipboard) return;\n\n    try {\n      const data = JSON.parse(clipboard);\n      const newGraph = graph.clone();\n      \n      // Mappings to track Old ID -> New ID\n      const idMap = new Map<string, string>();\n      const newSelectedNodes = new Set<string>();\n      const newSelectedContainers = new Set<string>();\n\n      // 1. Paste Containers\n      data.containers.forEach((c: any) => {\n        const newId = `c_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(c.id, newId);\n        newGraph.containersById[newId] = {\n          ...c,\n          id: newId,\n          position: { x: c.position.x + 20, y: c.position.y + 20 }, // Offset slightly\n          nodeIds: [], // Will rebuild these\n          childContainerIds: []\n        };\n        newSelectedContainers.add(newId);\n      });\n\n      // 2. Paste Nodes\n      data.nodes.forEach((n: any) => {\n        const newId = `n_${crypto.randomUUID().slice(0, 4)}`;\n        idMap.set(n.id, newId);\n        \n        newGraph.nodesById[newId] = {\n          ...n,\n          id: newId,\n          position: { x: n.position.x + 20, y: n.position.y + 20 },\n          parentId: n.parentId ? idMap.get(n.parentId) : undefined // Remap parent if it was also copied\n        };\n        newSelectedNodes.add(newId);\n\n        // If this node belongs to a container we just pasted, register it there\n        if (n.parentId && idMap.has(n.parentId)) {\n           const newParentId = idMap.get(n.parentId)!;\n           newGraph.containersById[newParentId]?.nodeIds.push(newId);\n        }\n      });\n\n      // 3. Paste Edges (Only if start/end exist in the paste)\n      data.edges.forEach((e: any) => {\n        const newSource = idMap.get(e.sourceNodeId);\n        const newTarget = idMap.get(e.targetNodeId);\n        \n        if (newSource && newTarget) {\n          const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n          newGraph.edgesById[newEdgeId] = {\n            ...e,\n            id: newEdgeId,\n            sourceNodeId: newSource,\n            targetNodeId: newTarget\n          };\n        }\n      });\n\n      // 4. Update State\n      onGraphChange(newGraph);\n      // Select the newly pasted items so user can immediately drag them\n      setSelectedNodes(newSelectedNodes);\n      setSelectedContainerIds(newSelectedContainers);\n\n    } catch (err) {\n      console.error(\"Paste failed\", err);\n    }\n  };\n\n  const completeExplicitEdge = (targetNode: Entity) => {\n    if (!enablePorts) { return; }\n     // Only run this if we have a pending start\n     if (!pendingEdgeStart) return;\n\n     // 1. Prompt for Target Port Name\n     const label = window.prompt(\"Enter Target Port Name:\", \"in-1\");\n     \n     // HANDLE CANCELLATION (User dragged, but changed their mind at the last second)\n     if (!label) {\n        rollbackSourcePort(); // Delete the source port we made in step 1\n        return;\n     }\n\n     const newGraph = graph.clone();\n\n     // 2. Create Target Port on the Target Node\n     const newTargetPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n     const target = newGraph.nodesById[targetNode.id];\n     if(!target.ports) target.ports = [];\n     target.ports.push({ id: newTargetPortId, label });\n\n     // 3. Create the Edge connecting the two ports\n     const newEdgeId = `e_${crypto.randomUUID().slice(0, 4)}`;\n     newGraph.edgesById[newEdgeId] = {\n        id: newEdgeId,\n        sourceNodeId: pendingEdgeStart.nodeId,\n        sourcePortId: pendingEdgeStart.portId, // <--- Link to specific source port\n        targetNodeId: targetNode.id,\n        targetPortId: newTargetPortId          // <--- Link to specific target port\n     };\n\n     onGraphChange(newGraph);\n     setPendingEdgeStart(null); // Clear state\n  };\n\n// --- Keyboard Handling ---\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Ignore if user is typing in a text input\n      if ((e.target as HTMLElement).tagName === \"INPUT\") return;\n\n      if (e.key === \"Delete\" || e.key === \"Backspace\") { deleteSelected(); }\n      if (e.key === \"Escape\") { clearAllStates(); }\n\n      if (e.ctrlKey || e.metaKey){\n        if (e.key === \"a\") { selectAll(); }\n        if (e.key === \"c\") { copy(e); }\n        if (e.key === \"x\") { copy(e); deleteSelected(); }\n        if (e.key === \"v\") { paste(e); }\n//        if (e.key === \"z\"){ undo(); }\n//        if (e.key === \"y\"){ redo(); }\n      }\n  };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [graph, selectedNodes, selectedContainerIds, onGraphChange]);\n\n  const getMousePos = (e: React.MouseEvent): Vec2 => {\n    const rect = containerRef.current!.getBoundingClientRect();\n    const screenX = e.clientX - rect.left;\n    const screenY = e.clientY - rect.top;\n\n    return {\n      x: (screenX - view.x) / view.zoom,\n      y: (screenY - view.y) / view.zoom\n    };\n  };\n\n  const getRelativePos = (e: React.MouseEvent) => {\n    if (!containerRef.current) return { x: e.clientX, y: e.clientY };\n    \n    // Get the position of the canvas div on the screen\n    const rect = containerRef.current.getBoundingClientRect();\n    \n    return {\n      x: rect.left-view.x,//e.clientX - rect.left, // Mouse X minus Canvas Left edge\n      y: rect.top-view.y // e.clientY - rect.top   // Mouse Y minus Canvas Top edge\n    };\n  };\n\n  const toggleContainer = (cid: ID) => { \n      const newGraph = graph.clone();\n      newGraph.toggleContainerCollapsed(cid);\n      onGraphChange(newGraph);\n  };\n\n  // --- Port functions ----\n\n  const createPortAndStartDrag = (entity: Entity) => {\n    if (enablePorts) {\n      // 1. Prompt for Source Port Name\n      const label = window.prompt(\"Enter Source Port Name:\", \"out-1\");\n      if (!label) return; // User cancelled\n\n      // 2. Create the Port Object\n      const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n      const newPort = { id: newPortId, label };\n\n      // 3. UPDATE GRAPH: Add port to source node immediately\n      const newGraph = graph.clone();\n      const node = newGraph.nodesById[entity.id];\n      if (!node.ports) node.ports = [];\n      node.ports.push(newPort);\n      onGraphChange(newGraph);\n\n      // 4. Save state to track we are currently dragging from this port\n      setPendingEdgeStart({ nodeId: entity.id, portId: newPortId });\n      \n      // (Optional) Trigger your visual \"Ghost Line\" state here\n      // setInteractionState(\"dragging_edge\");\n    }\n  };\n\n  const rollbackSourcePort = () => {\n    if (!pendingEdgeStart) return;\n\n    const newGraph = graph.clone();\n    const node = newGraph.nodesById[pendingEdgeStart.nodeId];\n    \n    // Remove the port with the matching ID\n    if (node && node.ports) {\n      node.ports = node.ports.filter(p => p.id !== pendingEdgeStart.portId);\n    }\n\n    onGraphChange(newGraph);\n    setPendingEdgeStart(null);\n  };\n\n  // --- Rendering Helpers ---\n\n  const renderPorts = (entity: Node | Container) => {\n    if (enablePorts){\n    // USE LOGIC: Calculate which ports to show (proxies or real)\n    const portsToRender = \"nodeIds\" in entity \n      ? GraphLogic.getRenderablePorts(graph, entity as Container)\n      : (entity.ports || []);\n\n    return portsToRender.map((port) => {\n      // Geometry Calculation\n      // 1. Get Absolute Position from Geometry helper\n       const absPos = getPortPosition(\n         entity,\n         port.id,\n         graph,\n         \"nodeIds\" in entity ? (entity as Container).size : { width: 100, height: 50 }\n       );\n\n       let pos = { x: absPos.x, y: absPos.y };\n       if (\"nodeIds\" in entity) { // It is a container\n           pos.x = absPos.x - entity.position.x;\n           pos.y = absPos.y - entity.position.y;\n       }\n      return (\n        <div\n          key={port.id}\n          title={port.label}\n          style={{\n            position: \"absolute\",\n            left: pos.x - 6, top: pos.y - 6,\n            width: 12, height: 12, borderRadius: \"50%\",\n            backgroundColor: \"#fff\", border: \"2px solid #333\",\n            zIndex: 100, cursor: \"pointer\",\n          }}\n          onMouseEnter={() => setHoveredPort({ nodeId: entity.id, portId: port.id })}\n          onMouseLeave={() => setHoveredPort(null)}\n          onMouseDown={(e) => {\n            e.stopPropagation();\n            setCreatingEdge({ sourceNodeId: entity.id, position: pos}); \n            setDragStartPortId(port.id);\n            setPendingSourcePortLabel(port.label); \n            setMode(\"edge-create\");\n            setDragStartMouse(getMousePos(e));\n          }}\n        />\n      );\n    });\n    }\n  };\n\n  // --- Event Handlers (on Canvas) ---\n  const handleWheel = (e: React.WheelEvent) => {\n    // If holding Ctrl, we Zoom. If not, we Pan (standard trackpad behavior)\n    if (e.ctrlKey || e.metaKey) {\n        e.preventDefault(); // Stop browser zoom\n\n        const rect = containerRef.current!.getBoundingClientRect();\n        const screenX = e.clientX - rect.left;\n        const screenY = e.clientY - rect.top;\n\n        // 1. Calculate where the mouse is in the WORLD currently\n        const worldX = (screenX - view.x) / view.zoom;\n        const worldY = (screenY - view.y) / view.zoom;\n\n        // 2. Calculate new Zoom\n        const zoomSensitivity = 0.001;\n        const delta = -e.deltaY * zoomSensitivity;\n        const newZoom = Math.min(Math.max(0.1, view.zoom * (1 + delta)), 5); // Limit 0.1x to 5x\n\n        // 3. Calculate new Pan so the mouse stays over the same world point\n        const newX = screenX - (worldX * newZoom);\n        const newY = screenY - (worldY * newZoom);\n\n        setView({ x: newX, y: newY, zoom: newZoom });\n    } else {\n        // Standard Pan (Trackpad or Shift+Scroll)\n        setView(prev => ({\n            ...prev,\n            x: prev.x - e.deltaX,\n            y: prev.y - e.deltaY\n        }));\n    }\n  };\n\n  const handleMouseDown = (e: React.MouseEvent) => {\n    // 0. PANNING START (Middle Mouse or Space + Left Click)\n    if (e.button === 1 || (e.button === 0 && e.nativeEvent.getModifierState(\"Space\"))) {\n        e.preventDefault();\n        setIsPanning(true);\n        setDragStartMouse({ x: e.clientX, y: e.clientY }); // Use raw screen coords for panning logic\n        return;\n    }\n\n    const pos = getMousePos(e);\n\n    // 1. Port Interaction\n    if (enablePorts && hoveredPort) {\n        // Logic handled in renderPorts onMouseDown\n        return;\n    }\n\n    // 2. Right Click\n    if (e.button === 2 && e.target === e.currentTarget) {\n      const hitId = GraphLogic.hitTestEntity(graph, pos);\n\n       const relPos = getRelativePos(e);\n       \n       if (!hitId) {\n           e.preventDefault();\n           setCanvasMenu({ \n               position: relPos, \n               targetId: undefined, \n               type: undefined \n           });\n           return;\n       }\n        return;\n    }\n\n    // 3. Canvas Click (Clear)\n    if (e.target === e.currentTarget) {\n        clearAllStates();\n        setMode(\"lasso\");\n        setLassoStart(pos);\n        setLassoEnd(pos);\n        setEditingEntityId(null);\n    }\n  };\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    // 0. HANDLE PANNING\n    if (isPanning && dragStartMouse) {\n        const dx = e.clientX - dragStartMouse.x;\n        const dy = e.clientY - dragStartMouse.y;\n        \n        setView(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));\n        setDragStartMouse({ x: e.clientX, y: e.clientY }); // Reset for next frame\n        return;\n    }\n\n    const mousePos = getMousePos(e);\n\n    // 1. Handle Dragging Entities\n    if (mode === \"drag\" && dragStartMouse) {\n      const dx = mousePos.x - dragStartMouse.x;\n      const dy = mousePos.y - dragStartMouse.y;\n\n      const newGraph = graph.clone();\n      let changed = false;\n\n      dragStartPositions.forEach((startPos, id) => {\n        // Update Node Positions\n        const node = newGraph.nodesById[id];\n        if (node) {\n          node.position = { x: startPos.x + dx, y: startPos.y + dy };\n          changed = true;\n        }\n        // Update Container Positions\n        const container = newGraph.containersById[id];\n        if (container) {\n          container.position = { x: startPos.x + dx, y: startPos.y + dy };\n          changed = true;\n        }\n      });\n\n      if (changed) onGraphChange(newGraph);\n    }\n\n    // 2. Handle Edge Creation (Update the \"rubber band\" line)\n    if (mode === \"edge-create\" && creatingEdge) {\n      setCreatingEdge({ ...creatingEdge, position: mousePos });\n    }\n\n    // 3. Handle Lasso\n    if (mode === \"lasso\") {\n      setLassoEnd(mousePos);\n    }\n\n    if (mode === \"resize\" && resizingState) {\n          const dx = mousePos.x - resizingState.startMouse.x;\n        const dy = mousePos.y - resizingState.startMouse.y;\n\n        // Update locally to avoid massive re-renders, or update graph directly\n        const newGraph = graph.clone();\n        const container = newGraph.containersById[resizingState.id];\n        if (container) {\n            container.size = {\n                width: Math.max(100, resizingState.startSize.width + dx),\n                height: Math.max(50, resizingState.startSize.height + dy)\n            };\n            onGraphChange(newGraph);\n        }\n    }\n  };\n\n  const handleMouseUp = (e: React.MouseEvent) => {\n    if (isPanning) {\n        setIsPanning(false);\n        setDragStartMouse(null);\n        return;\n    }\n\n    const pos = getMousePos(e);\n\n    // Inside handleMouseUp or your main event loop\n  if (mode === \"edge-create\" && creatingEdge) {\n    const targetNodeId = hoveredPort ? hoveredPort.nodeId : GraphLogic.hitTestEntity(graph, pos);\n    \n    // Only proceed if we hit a valid target different from source\n    if (targetNodeId && targetNodeId !== creatingEdge.sourceNodeId) {\n      \n      // START TRANSACTION (We might need to modify the graph multiple times)\n      let finalGraph = graph.clone();\n      let finalSourcePortId = creatingEdge.sourcePortId;\n      let finalTargetPortId = hoveredPort ? hoveredPort.portId : undefined;\n\n      // --- STEP 1: Handle Missing SOURCE Port ---\n      // User started dragging from a Node Body, not a Port\n      if (!finalSourcePortId && enablePorts) {\n         const label = window.prompt(\"Name the New Source Port:\", \"out-1\");\n         if (label) {\n           // Create port on Source Node\n           const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n           const sourceNode = finalGraph.nodesById[creatingEdge.sourceNodeId] || finalGraph.containersById[creatingEdge.sourceNodeId];\n           \n           if (!sourceNode.ports) sourceNode.ports = [];\n           sourceNode.ports.push({ id: newPortId, label });\n           \n           finalSourcePortId = newPortId; // Save for edge creation\n         } else {\n           // User cancelled source port creation -> Cancel entire operation\n           setCreatingEdge(null);\n           setMode(\"idle\");\n           return; \n         }\n      }\n\n      // --- STEP 2: Handle Missing TARGET Port ---\n      // User dropped on a Node Body, not a Port\n      if (!finalTargetPortId && enablePorts) {\n         const label = window.prompt(\"Name the New Target Port:\", \"in-1\");\n         if (label) {\n           // Create port on Target Node\n           const newPortId = `p_${crypto.randomUUID().slice(0, 4)}`;\n           const targetNode = finalGraph.nodesById[targetNodeId] || finalGraph.containersById[targetNodeId];\n           \n           if (!targetNode.ports) targetNode.ports = [];\n           targetNode.ports.push({ id: newPortId, label });\n           \n           finalTargetPortId = newPortId; // Save for edge creation\n         } else {\n            // User cancelled target port creation -> Cancel entire operation\n            setCreatingEdge(null);\n            setMode(\"idle\");\n            return;\n         }\n      }\n\n      // --- STEP 3: Create the Edge ---\n      // Only create if we have valid ports (or if we are in simple mode where ports are optional)\n      if ((!enablePorts) || (finalSourcePortId && finalTargetPortId)) {\n          const edgeId = `e_${crypto.randomUUID()}`;\n          finalGraph.edgesById[edgeId] = {\n            id: edgeId,\n            sourceNodeId: creatingEdge.sourceNodeId,\n            sourcePortId: finalSourcePortId, // Use the resolved ID\n            targetNodeId: targetNodeId,\n            targetPortId: finalTargetPortId  // Use the resolved ID\n          };\n\n          onGraphChange(finalGraph);\n      }\n    }\n\n    // Cleanup\n    setCreatingEdge(null);\n    setMode(\"idle\");\n  }\n    if (mode === \"drag\") {\n        // USE LOGIC: When dropping, check containment\n        const newGraph = graph.clone();\n        \n        // Check every node/container that was dragged\n        // We only check the \"roots\" of the drag to avoid double processing\n        dragStartPositions.forEach((_, id) => {\n             GraphLogic.assignEntityToContainer(newGraph, id);\n             // Also recompute sizes of parents that might have grown\n             const parent = newGraph.nodesById[id]?.parentId || newGraph.containersById[id]?.parentId;\n             if(parent) GraphLogic.recomputeContainerSize(newGraph, parent);\n        });\n        \n        onGraphChange(newGraph);\n        setMode(\"idle\");\n        setDragStartMouse(null);\n        setDragStartPositions(new Map());\n    }\n    \n  if (mode === \"lasso\" && lassoStart && lassoEnd) {\n      // Calculate selection box\n      const x1 = Math.min(lassoStart.x, lassoEnd.x);\n      const x2 = Math.max(lassoStart.x, lassoEnd.x);\n      const y1 = Math.min(lassoStart.y, lassoEnd.y);\n      const y2 = Math.max(lassoStart.y, lassoEnd.y);\n\n      // Don't select if the box is tiny (accidental click)\n      if (Math.abs(x2 - x1) > 5 && Math.abs(y2 - y1) > 5) {\n          const newSelectedNodes = new Set<string>();\n          const newSelectedContainers = new Set<string>();\n\n          // Find nodes inside\n          Object.values(graph.nodesById).forEach(node => {\n              if (GraphLogic.isEntityVisible(graph, node.id) &&\n                  node.position.x >= x1 && node.position.x + 100 <= x2 && // Assuming width 100\n                  node.position.y >= y1 && node.position.y + 50 <= y2) {  // Assuming height 50\n                  newSelectedNodes.add(node.id);\n              }\n          });\n\n          // Find containers inside\n          Object.values(graph.containersById).forEach(container => {\n              if (GraphLogic.isEntityVisible(graph, container.id) &&\n                  container.position.x >= x1 && container.position.x + container.size.width <= x2 &&\n                  container.position.y >= y1 && container.position.y + container.size.height <= y2) {\n                  newSelectedContainers.add(container.id);\n              }\n          });\n\n          setSelectedNodes(newSelectedNodes);\n          setSelectedContainerIds(newSelectedContainers);\n      }\n      \n      setLassoStart(null);\n      setLassoEnd(null);\n    }\n    setMode(\"idle\");\n    \n  };\n\n  return (\n    <div \n        ref={containerRef} \n        className=\"graph-canvas\" \n        style={{ \n          position: \"relative\",\n          width: \"100%\",\n          height: \"100%\",\n          overflow: \"hidden\", \n          userSelect: \"none\", \n          cursor: isPanning ? \"grabbing\" : \"default\"\n        }}\n        onWheel={handleWheel}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onContextMenu={(e) => e.preventDefault()}\n    >\n      {/* TRANSFORM LAYER */}\n      <div style={{\n          transform: `translate(${view.x}px, ${view.y}px) scale(${view.zoom})`,\n          transformOrigin: \"0 0\", // Important: Scale from top-left, we handle offset manually\n          width: \"100%\",\n          height: \"100%\",\n          position: \"absolute\",\n          top: 0,\n          left: 0\n      }}>\n\n{Object.values(graph.containersById).map(c => {\n    if (!GraphLogic.isEntityVisible(graph, c.id)) return null;\n    return (\n        <React.Fragment key={c.id}>\n            <GraphContainer \n                container={c}\n                selected={selectedContainerIds.has(c.id)}\n                onMouseDown={(e) => {\n                    e.stopPropagation();\n                    // Select logic\n                    if (!e.shiftKey) {\n                        setSelectedNodes(new Set());\n                        setSelectedContainerIds(new Set([c.id]));\n                    } else {\n                        const newSet = new Set(selectedContainerIds);\n                        newSet.has(c.id) ? newSet.delete(c.id) : newSet.add(c.id);\n                        setSelectedContainerIds(newSet);\n                    }\n                    // Start dragging\n                    setMode(\"drag\");\n                    setDragStartMouse(getMousePos(e));\n                    setDragStartPositions(GraphLogic.collectDragStartPositions([...selectedContainerIds, ...selectedNodes, c.id], new Map(), graph));\n                }}\n                onDoubleClick={(e) => {\n                    toggleContainer(c.id);\n                }}\n                onContextMenu={(e) => {}}\n                onResizeMouseDown={(e: React.MouseEvent) => {\n                  setResizingState({\n                    id: c.id,\n                    startMouse: getMousePos(e),\n                    startSize: { ...c.size }\n                  });\n                  setMode(\"resize\");\n                }}\n            >\n                {renderPorts(c)}\n            </GraphContainer>\n        </React.Fragment>\n    )\n})}\n\n        {Object.values(graph.nodesById).map(n => {\n            if (!GraphLogic.isEntityVisible(graph, n.id)) return null;\n            return (\n                    <React.Fragment key={n.id}>\n                    <GraphNode \n                        node={n}\n                        selected={selectedNodes.has(n.id)}\n                        onMouseDown={(e) => {\n                            e.stopPropagation();\n                            // Select logic\n                            if (!e.shiftKey) {\n                                setSelectedContainerIds(new Set());\n                                setSelectedNodes(new Set([n.id]));\n                            } else {\n                                const newSet = new Set(selectedNodes);\n                                newSet.has(n.id) ? newSet.delete(n.id) : newSet.add(n.id);\n                                setSelectedNodes(newSet);\n                            }\n                            \n                            // Right click check for menu\n                            if (e.button === 2) {\n                        //        setCanvasMenu({ targetId: n.id, type: \"node\", position: { x: e.clientX, y: e.clientY } });\n                              e.preventDefault();\n                              e.stopPropagation(); // Stop canvas from panning\n                              \n                              // Start Edge Creation Mode manually here\n                              const mousePos = getMousePos(e);\n                              setMode(\"edge-create\");\n                              setCreatingEdge({\n                                  sourceNodeId: n.id,\n                                  position: mousePos\n                              });\n                              createPortAndStartDrag(n);\n                              return;\n                            }\n\n                            // Start dragging\n                            setMode(\"drag\");\n                            setDragStartMouse(getMousePos(e));\n                            setDragStartPositions(GraphLogic.collectDragStartPositions([...selectedContainerIds, ...selectedNodes, n.id], new Map(), graph));\n                        }}\n                        onDoubleClick={(e: React.MouseEvent) => {\n                            e.stopPropagation();\n                            setEditingEntityId(n.id);\n                            const pos = getMousePos(e);\n                            setEditorPosition({ x: pos.x, y: pos.y });\n                        }}\n                    />\n                    {renderPorts(n)}\n                    </React.Fragment>\n            )\n        })}\n\n{/* --- SVG LAYER FOR EDGES --- */}\n        <svg\n          style={{\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            width: \"100%\",\n            height: \"100%\",\n            pointerEvents: \"none\",\n            overflow: \"visible\",\n            zIndex: 10 // Below nodes (zIndex 10) but above background\n          }}\n        >\n          {/* Helper to find where an edge should visually start/end */}\n          {(() => {\n            const getVisualPosition = (entityId: string): Vec2 | null => {\n              // 1. If the entity is directly visible, return its position\n              if (GraphLogic.isEntityVisible(graph, entityId)) {\n                return graph.nodesById[entityId]?.position || graph.containersById[entityId]?.position;\n              }\n              // 2. If hidden, look for its parent container\n              // (This is a simplified lookup; for deep nesting, you'd recurse)\n              const parent = Object.values(graph.containersById).find(c => \n                 c.nodeIds.includes(entityId) || c.childContainerIds?.includes(entityId)\n              );\n              \n              // If parent exists and is visible, snap to parent\n              if (parent && GraphLogic.isEntityVisible(graph, parent.id)) {\n                 return { \n                   x: parent.position.x + parent.size.width / 2, // Snap to center of container\n                   y: parent.position.y + parent.size.height / 2 \n                 };\n              }\n              return null;\n            };\n\n            return (\n              <>\n                {/* 1. Render Existing Edges */}\n                {Object.values(graph.edgesById).map((edge) => {\n                  const start = getVisualPosition(edge.sourceNodeId);\n                  const end = getVisualPosition(edge.targetNodeId);\n\n                  if (!start || !end) return null; // Both ends hidden deep inside collapsed structures\n\n                  return (\n                    <line\n                      key={edge.id}\n                      x1={start.x + (graph.nodesById[edge.sourceNodeId] ? 50 : 0)} // Offset center if it's a node\n                      y1={start.y + (graph.nodesById[edge.sourceNodeId] ? 25 : 0)}\n                      x2={end.x + (graph.nodesById[edge.targetNodeId] ? 50 : 0)}\n                      y2={end.y + (graph.nodesById[edge.targetNodeId] ? 25 : 0)}\n                      stroke=\"black\"\n                      strokeWidth=\"2\"\n                    />\n                  );\n                })}\n\n                {/* 2. Render Temporary \"Creating\" Edge */}\n                {mode === \"edge-create\" && creatingEdge && (\n                   <line\n                     x1={creatingEdge.position.x} // Mouse Position\n                     y1={creatingEdge.position.y}\n                     // Calculate start from the source node center\n                     x2={(() => {\n                        const n = graph.nodesById[creatingEdge.sourceNodeId];\n                        return n ? n.position.x + 50 : 0; \n                     })()}\n                     y2={(() => {\n                        const n = graph.nodesById[creatingEdge.sourceNodeId];\n                        return n ? n.position.y + 25 : 0; \n                     })()}\n                     stroke=\"black\"\n                     strokeWidth=\"2\"\n                     strokeDasharray=\"5,5\"\n                   />\n                )}\n              </>\n            );\n          })()}\n        </svg>\n\n  </div>\n        {/* UI ELEMENTS THAT SHOULD NOT ZOOM \n           (Put Context Menu or Fixed HUDs here outside the transform layer)\n        */}\n\n        {/* Lasso Selection Box */}\n        {mode === \"lasso\" && lassoStart && lassoEnd && \n          (Math.abs(lassoStart.x - lassoEnd.x) > 5 || Math.abs(lassoStart.y - lassoEnd.y) > 5) && (\n             <Lasso start={lassoStart} end={lassoEnd} />\n        )}\n\n        {editingEntityId && editorPosition && (\n             <EntityEditor \n                entityId={editingEntityId}\n                graph={graph}\n                position={editorPosition}\n                onClose={() => setEditingEntityId(null)}\n                onGraphChange={onGraphChange}\n                enablePorts={enablePorts}\n             />\n        )}\n\n    {/* --- CONTEXT MENU --- */}\n    {canvasMenu && (\n      <div\n        style={{\n          position: \"absolute\",\n          top: canvasMenu.position.y,\n          left: canvasMenu.position.x,\n          zIndex: 1000\n        }}\n      >\n      <ContextMenu\n        position={canvasMenu.position}\n        options={(() => {\n          // 1. Menu for CANVAS (Background) -> Create New Items\n          if (!canvasMenu.targetId) {\n            return [\n              {\n                label: \"Add Node\",\n                onClick: () => {\n                  const newGraph = graph.clone();\n                  const id = `n_${crypto.randomUUID().slice(0, 4)}`;\n                  newGraph.addNode({\n                    id,\n                    label: \"New Node\",\n                    position: canvasMenu.position,\n                    ports: [],\n                    size: { width: 100, height: 50}\n                  });\n                  onGraphChange(newGraph);\n                  setCanvasMenu(null); // Close menu\n                }\n              },\n              {\n                label: \"Add Container\",\n                onClick: () => {\n                  const newGraph = graph.clone();\n                  const id = `c_${crypto.randomUUID().slice(0, 4)}`;\n                  newGraph.addContainer({\n                    id,\n                    label: \"New Container\",\n                    position: canvasMenu.position,\n                    size: { width: 300, height: 200 }, // Default size\n                    nodeIds: [],\n                    childContainerIds: [],\n                    collapsed: false\n                  });\n                  onGraphChange(newGraph);\n                  setCanvasMenu(null);\n                }\n              }\n            ];\n          }\n\n          // 2. Menu for NODES\n          if (canvasMenu.type === \"node\") {\n            return [\n              {\n                label: \"Rename\",\n                onClick: () => {\n                  setEditingEntityId(canvasMenu.targetId || null);\n                  setEditorPosition(canvasMenu.position);\n                  setCanvasMenu(null);\n                }\n              },\n              {\n                label: \"Delete Node\",\n                onClick: () => {\n                  if (canvasMenu.targetId) {\n                    const newGraph = graph.clone();\n                    newGraph.removeNode(canvasMenu.targetId);\n                    onGraphChange(newGraph);\n                  }\n                  setCanvasMenu(null);\n                }\n              }\n            ];\n          }\n\n          // 3. Menu for CONTAINERS\n          if (canvasMenu.type === \"container\") {\n            return [\n              {\n                label: \"Rename\",\n                onClick: () => {\n                  setEditingEntityId(canvasMenu.targetId || null);\n                  setEditorPosition(canvasMenu.position);\n                  setCanvasMenu(null);\n                }\n              },\n              {\n                label: \"Toggle Collapse\",\n                onClick: () => {\n                  if (canvasMenu.targetId) {\n                    toggleContainer(canvasMenu.targetId);\n                  }\n                  setCanvasMenu(null);\n                }\n              },\n              {\n                label: \"Delete Container\",\n                onClick: () => {\n                  if (canvasMenu.targetId) {\n                    const newGraph = graph.clone();\n                    newGraph.removeContainer(canvasMenu.targetId);\n                    onGraphChange(newGraph);\n                  }\n                  setCanvasMenu(null);\n                }\n              }\n            ];\n          }\n\n          return []; // Fallback\n        })()}\n      />\n      </div>\n    )}\n\n    {/* Close menu if clicking elsewhere */ }\n    {canvasMenu && (\n      <div \n         style={{ position: \"fixed\", top: 0, left: 0, width: \"100%\", height: \"100%\", zIndex: 999 }} \n         onMouseDown={() => setCanvasMenu(null)} \n         onContextMenu={(e) => { e.preventDefault(); setCanvasMenu(null); }} \n      />\n    )}\n    </div>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}