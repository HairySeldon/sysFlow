{"ast":null,"code":"/**\n * Helper to safely resolve entity size.\n * Defaults to a standard node size (150x60) if width/height are missing.\n */\nconst getEntitySize = entity => {\n  var _entity$size$width, _entity$size$height;\n  // Use explicit properties if they exist, otherwise fallback defaults\n  return {\n    width: (_entity$size$width = entity.size.width) !== null && _entity$size$width !== void 0 ? _entity$size$width : 150,\n    height: (_entity$size$height = entity.size.height) !== null && _entity$size$height !== void 0 ? _entity$size$height : 60\n  };\n};\n\n/**\n * Calculates the exact (x,y) screen coordinate for a specific port on an entity.\n * Now self-contained: determines entity sizes internally.\n */\nexport const getPortPosition = (entity, portId, graph) => {\n  // 1. Resolve geometry for the source entity\n  const entitySize = getEntitySize(entity);\n  const center = getCenter(entity.position, entitySize);\n\n  // 2. Find if this port is connected to an edge\n  const connectedEdge = Object.values(graph.edgesById).find(e => e.sourceNodeId === entity.id && e.sourcePortId === portId || e.targetNodeId === entity.id && e.targetPortId === portId);\n  if (connectedEdge) {\n    // --- CASE A: Connected (Dynamic Position) ---\n    // The port should \"slide\" to face the other node.\n\n    const isSource = connectedEdge.sourceNodeId === entity.id;\n    const targetNodeId = isSource ? connectedEdge.targetNodeId : connectedEdge.sourceNodeId;\n    const targetEntity = graph.nodesById[targetNodeId] || graph.containersById[targetNodeId];\n    if (!targetEntity) return center; // Fallback\n\n    // Resolve geometry for the target entity\n    const targetSize = getEntitySize(targetEntity);\n    const targetCenter = getCenter(targetEntity.position, targetSize);\n\n    // Use intersection logic to find the point on the source entity's bounding box\n    // that faces the target center.\n    return getRectIntersection(center, entitySize, targetCenter);\n  } else {\n    // --- CASE B: Unconnected (Static Distribution) ---\n    // Distribute unconnected ports along the LEFT edge.\n\n    const unconnectedPorts = (entity.ports || []).filter(p => {\n      return !Object.values(graph.edgesById).some(e => e.sourceNodeId === entity.id && e.sourcePortId === p.id || e.targetNodeId === entity.id && e.targetPortId === p.id);\n    });\n    const index = unconnectedPorts.findIndex(p => p.id === portId);\n    if (index === -1) return center;\n\n    // Space them evenly based on the entity's actual height\n    const step = entitySize.height / (unconnectedPorts.length + 1);\n    return {\n      x: entity.position.x,\n      // Left edge\n      y: entity.position.y + step * (index + 1)\n    };\n  }\n};\n\n/**\n * Calculates the intersection point between a line (from center to target)\n * and the bounding box of the source node.\n */\nexport const getRectIntersection = (center, size, target) => {\n  const dx = target.x - center.x;\n  const dy = target.y - center.y;\n\n  // Avoid division by zero\n  if (dx === 0 && dy === 0) return {\n    ...center\n  };\n\n  // Half dimensions\n  const hw = size.width / 2;\n  const hh = size.height / 2;\n\n  // Calculate the \"scale\" needed to stretch the vector (dx, dy)\n  // until it hits the box wall.\n  const scaleX = hw / Math.abs(dx);\n  const scaleY = hh / Math.abs(dy);\n  const scale = Math.min(scaleX, scaleY);\n  return {\n    x: center.x + dx * scale,\n    y: center.y + dy * scale\n  };\n};\n\n// Helper to get center of a node/container\nexport const getCenter = (pos, size) => ({\n  x: pos.x + size.width / 2,\n  y: pos.y + size.height / 2\n});","map":{"version":3,"names":["getEntitySize","entity","_entity$size$width","_entity$size$height","width","size","height","getPortPosition","portId","graph","entitySize","center","getCenter","position","connectedEdge","Object","values","edgesById","find","e","sourceNodeId","id","sourcePortId","targetNodeId","targetPortId","isSource","targetEntity","nodesById","containersById","targetSize","targetCenter","getRectIntersection","unconnectedPorts","ports","filter","p","some","index","findIndex","step","length","x","y","target","dx","dy","hw","hh","scaleX","Math","abs","scaleY","scale","min","pos"],"sources":["/home/belac/sysFlow/src/utils/Geometry.ts"],"sourcesContent":["import { Entity, Vec2, ID } from \"../models/Entity\";\nimport { GraphModel } from \"../models/GraphModel\";\n\n/**\n * Helper to safely resolve entity size.\n * Defaults to a standard node size (150x60) if width/height are missing.\n */\nconst getEntitySize = (entity: Entity): { width: number; height: number } => {\n  // Use explicit properties if they exist, otherwise fallback defaults\n  return {\n    width: entity.size.width ?? 150,\n    height: entity.size.height ?? 60\n  };\n};\n\n/**\n * Calculates the exact (x,y) screen coordinate for a specific port on an entity.\n * Now self-contained: determines entity sizes internally.\n */\nexport const getPortPosition = (\n  entity: Entity,\n  portId: ID,\n  graph: GraphModel\n): Vec2 => {\n  // 1. Resolve geometry for the source entity\n  const entitySize = getEntitySize(entity);\n  const center = getCenter(entity.position, entitySize);\n\n  // 2. Find if this port is connected to an edge\n  const connectedEdge = Object.values(graph.edgesById).find(\n    (e) =>\n      (e.sourceNodeId === entity.id && e.sourcePortId === portId) ||\n      (e.targetNodeId === entity.id && e.targetPortId === portId)\n  );\n\n  if (connectedEdge) {\n    // --- CASE A: Connected (Dynamic Position) ---\n    // The port should \"slide\" to face the other node.\n\n    const isSource = connectedEdge.sourceNodeId === entity.id;\n    const targetNodeId = isSource ? connectedEdge.targetNodeId : connectedEdge.sourceNodeId;\n    const targetEntity = graph.nodesById[targetNodeId] || graph.containersById[targetNodeId];\n\n    if (!targetEntity) return center; // Fallback\n\n    // Resolve geometry for the target entity\n    const targetSize = getEntitySize(targetEntity);\n    const targetCenter = getCenter(targetEntity.position, targetSize);\n\n    // Use intersection logic to find the point on the source entity's bounding box\n    // that faces the target center.\n    return getRectIntersection(center, entitySize, targetCenter);\n  } else {\n    // --- CASE B: Unconnected (Static Distribution) ---\n    // Distribute unconnected ports along the LEFT edge.\n\n    const unconnectedPorts = (entity.ports || []).filter((p) => {\n      return !Object.values(graph.edgesById).some(\n        (e) =>\n          (e.sourceNodeId === entity.id && e.sourcePortId === p.id) ||\n          (e.targetNodeId === entity.id && e.targetPortId === p.id)\n      );\n    });\n\n    const index = unconnectedPorts.findIndex((p) => p.id === portId);\n    if (index === -1) return center; \n\n    // Space them evenly based on the entity's actual height\n    const step = entitySize.height / (unconnectedPorts.length + 1);\n    return {\n      x: entity.position.x, // Left edge\n      y: entity.position.y + step * (index + 1),\n    };\n  }\n};\n\n/**\n * Calculates the intersection point between a line (from center to target)\n * and the bounding box of the source node.\n */\nexport const getRectIntersection = (\n  center: Vec2,\n  size: { width: number; height: number },\n  target: Vec2\n): Vec2 => {\n  const dx = target.x - center.x;\n  const dy = target.y - center.y;\n\n  // Avoid division by zero\n  if (dx === 0 && dy === 0) return { ...center };\n\n  // Half dimensions\n  const hw = size.width / 2;\n  const hh = size.height / 2;\n\n  // Calculate the \"scale\" needed to stretch the vector (dx, dy)\n  // until it hits the box wall.\n  const scaleX = hw / Math.abs(dx);\n  const scaleY = hh / Math.abs(dy);\n\n  const scale = Math.min(scaleX, scaleY);\n\n  return {\n    x: center.x + dx * scale,\n    y: center.y + dy * scale,\n  };\n};\n\n// Helper to get center of a node/container\nexport const getCenter = (\n  pos: Vec2,\n  size: { width: number; height: number }\n): Vec2 => ({\n  x: pos.x + size.width / 2,\n  y: pos.y + size.height / 2,\n});\n"],"mappings":"AAGA;AACA;AACA;AACA;AACA,MAAMA,aAAa,GAAIC,MAAc,IAAwC;EAAA,IAAAC,kBAAA,EAAAC,mBAAA;EAC3E;EACA,OAAO;IACLC,KAAK,GAAAF,kBAAA,GAAED,MAAM,CAACI,IAAI,CAACD,KAAK,cAAAF,kBAAA,cAAAA,kBAAA,GAAI,GAAG;IAC/BI,MAAM,GAAAH,mBAAA,GAAEF,MAAM,CAACI,IAAI,CAACC,MAAM,cAAAH,mBAAA,cAAAA,mBAAA,GAAI;EAChC,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMI,eAAe,GAAGA,CAC7BN,MAAc,EACdO,MAAU,EACVC,KAAiB,KACR;EACT;EACA,MAAMC,UAAU,GAAGV,aAAa,CAACC,MAAM,CAAC;EACxC,MAAMU,MAAM,GAAGC,SAAS,CAACX,MAAM,CAACY,QAAQ,EAAEH,UAAU,CAAC;;EAErD;EACA,MAAMI,aAAa,GAAGC,MAAM,CAACC,MAAM,CAACP,KAAK,CAACQ,SAAS,CAAC,CAACC,IAAI,CACtDC,CAAC,IACCA,CAAC,CAACC,YAAY,KAAKnB,MAAM,CAACoB,EAAE,IAAIF,CAAC,CAACG,YAAY,KAAKd,MAAM,IACzDW,CAAC,CAACI,YAAY,KAAKtB,MAAM,CAACoB,EAAE,IAAIF,CAAC,CAACK,YAAY,KAAKhB,MACxD,CAAC;EAED,IAAIM,aAAa,EAAE;IACjB;IACA;;IAEA,MAAMW,QAAQ,GAAGX,aAAa,CAACM,YAAY,KAAKnB,MAAM,CAACoB,EAAE;IACzD,MAAME,YAAY,GAAGE,QAAQ,GAAGX,aAAa,CAACS,YAAY,GAAGT,aAAa,CAACM,YAAY;IACvF,MAAMM,YAAY,GAAGjB,KAAK,CAACkB,SAAS,CAACJ,YAAY,CAAC,IAAId,KAAK,CAACmB,cAAc,CAACL,YAAY,CAAC;IAExF,IAAI,CAACG,YAAY,EAAE,OAAOf,MAAM,CAAC,CAAC;;IAElC;IACA,MAAMkB,UAAU,GAAG7B,aAAa,CAAC0B,YAAY,CAAC;IAC9C,MAAMI,YAAY,GAAGlB,SAAS,CAACc,YAAY,CAACb,QAAQ,EAAEgB,UAAU,CAAC;;IAEjE;IACA;IACA,OAAOE,mBAAmB,CAACpB,MAAM,EAAED,UAAU,EAAEoB,YAAY,CAAC;EAC9D,CAAC,MAAM;IACL;IACA;;IAEA,MAAME,gBAAgB,GAAG,CAAC/B,MAAM,CAACgC,KAAK,IAAI,EAAE,EAAEC,MAAM,CAAEC,CAAC,IAAK;MAC1D,OAAO,CAACpB,MAAM,CAACC,MAAM,CAACP,KAAK,CAACQ,SAAS,CAAC,CAACmB,IAAI,CACxCjB,CAAC,IACCA,CAAC,CAACC,YAAY,KAAKnB,MAAM,CAACoB,EAAE,IAAIF,CAAC,CAACG,YAAY,KAAKa,CAAC,CAACd,EAAE,IACvDF,CAAC,CAACI,YAAY,KAAKtB,MAAM,CAACoB,EAAE,IAAIF,CAAC,CAACK,YAAY,KAAKW,CAAC,CAACd,EAC1D,CAAC;IACH,CAAC,CAAC;IAEF,MAAMgB,KAAK,GAAGL,gBAAgB,CAACM,SAAS,CAAEH,CAAC,IAAKA,CAAC,CAACd,EAAE,KAAKb,MAAM,CAAC;IAChE,IAAI6B,KAAK,KAAK,CAAC,CAAC,EAAE,OAAO1B,MAAM;;IAE/B;IACA,MAAM4B,IAAI,GAAG7B,UAAU,CAACJ,MAAM,IAAI0B,gBAAgB,CAACQ,MAAM,GAAG,CAAC,CAAC;IAC9D,OAAO;MACLC,CAAC,EAAExC,MAAM,CAACY,QAAQ,CAAC4B,CAAC;MAAE;MACtBC,CAAC,EAAEzC,MAAM,CAACY,QAAQ,CAAC6B,CAAC,GAAGH,IAAI,IAAIF,KAAK,GAAG,CAAC;IAC1C,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMN,mBAAmB,GAAGA,CACjCpB,MAAY,EACZN,IAAuC,EACvCsC,MAAY,KACH;EACT,MAAMC,EAAE,GAAGD,MAAM,CAACF,CAAC,GAAG9B,MAAM,CAAC8B,CAAC;EAC9B,MAAMI,EAAE,GAAGF,MAAM,CAACD,CAAC,GAAG/B,MAAM,CAAC+B,CAAC;;EAE9B;EACA,IAAIE,EAAE,KAAK,CAAC,IAAIC,EAAE,KAAK,CAAC,EAAE,OAAO;IAAE,GAAGlC;EAAO,CAAC;;EAE9C;EACA,MAAMmC,EAAE,GAAGzC,IAAI,CAACD,KAAK,GAAG,CAAC;EACzB,MAAM2C,EAAE,GAAG1C,IAAI,CAACC,MAAM,GAAG,CAAC;;EAE1B;EACA;EACA,MAAM0C,MAAM,GAAGF,EAAE,GAAGG,IAAI,CAACC,GAAG,CAACN,EAAE,CAAC;EAChC,MAAMO,MAAM,GAAGJ,EAAE,GAAGE,IAAI,CAACC,GAAG,CAACL,EAAE,CAAC;EAEhC,MAAMO,KAAK,GAAGH,IAAI,CAACI,GAAG,CAACL,MAAM,EAAEG,MAAM,CAAC;EAEtC,OAAO;IACLV,CAAC,EAAE9B,MAAM,CAAC8B,CAAC,GAAGG,EAAE,GAAGQ,KAAK;IACxBV,CAAC,EAAE/B,MAAM,CAAC+B,CAAC,GAAGG,EAAE,GAAGO;EACrB,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMxC,SAAS,GAAGA,CACvB0C,GAAS,EACTjD,IAAuC,MAC7B;EACVoC,CAAC,EAAEa,GAAG,CAACb,CAAC,GAAGpC,IAAI,CAACD,KAAK,GAAG,CAAC;EACzBsC,CAAC,EAAEY,GAAG,CAACZ,CAAC,GAAGrC,IAAI,CAACC,MAAM,GAAG;AAC3B,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}