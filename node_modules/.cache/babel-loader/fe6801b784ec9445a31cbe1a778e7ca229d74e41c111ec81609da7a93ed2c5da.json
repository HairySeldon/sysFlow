{"ast":null,"code":"// Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph, id) => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container === null || container === void 0 ? void 0 : container.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph, pos) => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 && pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width && pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nconst isContainerEntity = entity => {\n  return entity && (Array.isArray(entity.nodeIds) || Array.isArray(entity.childContainerIds));\n};\nexport const recomputeContainerSize = (graph, id) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n    const n = graph.getNode(nId);\n    if (!n) return;\n    hasChildren = true;\n    minX = Math.min(minX, n.position.x);\n    minY = Math.min(minY, n.position.y);\n    maxX = Math.max(maxX, n.position.x + 100);\n    maxY = Math.max(maxY, n.position.y + 50);\n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n    const ch = graph.containersById[childId];\n    if (!ch) return;\n    hasChildren = true;\n    minX = Math.min(minX, ch.position.x);\n    minY = Math.min(minY, ch.position.y);\n    maxX = Math.max(maxX, ch.position.x + ch.size.width);\n    maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n  if (!hasChildren) return;\n  const requiredWidth = maxX - minX + CONTAINER_PADDING * 2;\n  const requiredHeight = maxY - minY + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\nexport const assignEntityToContainer = (graph, entityId, skipContainerId) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n  for (const c of containers) {\n    if (c.id === entityId || skipContainerId && c.id === skipContainerId) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside = entity.position.x >= c.position.x && entity.position.y >= c.position.y && entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width && entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n          const oldParent = graph.containersById[entity.parentId];\n          if (oldParent) {\n            var _oldParent$childConta;\n            if (isContainer) oldParent.childContainerIds = (_oldParent$childConta = oldParent.childContainerIds) === null || _oldParent$childConta === void 0 ? void 0 : _oldParent$childConta.filter(id => id !== entityId);else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n          }\n        }\n\n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n    const prev = graph.containersById[entity.parentId];\n    if (prev) {\n      var _prev$childContainerI;\n      if (isContainer) prev.childContainerIds = (_prev$childContainerI = prev.childContainerIds) === null || _prev$childContainerI === void 0 ? void 0 : _prev$childContainerI.filter(id => id !== entityId);else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n    }\n    entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph, container) => {\n  const containerPorts = container.ports || [];\n  if (!container.collapsed) return containerPorts;\n  const proxyPorts = [];\n  const childNodeIds = new Set(container.nodeIds || []);\n  Object.values(graph.edgesById).forEach(edge => {\n    const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n    const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n    // Edge goes OUT\n    if (isSourceInside && !isTargetInside) {\n      var _sourceNode$ports;\n      const sourceNode = graph.nodesById[edge.sourceNodeId];\n      const internalPort = sourceNode === null || sourceNode === void 0 ? void 0 : (_sourceNode$ports = sourceNode.ports) === null || _sourceNode$ports === void 0 ? void 0 : _sourceNode$ports.find(p => p.id === edge.sourcePortId);\n      proxyPorts.push({\n        id: edge.sourcePortId || `proxy-src-${edge.id}`,\n        label: internalPort ? `${sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.label}.${internalPort.label}` : \"out\"\n      });\n    }\n    // Edge comes IN\n    else if (!isSourceInside && isTargetInside) {\n      var _targetNode$ports;\n      const targetNode = graph.nodesById[edge.targetNodeId];\n      const internalPort = targetNode === null || targetNode === void 0 ? void 0 : (_targetNode$ports = targetNode.ports) === null || _targetNode$ports === void 0 ? void 0 : _targetNode$ports.find(p => p.id === edge.targetPortId);\n      proxyPorts.push({\n        id: edge.targetPortId || `proxy-tgt-${edge.id}`,\n        label: internalPort ? `${targetNode === null || targetNode === void 0 ? void 0 : targetNode.label}.${internalPort.label}` : \"in\"\n      });\n    }\n  });\n  return [...containerPorts, ...proxyPorts];\n};\nexport const collectDragStartPositions = (rootIds, map, graph) => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...n.position\n        });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...c.position\n        });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n        c.nodeIds.forEach(nid => {\n          const child = graph.nodesById[nid];\n          if (child && !map.has(nid)) map.set(nid, {\n            ...child.position\n          });\n        });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};","map":{"version":3,"names":["CONTAINER_HEADER_HEIGHT","CONTAINER_PADDING","MIN_CONTAINER_WIDTH","MIN_CONTAINER_HEIGHT","isEntityVisible","graph","id","node","nodesById","container","containersById","currentParentId","parentId","parent","collapsed","hitTestEntity","pos","nodes","Object","values","containers","n","x","position","y","c","reverse","size","width","height","isContainerEntity","entity","Array","isArray","nodeIds","childContainerIds","recomputeContainerSize","minX","Infinity","minY","maxX","maxY","hasChildren","forEach","nId","getNode","Math","min","max","childId","ch","requiredWidth","requiredHeight","assignEntityToContainer","entityId","skipContainerId","isContainer","inside","oldParent","_oldParent$childConta","filter","includes","push","prev","_prev$childContainerI","undefined","getRenderablePorts","containerPorts","ports","proxyPorts","childNodeIds","Set","edgesById","edge","isSourceInside","has","sourceNodeId","isTargetInside","targetNodeId","_sourceNode$ports","sourceNode","internalPort","find","p","sourcePortId","label","_targetNode$ports","targetNode","targetPortId","collectDragStartPositions","rootIds","map","set","nid","child"],"sources":["/home/belac/sysFlow/src/utils/GraphLogic.ts"],"sourcesContent":["import { GraphModel } from \"../models/GraphModel\";\nimport { Container } from \"../models/Container\";\nimport { Node } from \"../models/Node\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { getPortPosition } from \"./Geometry\"; // Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph: GraphModel, id: ID): boolean => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container?.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph: GraphModel, pos: Vec2): ID | null => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 &&\n        pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width &&\n        pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nconst isContainerEntity = (entity: any): boolean => {\n  return (\n    entity &&\n    (Array.isArray(entity.nodeIds) || Array.isArray(entity.childContainerIds))\n  );\n};\n\nexport const recomputeContainerSize = (graph: GraphModel, id: ID) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n      const n = graph.getNode(nId);\n      if (!n) return;\n      hasChildren = true;\n      minX = Math.min(minX, n.position.x);\n      minY = Math.min(minY, n.position.y);\n      maxX = Math.max(maxX, n.position.x + 100);\n      maxY = Math.max(maxY, n.position.y + 50); \n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n      const ch = graph.containersById[childId];\n      if (!ch) return;\n      hasChildren = true;\n      minX = Math.min(minX, ch.position.x);\n      minY = Math.min(minY, ch.position.y);\n      maxX = Math.max(maxX, ch.position.x + ch.size.width);\n      maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n\n  if (!hasChildren) return; \n\n  const requiredWidth = (maxX - minX) + CONTAINER_PADDING * 2;\n  const requiredHeight = (maxY - minY) + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\n\nexport const assignEntityToContainer = (graph: GraphModel, entityId: ID, skipContainerId?: ID) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n\n  for (const c of containers) {\n    if (c.id === entityId || (skipContainerId && c.id === skipContainerId)) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside =\n      entity.position.x >= c.position.x &&\n      entity.position.y >= c.position.y &&\n      entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width &&\n      entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n             const oldParent = graph.containersById[entity.parentId];\n             if (oldParent) {\n                 if(isContainer) oldParent.childContainerIds = oldParent.childContainerIds?.filter(id => id !== entityId);\n                 else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n             }\n        }\n        \n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n      const prev = graph.containersById[entity.parentId];\n      if (prev) {\n        if (isContainer) prev.childContainerIds = prev.childContainerIds?.filter(id => id !== entityId);\n        else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n      }\n      entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph: GraphModel, container: Container): Port[] => {\n    const containerPorts = container.ports || [];\n    if (!container.collapsed) return containerPorts;\n\n    const proxyPorts: Port[] = [];\n    const childNodeIds = new Set(container.nodeIds || []); \n\n    Object.values(graph.edgesById).forEach(edge => {\n      const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n      const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n      // Edge goes OUT\n      if (isSourceInside && !isTargetInside) {\n        const sourceNode = graph.nodesById[edge.sourceNodeId];\n        const internalPort = sourceNode?.ports?.find(p => p.id === edge.sourcePortId);\n        proxyPorts.push({\n          id: edge.sourcePortId || `proxy-src-${edge.id}`, \n          label: internalPort ? `${sourceNode?.label}.${internalPort.label}` : \"out\"\n        });\n      } \n      // Edge comes IN\n      else if (!isSourceInside && isTargetInside) {\n        const targetNode = graph.nodesById[edge.targetNodeId];\n        const internalPort = targetNode?.ports?.find(p => p.id === edge.targetPortId);\n        proxyPorts.push({\n          id: edge.targetPortId || `proxy-tgt-${edge.id}`, \n          label: internalPort ? `${targetNode?.label}.${internalPort.label}` : \"in\"\n        });\n      }\n    });\n\n    return [...containerPorts, ...proxyPorts];\n};\n\nexport const collectDragStartPositions = (\n  rootIds: ID[],\n  map: Map<ID, Vec2>,\n  graph: GraphModel\n): Map<ID, Vec2> => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, { ...n.position });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, { ...c.position });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n          c.nodeIds.forEach(nid => {\n              const child = graph.nodesById[nid];\n              if(child && !map.has(nid)) map.set(nid, {...child.position});\n          });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}