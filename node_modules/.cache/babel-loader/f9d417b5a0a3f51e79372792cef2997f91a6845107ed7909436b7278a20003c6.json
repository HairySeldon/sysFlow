{"ast":null,"code":"var _jsxFileName = \"/home/belac/sysFlow/src/components/GraphPortLayer.tsx\";\nimport React from \"react\";\nimport * as GraphLogic from \"../utils/GraphLogic\";\nimport { getPortPosition } from \"../utils/Geometry\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const GraphPortLayer = ({\n  graph,\n  enablePorts,\n  onHoverPort,\n  onPortMouseDown\n}) => {\n  if (!enablePorts) return null;\n  const renderEntityPorts = entity => {\n    // 1. UPDATED: Always use the entity's own ports (node OR container)\n    // If you previously relied on getRenderablePorts for special logic, you can merge arrays here,\n    // but for \"Ports on Containers\", we usually want the explicit ports from the model.\n    const portsToRender = entity.ports || [];\n    return portsToRender.map(port => {\n      // 2. UPDATED: Calculate Absolute Position for everything\n      const absPos = getPortPosition(entity, port.id, graph);\n\n      // 3. REMOVED: The logic that subtracted entity.position.\n      // Since GraphPortLayer is an overlay on the canvas, we want Absolute positions for everyone.\n\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        title: port.label,\n        style: {\n          position: \"absolute\",\n          left: absPos.x - 6,\n          // Center the 12px dot\n          top: absPos.y - 6,\n          width: 12,\n          height: 12,\n          borderRadius: \"50%\",\n          backgroundColor: \"#fff\",\n          border: \"2px solid #333\",\n          zIndex: 10,\n          cursor: \"crosshair\"\n          // distinct color for container ports if you want visual debugging:\n          // borderColor: \"nodeIds\" in entity ? \"blue\" : \"#333\" \n        },\n        onMouseEnter: () => onHoverPort({\n          nodeId: entity.id,\n          portId: port.id\n        }),\n        onMouseLeave: () => onHoverPort(null),\n        onMouseDown: e => {\n          e.stopPropagation(); // Good practice to stop canvas drag\n          onPortMouseDown(e, entity.id, port.id, port.label, absPos);\n        }\n      }, port.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 41,\n        columnNumber: 9\n      }, this);\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [Object.values(graph.containersById).map(c => {\n      if (!GraphLogic.isEntityVisible(graph, c.id)) return null;\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: renderEntityPorts(c)\n      }, `ports-${c.id}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 74,\n        columnNumber: 17\n      }, this);\n    }), Object.values(graph.nodesById).map(n => {\n      if (!GraphLogic.isEntityVisible(graph, n.id)) return null;\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: renderEntityPorts(n)\n      }, `ports-${n.id}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 80,\n        columnNumber: 17\n      }, this);\n    })]\n  }, void 0, true);\n};\n_c = GraphPortLayer;\nvar _c;\n$RefreshReg$(_c, \"GraphPortLayer\");","map":{"version":3,"names":["React","GraphLogic","getPortPosition","jsxDEV","_jsxDEV","Fragment","_Fragment","GraphPortLayer","graph","enablePorts","onHoverPort","onPortMouseDown","renderEntityPorts","entity","portsToRender","ports","map","port","absPos","id","title","label","style","position","left","x","top","y","width","height","borderRadius","backgroundColor","border","zIndex","cursor","onMouseEnter","nodeId","portId","onMouseLeave","onMouseDown","e","stopPropagation","fileName","_jsxFileName","lineNumber","columnNumber","children","Object","values","containersById","c","isEntityVisible","nodesById","n","_c","$RefreshReg$"],"sources":["/home/belac/sysFlow/src/components/GraphPortLayer.tsx"],"sourcesContent":["import React from \"react\";\nimport { GraphModel } from \"../models/GraphModel\";\nimport * as GraphLogic from \"../utils/GraphLogic\"; \nimport { getPortPosition } from \"../utils/Geometry\"; \nimport { ID, Vec2 } from \"../models/Entity\";\n\ninterface GraphPortLayerProps {\n  graph: GraphModel;\n  enablePorts: boolean;\n  hoveredPort: { nodeId: ID; portId: ID } | null;\n  onHoverPort: (info: { nodeId: ID; portId: ID } | null) => void;\n  onPortMouseDown: (e: React.MouseEvent, nodeId: ID, portId: ID, label: string, position: Vec2) => void;\n}\n\nexport const GraphPortLayer: React.FC<GraphPortLayerProps> = ({\n  graph,\n  enablePorts,\n  onHoverPort,\n  onPortMouseDown,\n}) => {\n  if (!enablePorts) return null;\n\n  const renderEntityPorts = (entity: any) => {\n    // 1. UPDATED: Always use the entity's own ports (node OR container)\n    // If you previously relied on getRenderablePorts for special logic, you can merge arrays here,\n    // but for \"Ports on Containers\", we usually want the explicit ports from the model.\n    const portsToRender = entity.ports || [];\n\n    return portsToRender.map((port: any) => {\n      // 2. UPDATED: Calculate Absolute Position for everything\n      const absPos = getPortPosition(\n        entity,\n        port.id,\n        graph,\n      );\n\n      // 3. REMOVED: The logic that subtracted entity.position.\n      // Since GraphPortLayer is an overlay on the canvas, we want Absolute positions for everyone.\n      \n      return (\n        <div\n          key={port.id}\n          title={port.label}\n          style={{\n            position: \"absolute\",\n            left: absPos.x - 6, // Center the 12px dot\n            top: absPos.y - 6,\n            width: 12,\n            height: 12,\n            borderRadius: \"50%\",\n            backgroundColor: \"#fff\",\n            border: \"2px solid #333\",\n            zIndex: 10,\n            cursor: \"crosshair\",\n            // distinct color for container ports if you want visual debugging:\n            // borderColor: \"nodeIds\" in entity ? \"blue\" : \"#333\" \n          }}\n          onMouseEnter={() => onHoverPort({ nodeId: entity.id, portId: port.id })}\n          onMouseLeave={() => onHoverPort(null)}\n          onMouseDown={(e) => {\n            e.stopPropagation(); // Good practice to stop canvas drag\n            onPortMouseDown(e, entity.id, port.id, port.label, absPos);\n          }}\n        />\n      );\n    });\n  };\n\n  return (\n    <>\n      {/* Container Ports */}\n      {Object.values(graph.containersById).map((c) => {\n         if (!GraphLogic.isEntityVisible(graph, c.id)) return null;\n         return <React.Fragment key={`ports-${c.id}`}>{renderEntityPorts(c)}</React.Fragment>;\n      })}\n\n      {/* Node Ports */}\n      {Object.values(graph.nodesById).map((n) => {\n         if (!GraphLogic.isEntityVisible(graph, n.id)) return null;\n         return <React.Fragment key={`ports-${n.id}`}>{renderEntityPorts(n)}</React.Fragment>;\n      })}\n    </>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}