{"ast":null,"code":"export class GraphModel {\n  constructor() {\n    this.nodesById = {};\n    this.containersById = {};\n    this.edgesById = {};\n  }\n  addNode(node) {\n    this.nodesById[node.id] = node;\n  }\n  addContainer(container) {\n    this.containersById[container.id] = container;\n  }\n  addEdge(edge) {\n    this.edgesById[edge.id] = edge;\n  }\n  getNode(id) {\n    return this.nodesById[id];\n  }\n  getContainer(id) {\n    return this.containersById[id];\n  }\n  moveNode(id, pos) {\n    const n = this.getNode(id);\n    if (n) n.position = pos;\n  }\n  moveContainer(id, pos) {\n    const c = this.getContainer(id);\n    if (c) c.position = pos;\n  }\n  removeNode(id) {\n    delete this.nodesById[id];\n  }\n  removeEdge(id) {\n    delete this.edgesById[id];\n  }\n  addPortToEntity(entityId, port) {\n    // 1. Try to find it as a Node\n    const node = this.nodesById[entityId];\n    if (node) {\n      if (!node.ports) node.ports = []; // Initialize if missing\n      node.ports.push(port);\n      return;\n    }\n\n    // 2. Try to find it as a Container\n    const container = this.containersById[entityId];\n    if (container) {\n      if (!container.ports) container.ports = []; // Initialize if missing\n      container.ports.push(port);\n      return;\n    }\n    console.warn(`Could not find entity with ID ${entityId} to add port.`);\n  }\n  removePortAndEdges(entityId, portId) {\n    // 1. Find the Entity\n    const entity = this.nodesById[entityId] || this.containersById[entityId];\n    if (!entity || !entity.ports) return;\n\n    // 2. Remove the Port from the Entity\n    entity.ports = entity.ports.filter(p => p.id !== portId);\n\n    // 3. Remove all Edges connected to this Port\n    const edgeIdsToRemove = [];\n    Object.values(this.edgesById).forEach(edge => {\n      // Check if edge connects to this specific port\n      if (edge.sourceNodeId === entityId && edge.sourcePortId === portId || edge.targetNodeId === entityId && edge.targetPortId === portId) {\n        edgeIdsToRemove.push(edge.id);\n      }\n    });\n\n    // Delete the identified edges\n    edgeIdsToRemove.forEach(id => {\n      delete this.edgesById[id];\n    });\n  }\n  removeContainerRecursive(id) {\n    var _c$childContainerIds;\n    const c = this.containersById[id];\n    if (!c) return;\n    // delete child nodes\n    c.nodeIds.forEach(nid => this.removeNode(nid));\n    // delete child containers recursively\n    (_c$childContainerIds = c.childContainerIds) === null || _c$childContainerIds === void 0 ? void 0 : _c$childContainerIds.forEach(cid => this.removeContainerRecursive(cid));\n    // delete container itself\n    delete this.containersById[id];\n  }\n  toggleContainerCollapsed(id) {\n    const c = this.getContainer(id);\n    if (c) c.collapsed = !c.collapsed;\n  }\n\n  // Inside GraphModel.ts\n  clone() {\n    const copy = new GraphModel(); // Or however you construct it\n    // Copy data\n    copy.nodesById = {\n      ...this.nodesById\n    };\n    copy.containersById = {\n      ...this.containersById\n    };\n    copy.edgesById = {\n      ...this.edgesById\n    };\n    return copy;\n  }\n  exportJSON() {\n    return JSON.stringify({\n      nodes: this.nodesById,\n      containers: this.containersById,\n      edges: this.edgesById\n    });\n  }\n}","map":{"version":3,"names":["GraphModel","constructor","nodesById","containersById","edgesById","addNode","node","id","addContainer","container","addEdge","edge","getNode","getContainer","moveNode","pos","n","position","moveContainer","c","removeNode","removeEdge","addPortToEntity","entityId","port","ports","push","console","warn","removePortAndEdges","portId","entity","filter","p","edgeIdsToRemove","Object","values","forEach","sourceNodeId","sourcePortId","targetNodeId","targetPortId","removeContainerRecursive","_c$childContainerIds","nodeIds","nid","childContainerIds","cid","toggleContainerCollapsed","collapsed","clone","copy","exportJSON","JSON","stringify","nodes","containers","edges"],"sources":["/home/belac/sysFlow/src/models/GraphModel.ts"],"sourcesContent":["import { Node } from \"./Node\";\nimport { Container } from \"./Container\";\nimport { Edge } from \"./Edge\";\nimport { Port, ID, Vec2 } from \"./Entity\";\n\nexport class GraphModel {\n  nodesById: Record<ID, Node> = {};\n  containersById: Record<ID, Container> = {};\n  edgesById: Record<ID, Edge> = {};\n\n  addNode(node: Node) { this.nodesById[node.id] = node; }\n  addContainer(container: Container) { this.containersById[container.id] = container; }\n  addEdge(edge: Edge) { this.edgesById[edge.id] = edge; }\n\n  getNode(id: ID) { return this.nodesById[id]; }\n  getContainer(id: ID) { return this.containersById[id]; }\n\n  moveNode(id: ID, pos: Vec2) { const n = this.getNode(id); if (n) n.position = pos; }\n  moveContainer(id: ID, pos: Vec2) { const c = this.getContainer(id); if (c) c.position = pos; }\n\n  removeNode(id: ID) { delete this.nodesById[id]; }\n  removeEdge(id: ID) { delete this.edgesById[id]; }\n\n  addPortToEntity(entityId: string, port: Port): void {\n    // 1. Try to find it as a Node\n    const node = this.nodesById[entityId];\n    if (node) {\n      if (!node.ports) node.ports = []; // Initialize if missing\n      node.ports.push(port);\n      return;\n    }\n\n    // 2. Try to find it as a Container\n    const container = this.containersById[entityId];\n    if (container) {\n      if (!container.ports) container.ports = []; // Initialize if missing\n      container.ports.push(port);\n      return;\n    }\n\n    console.warn(`Could not find entity with ID ${entityId} to add port.`);\n  }\n\n  removePortAndEdges(entityId: string, portId: string): void {\n    // 1. Find the Entity\n    const entity = this.nodesById[entityId] || this.containersById[entityId];\n    if (!entity || !entity.ports) return;\n\n    // 2. Remove the Port from the Entity\n    entity.ports = entity.ports.filter(p => p.id !== portId);\n\n    // 3. Remove all Edges connected to this Port\n    const edgeIdsToRemove: string[] = [];\n    Object.values(this.edgesById).forEach(edge => {\n      // Check if edge connects to this specific port\n      if (\n        (edge.sourceNodeId === entityId && edge.sourcePortId === portId) ||\n        (edge.targetNodeId === entityId && edge.targetPortId === portId)\n      ) {\n        edgeIdsToRemove.push(edge.id);\n      }\n    });\n\n    // Delete the identified edges\n    edgeIdsToRemove.forEach(id => {\n      delete this.edgesById[id];\n    });\n  }\n\n  removeContainerRecursive(id: ID) {\n    const c = this.containersById[id];\n    if (!c) return;\n    // delete child nodes\n    c.nodeIds.forEach(nid => this.removeNode(nid));\n    // delete child containers recursively\n    c.childContainerIds?.forEach(cid => this.removeContainerRecursive(cid));\n    // delete container itself\n    delete this.containersById[id];\n  }\n\n  toggleContainerCollapsed(id: ID) {\n    const c = this.getContainer(id);\n    if (c) c.collapsed = !c.collapsed;\n  }\n\n  // Inside GraphModel.ts\n  clone(): GraphModel {\n    const copy = new GraphModel(); // Or however you construct it\n    // Copy data\n    copy.nodesById = { ...this.nodesById };\n    copy.containersById = { ...this.containersById };\n    copy.edgesById = { ...this.edgesById };\n    return copy;\n  }\n\n  exportJSON() {\n    return JSON.stringify({\n      nodes: this.nodesById,\n      containers: this.containersById,\n      edges: this.edgesById\n    });\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}