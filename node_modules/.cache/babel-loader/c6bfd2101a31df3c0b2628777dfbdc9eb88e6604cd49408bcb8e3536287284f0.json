{"ast":null,"code":"// Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph, id) => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container === null || container === void 0 ? void 0 : container.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph, pos) => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 && pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width && pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nconst isContainerEntity = entity => {\n  return entity && (Array.isArray(entity.nodeIds) || Array.isArray(entity.childContainerIds));\n};\nexport const recomputeContainerSize = (graph, id) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n    const n = graph.getNode(nId);\n    if (!n) return;\n    hasChildren = true;\n    minX = Math.min(minX, n.position.x);\n    minY = Math.min(minY, n.position.y);\n    maxX = Math.max(maxX, n.position.x + 100);\n    maxY = Math.max(maxY, n.position.y + 50);\n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n    const ch = graph.containersById[childId];\n    if (!ch) return;\n    hasChildren = true;\n    minX = Math.min(minX, ch.position.x);\n    minY = Math.min(minY, ch.position.y);\n    maxX = Math.max(maxX, ch.position.x + ch.size.width);\n    maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n  if (!hasChildren) return;\n  const requiredWidth = maxX - minX + CONTAINER_PADDING * 2;\n  const requiredHeight = maxY - minY + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\nexport const assignEntityToContainer = (graph, entityId, skipContainerId) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n  const isContainer = isContainerEntity(entity);\n\n  // 1. Find ALL valid candidate containers\n  const candidates = Object.values(graph.containersById).filter(c => {\n    // Basic validation checks\n    if (c.id === entityId || skipContainerId && c.id === skipContainerId) return false;\n    if (!isEntityVisible(graph, c.id)) return false;\n\n    // Geometric Check: Is entity inside 'c'?\n    const inside = entity.position.x >= c.position.x && entity.position.y >= c.position.y && entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width && entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n    return inside;\n  });\n\n  // 2. SORT candidates by Area (Smallest -> Largest)\n  // The smallest container that fits is always the most immediate parent.\n  candidates.sort((a, b) => a.size.width * a.size.height - b.size.width * b.size.height);\n\n  // 3. Pick the winner (if any)\n  const bestParent = candidates[0];\n\n  // ---------------------------------------------------------\n  // 4. Perform the Re-Assignment (Same logic as before)\n  // ---------------------------------------------------------\n\n  // Check if we are moving TO a new parent, or moving FROM a parent to 'undefined' (root)\n  if (bestParent) {\n    if (entity.parentId !== bestParent.id) {\n      // Remove from OLD parent\n      removeFromParent(graph, entity, isContainer);\n\n      // Add to NEW parent (bestParent)\n      entity.parentId = bestParent.id;\n      if (isContainer) {\n        if (!bestParent.childContainerIds) bestParent.childContainerIds = [];\n        if (!bestParent.childContainerIds.includes(entityId)) bestParent.childContainerIds.push(entityId);\n      } else {\n        if (!bestParent.nodeIds.includes(entityId)) bestParent.nodeIds.push(entityId);\n      }\n    }\n  } else {\n    // No valid parent found -> Move to Root\n    if (entity.parentId) {\n      removeFromParent(graph, entity, isContainer);\n      entity.parentId = undefined;\n    }\n  }\n};\n\n// Helper to keep code clean (extracting your lines 121-127 & 144-148)\nconst removeFromParent = (graph, entity, isContainer) => {\n  if (!entity.parentId) return;\n  const oldParent = graph.containersById[entity.parentId];\n  if (oldParent) {\n    if (isContainer) {\n      var _oldParent$childConta;\n      oldParent.childContainerIds = (_oldParent$childConta = oldParent.childContainerIds) === null || _oldParent$childConta === void 0 ? void 0 : _oldParent$childConta.filter(id => id !== entity.id);\n    } else {\n      oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entity.id);\n    }\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph, container) => {\n  const containerPorts = container.ports || [];\n  if (!container.collapsed) return containerPorts;\n  const proxyPorts = [];\n  const childNodeIds = new Set(container.nodeIds || []);\n  Object.values(graph.edgesById).forEach(edge => {\n    const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n    const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n    // Edge goes OUT\n    if (isSourceInside && !isTargetInside) {\n      var _sourceNode$ports;\n      const sourceNode = graph.nodesById[edge.sourceNodeId];\n      const internalPort = sourceNode === null || sourceNode === void 0 ? void 0 : (_sourceNode$ports = sourceNode.ports) === null || _sourceNode$ports === void 0 ? void 0 : _sourceNode$ports.find(p => p.id === edge.sourcePortId);\n      proxyPorts.push({\n        id: edge.sourcePortId || `proxy-src-${edge.id}`,\n        label: internalPort ? `${sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.label}.${internalPort.label}` : \"out\"\n      });\n    }\n    // Edge comes IN\n    else if (!isSourceInside && isTargetInside) {\n      var _targetNode$ports;\n      const targetNode = graph.nodesById[edge.targetNodeId];\n      const internalPort = targetNode === null || targetNode === void 0 ? void 0 : (_targetNode$ports = targetNode.ports) === null || _targetNode$ports === void 0 ? void 0 : _targetNode$ports.find(p => p.id === edge.targetPortId);\n      proxyPorts.push({\n        id: edge.targetPortId || `proxy-tgt-${edge.id}`,\n        label: internalPort ? `${targetNode === null || targetNode === void 0 ? void 0 : targetNode.label}.${internalPort.label}` : \"in\"\n      });\n    }\n  });\n  return [...containerPorts, ...proxyPorts];\n};\nexport const collectDragStartPositions = (rootIds, map, graph) => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...n.position\n        });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...c.position\n        });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n        c.nodeIds.forEach(nid => {\n          const child = graph.nodesById[nid];\n          if (child && !map.has(nid)) map.set(nid, {\n            ...child.position\n          });\n        });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};","map":{"version":3,"names":["CONTAINER_HEADER_HEIGHT","CONTAINER_PADDING","MIN_CONTAINER_WIDTH","MIN_CONTAINER_HEIGHT","isEntityVisible","graph","id","node","nodesById","container","containersById","currentParentId","parentId","parent","collapsed","hitTestEntity","pos","nodes","Object","values","containers","n","x","position","y","c","reverse","size","width","height","isContainerEntity","entity","Array","isArray","nodeIds","childContainerIds","recomputeContainerSize","minX","Infinity","minY","maxX","maxY","hasChildren","forEach","nId","getNode","Math","min","max","childId","ch","requiredWidth","requiredHeight","assignEntityToContainer","entityId","skipContainerId","isContainer","candidates","filter","inside","sort","a","b","bestParent","removeFromParent","includes","push","undefined","oldParent","_oldParent$childConta","getRenderablePorts","containerPorts","ports","proxyPorts","childNodeIds","Set","edgesById","edge","isSourceInside","has","sourceNodeId","isTargetInside","targetNodeId","_sourceNode$ports","sourceNode","internalPort","find","p","sourcePortId","label","_targetNode$ports","targetNode","targetPortId","collectDragStartPositions","rootIds","map","set","nid","child"],"sources":["/home/belac/sysFlow/src/utils/GraphLogic.ts"],"sourcesContent":["import { GraphModel } from \"../models/GraphModel\";\nimport { Container } from \"../models/Container\";\nimport { Node } from \"../models/Node\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { getPortPosition } from \"./Geometry\"; // Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph: GraphModel, id: ID): boolean => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container?.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph: GraphModel, pos: Vec2): ID | null => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 &&\n        pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width &&\n        pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nconst isContainerEntity = (entity: any): boolean => {\n  return (\n    entity &&\n    (Array.isArray(entity.nodeIds) || Array.isArray(entity.childContainerIds))\n  );\n};\n\nexport const recomputeContainerSize = (graph: GraphModel, id: ID) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n      const n = graph.getNode(nId);\n      if (!n) return;\n      hasChildren = true;\n      minX = Math.min(minX, n.position.x);\n      minY = Math.min(minY, n.position.y);\n      maxX = Math.max(maxX, n.position.x + 100);\n      maxY = Math.max(maxY, n.position.y + 50); \n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n      const ch = graph.containersById[childId];\n      if (!ch) return;\n      hasChildren = true;\n      minX = Math.min(minX, ch.position.x);\n      minY = Math.min(minY, ch.position.y);\n      maxX = Math.max(maxX, ch.position.x + ch.size.width);\n      maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n\n  if (!hasChildren) return; \n\n  const requiredWidth = (maxX - minX) + CONTAINER_PADDING * 2;\n  const requiredHeight = (maxY - minY) + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\n\nexport const assignEntityToContainer = (graph: GraphModel, entityId: ID, skipContainerId?: ID) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n\n  const isContainer = isContainerEntity(entity);\n  \n  // 1. Find ALL valid candidate containers\n  const candidates = Object.values(graph.containersById).filter(c => {\n      // Basic validation checks\n      if (c.id === entityId || (skipContainerId && c.id === skipContainerId)) return false;\n      if (!isEntityVisible(graph, c.id)) return false; \n\n      // Geometric Check: Is entity inside 'c'?\n      const inside =\n        entity.position.x >= c.position.x &&\n        entity.position.y >= c.position.y &&\n        entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width &&\n        entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n      \n      return inside;\n  });\n\n  // 2. SORT candidates by Area (Smallest -> Largest)\n  // The smallest container that fits is always the most immediate parent.\n  candidates.sort((a, b) => \n    (a.size.width * a.size.height) - (b.size.width * b.size.height)\n  );\n\n  // 3. Pick the winner (if any)\n  const bestParent = candidates[0];\n\n  // ---------------------------------------------------------\n  // 4. Perform the Re-Assignment (Same logic as before)\n  // ---------------------------------------------------------\n  \n  // Check if we are moving TO a new parent, or moving FROM a parent to 'undefined' (root)\n  if (bestParent) {\n    if (entity.parentId !== bestParent.id) {\n        // Remove from OLD parent\n        removeFromParent(graph, entity, isContainer);\n\n        // Add to NEW parent (bestParent)\n        entity.parentId = bestParent.id;\n        if (isContainer) {\n           if (!bestParent.childContainerIds) bestParent.childContainerIds = [];\n           if (!bestParent.childContainerIds.includes(entityId)) bestParent.childContainerIds.push(entityId);\n        } else {\n           if (!bestParent.nodeIds.includes(entityId)) bestParent.nodeIds.push(entityId);\n        }\n    }\n  } else {\n     // No valid parent found -> Move to Root\n     if (entity.parentId) {\n         removeFromParent(graph, entity, isContainer);\n         entity.parentId = undefined;\n     }\n  }\n}\n\n// Helper to keep code clean (extracting your lines 121-127 & 144-148)\nconst removeFromParent = (graph: GraphModel, entity: any, isContainer: boolean) => {\n    if (!entity.parentId) return;\n    const oldParent = graph.containersById[entity.parentId];\n    if (oldParent) {\n        if (isContainer) {\n            oldParent.childContainerIds = oldParent.childContainerIds?.filter((id: string) => id !== entity.id);\n        } else {\n            oldParent.nodeIds = oldParent.nodeIds.filter((id: string) => id !== entity.id);\n        }\n    }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph: GraphModel, container: Container): Port[] => {\n    const containerPorts = container.ports || [];\n    if (!container.collapsed) return containerPorts;\n\n    const proxyPorts: Port[] = [];\n    const childNodeIds = new Set(container.nodeIds || []); \n\n    Object.values(graph.edgesById).forEach(edge => {\n      const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n      const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n      // Edge goes OUT\n      if (isSourceInside && !isTargetInside) {\n        const sourceNode = graph.nodesById[edge.sourceNodeId];\n        const internalPort = sourceNode?.ports?.find(p => p.id === edge.sourcePortId);\n        proxyPorts.push({\n          id: edge.sourcePortId || `proxy-src-${edge.id}`, \n          label: internalPort ? `${sourceNode?.label}.${internalPort.label}` : \"out\"\n        });\n      } \n      // Edge comes IN\n      else if (!isSourceInside && isTargetInside) {\n        const targetNode = graph.nodesById[edge.targetNodeId];\n        const internalPort = targetNode?.ports?.find(p => p.id === edge.targetPortId);\n        proxyPorts.push({\n          id: edge.targetPortId || `proxy-tgt-${edge.id}`, \n          label: internalPort ? `${targetNode?.label}.${internalPort.label}` : \"in\"\n        });\n      }\n    });\n\n    return [...containerPorts, ...proxyPorts];\n};\n\nexport const collectDragStartPositions = (\n  rootIds: ID[],\n  map: Map<ID, Vec2>,\n  graph: GraphModel\n): Map<ID, Vec2> => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, { ...n.position });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, { ...c.position });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n          c.nodeIds.forEach(nid => {\n              const child = graph.nodesById[nid];\n              if(child && !map.has(nid)) map.set(nid, {...child.position});\n          });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}