{"ast":null,"code":"// Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\nconst selectAll = () => {\n  const allNodeIds = new Set(Object.keys(graph.nodesById));\n  const allContainerIds = new Set(Object.keys(graph.containersById));\n  setSelectedNodes(allNodeIds);\n  setSelectedContainerIds(allContainerIds);\n};\nconst deleteSelected = () => {\n  if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n  const newGraph = graph.clone();\n  selectedNodes.forEach(id => newGraph.removeNode(id));\n  selectedContainerIds.forEach(id => newGraph.removeContainer(id));\n  onGraphChange(newGraph);\n  clearAllStates();\n};\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph, id) => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container === null || container === void 0 ? void 0 : container.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph, pos) => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 && pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width && pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nexport const isContainerEntity = e => {\n  return e.size !== undefined;\n};\nexport const recomputeContainerSize = (graph, id) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n    const n = graph.getNode(nId);\n    if (!n) return;\n    hasChildren = true;\n    minX = Math.min(minX, n.position.x);\n    minY = Math.min(minY, n.position.y);\n    maxX = Math.max(maxX, n.position.x + 100);\n    maxY = Math.max(maxY, n.position.y + 50);\n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n    const ch = graph.containersById[childId];\n    if (!ch) return;\n    hasChildren = true;\n    minX = Math.min(minX, ch.position.x);\n    minY = Math.min(minY, ch.position.y);\n    maxX = Math.max(maxX, ch.position.x + ch.size.width);\n    maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n  if (!hasChildren) return;\n  const requiredWidth = maxX - minX + CONTAINER_PADDING * 2;\n  const requiredHeight = maxY - minY + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\nexport const assignEntityToContainer = (graph, entityId, skipContainerId) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n  for (const c of containers) {\n    if (c.id === entityId || skipContainerId && c.id === skipContainerId) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside = entity.position.x >= c.position.x && entity.position.y >= c.position.y && entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width && entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n          const oldParent = graph.containersById[entity.parentId];\n          if (oldParent) {\n            var _oldParent$childConta;\n            if (isContainer) oldParent.childContainerIds = (_oldParent$childConta = oldParent.childContainerIds) === null || _oldParent$childConta === void 0 ? void 0 : _oldParent$childConta.filter(id => id !== entityId);else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n          }\n        }\n\n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n    const prev = graph.containersById[entity.parentId];\n    if (prev) {\n      var _prev$childContainerI;\n      if (isContainer) prev.childContainerIds = (_prev$childContainerI = prev.childContainerIds) === null || _prev$childContainerI === void 0 ? void 0 : _prev$childContainerI.filter(id => id !== entityId);else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n    }\n    entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph, container) => {\n  const containerPorts = container.ports || [];\n  if (!container.collapsed) return containerPorts;\n  const proxyPorts = [];\n  const childNodeIds = new Set(container.nodeIds || []);\n  Object.values(graph.edgesById).forEach(edge => {\n    const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n    const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n    // Edge goes OUT\n    if (isSourceInside && !isTargetInside) {\n      var _sourceNode$ports;\n      const sourceNode = graph.nodesById[edge.sourceNodeId];\n      const internalPort = sourceNode === null || sourceNode === void 0 ? void 0 : (_sourceNode$ports = sourceNode.ports) === null || _sourceNode$ports === void 0 ? void 0 : _sourceNode$ports.find(p => p.id === edge.sourcePortId);\n      proxyPorts.push({\n        id: edge.sourcePortId || `proxy-src-${edge.id}`,\n        label: internalPort ? `${sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.label}.${internalPort.label}` : \"out\"\n      });\n    }\n    // Edge comes IN\n    else if (!isSourceInside && isTargetInside) {\n      var _targetNode$ports;\n      const targetNode = graph.nodesById[edge.targetNodeId];\n      const internalPort = targetNode === null || targetNode === void 0 ? void 0 : (_targetNode$ports = targetNode.ports) === null || _targetNode$ports === void 0 ? void 0 : _targetNode$ports.find(p => p.id === edge.targetPortId);\n      proxyPorts.push({\n        id: edge.targetPortId || `proxy-tgt-${edge.id}`,\n        label: internalPort ? `${targetNode === null || targetNode === void 0 ? void 0 : targetNode.label}.${internalPort.label}` : \"in\"\n      });\n    }\n  });\n  return [...containerPorts, ...proxyPorts];\n};\nexport const collectDragStartPositions = (rootIds, map, graph) => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...n.position\n        });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, {\n          ...c.position\n        });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n        c.nodeIds.forEach(nid => {\n          const child = graph.nodesById[nid];\n          if (child && !map.has(nid)) map.set(nid, {\n            ...child.position\n          });\n        });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};","map":{"version":3,"names":["CONTAINER_HEADER_HEIGHT","CONTAINER_PADDING","MIN_CONTAINER_WIDTH","MIN_CONTAINER_HEIGHT","selectAll","allNodeIds","Set","Object","keys","graph","nodesById","allContainerIds","containersById","setSelectedNodes","setSelectedContainerIds","deleteSelected","selectedNodes","size","selectedContainerIds","newGraph","clone","forEach","id","removeNode","removeContainer","onGraphChange","clearAllStates","isEntityVisible","node","container","currentParentId","parentId","parent","collapsed","hitTestEntity","pos","nodes","values","containers","n","x","position","y","c","reverse","width","height","isContainerEntity","e","undefined","recomputeContainerSize","minX","Infinity","minY","maxX","maxY","hasChildren","nodeIds","nId","getNode","Math","min","max","childContainerIds","childId","ch","requiredWidth","requiredHeight","assignEntityToContainer","entityId","skipContainerId","entity","isContainer","inside","oldParent","_oldParent$childConta","filter","includes","push","prev","_prev$childContainerI","getRenderablePorts","containerPorts","ports","proxyPorts","childNodeIds","edgesById","edge","isSourceInside","has","sourceNodeId","isTargetInside","targetNodeId","_sourceNode$ports","sourceNode","internalPort","find","p","sourcePortId","label","_targetNode$ports","targetNode","targetPortId","collectDragStartPositions","rootIds","map","set","nid","child"],"sources":["/home/belac/sysFlow/src/utils/GraphLogic.ts"],"sourcesContent":["import { GraphModel } from \"../models/GraphModel\";\nimport { Container } from \"../models/Container\";\nimport { Node } from \"../models/Node\";\nimport { Entity, ID, Vec2, Port } from \"../models/Entity\";\nimport { getPortPosition } from \"./Geometry\"; // Assuming you have this from before\n\n// Constants\nexport const CONTAINER_HEADER_HEIGHT = 32;\nexport const CONTAINER_PADDING = 24;\nexport const MIN_CONTAINER_WIDTH = 160;\nexport const MIN_CONTAINER_HEIGHT = 120;\n\nconst selectAll = () => {\n    const allNodeIds = new Set(Object.keys(graph.nodesById));\n    const allContainerIds = new Set(Object.keys(graph.containersById));\n    setSelectedNodes(allNodeIds);\n    setSelectedContainerIds(allContainerIds);\n};\n\nconst deleteSelected = () => {\n    if (selectedNodes.size === 0 && selectedContainerIds.size === 0) return;\n\n    const newGraph = graph.clone();\n    selectedNodes.forEach((id) => newGraph.removeNode(id));\n    selectedContainerIds.forEach((id) => newGraph.removeContainer(id));\n\n    onGraphChange(newGraph);\n\n    clearAllStates();\n};\n\n\n// --- Visibility & Traversal ---\n\nexport const isEntityVisible = (graph: GraphModel, id: ID): boolean => {\n  // 1. Resolve Entity\n  const node = graph.nodesById[id];\n  const container = graph.containersById[id];\n  let currentParentId = node ? node.parentId : container?.parentId;\n\n  // 2. Walk up ancestor chain\n  while (currentParentId) {\n    const parent = graph.containersById[currentParentId];\n    if (!parent) break;\n    if (parent.collapsed) return false; // Hidden!\n    currentParentId = parent.parentId;\n  }\n  return true;\n};\n\n// --- Hit Testing ---\n\nexport const hitTestEntity = (graph: GraphModel, pos: Vec2): ID | null => {\n  const nodes = Object.values(graph.nodesById);\n  const containers = Object.values(graph.containersById);\n\n  // 1. Check Nodes\n  for (const n of nodes) {\n    if (!isEntityVisible(graph, n.id)) continue;\n    if (pos.x >= n.position.x && pos.x <= n.position.x + 100 &&\n        pos.y >= n.position.y && pos.y <= n.position.y + 50) return n.id;\n  }\n\n  // 2. Check Containers (Variable size)\n  // We reverse to click the \"topmost\" container first if they overlap\n  for (const c of containers.reverse()) {\n    if (!isEntityVisible(graph, c.id)) continue;\n    if (pos.x >= c.position.x && pos.x <= c.position.x + c.size.width &&\n        pos.y >= c.position.y && pos.y <= c.position.y + c.size.height) return c.id;\n  }\n  return null;\n};\n\n// --- Container Logic ---\n\nexport const isContainerEntity = (e: Entity): e is Container => {\n  return (e as Container).size !== undefined;\n};\n\nexport const recomputeContainerSize = (graph: GraphModel, id: ID) => {\n  const c = graph.containersById[id];\n  if (!c || c.collapsed) return;\n\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  let hasChildren = false;\n\n  // Check Nodes\n  c.nodeIds.forEach(nId => {\n      const n = graph.getNode(nId);\n      if (!n) return;\n      hasChildren = true;\n      minX = Math.min(minX, n.position.x);\n      minY = Math.min(minY, n.position.y);\n      maxX = Math.max(maxX, n.position.x + 100);\n      maxY = Math.max(maxY, n.position.y + 50); \n  });\n\n  // Check Child Containers\n  (c.childContainerIds || []).forEach(childId => {\n      const ch = graph.containersById[childId];\n      if (!ch) return;\n      hasChildren = true;\n      minX = Math.min(minX, ch.position.x);\n      minY = Math.min(minY, ch.position.y);\n      maxX = Math.max(maxX, ch.position.x + ch.size.width);\n      maxY = Math.max(maxY, ch.position.y + ch.size.height);\n  });\n\n  if (!hasChildren) return; \n\n  const requiredWidth = (maxX - minX) + CONTAINER_PADDING * 2;\n  const requiredHeight = (maxY - minY) + CONTAINER_PADDING * 2 + CONTAINER_HEADER_HEIGHT;\n\n  c.size.width = Math.max(c.size.width, requiredWidth, MIN_CONTAINER_WIDTH);\n  c.size.height = Math.max(c.size.height, requiredHeight, MIN_CONTAINER_HEIGHT);\n};\n\nexport const assignEntityToContainer = (graph: GraphModel, entityId: ID, skipContainerId?: ID) => {\n  const entity = graph.nodesById[entityId] || graph.containersById[entityId];\n  if (!entity) return;\n\n  const isContainer = isContainerEntity(entity);\n  const containers = Object.values(graph.containersById);\n\n  for (const c of containers) {\n    if (c.id === entityId || (skipContainerId && c.id === skipContainerId)) continue;\n    if (!isEntityVisible(graph, c.id)) continue; // Can't drop into a hidden container\n\n    const inside =\n      entity.position.x >= c.position.x &&\n      entity.position.y >= c.position.y &&\n      entity.position.x + (isContainer ? entity.size.width : 100) <= c.position.x + c.size.width &&\n      entity.position.y + (isContainer ? entity.size.height : 50) <= c.position.y + c.size.height;\n\n    if (inside) {\n      if (entity.parentId !== c.id) {\n        // Remove from old parent\n        if (entity.parentId) {\n             const oldParent = graph.containersById[entity.parentId];\n             if (oldParent) {\n                 if(isContainer) oldParent.childContainerIds = oldParent.childContainerIds?.filter(id => id !== entityId);\n                 else oldParent.nodeIds = oldParent.nodeIds.filter(id => id !== entityId);\n             }\n        }\n        \n        // Add to new parent\n        entity.parentId = c.id;\n        if (isContainer) {\n          if (!c.childContainerIds) c.childContainerIds = [];\n          if (!c.childContainerIds.includes(entityId)) c.childContainerIds.push(entityId);\n        } else {\n          if (!c.nodeIds.includes(entityId)) c.nodeIds.push(entityId);\n        }\n      }\n      return;\n    }\n  }\n\n  // If we get here, it's not inside any container. Clear parent.\n  if (entity.parentId) {\n      const prev = graph.containersById[entity.parentId];\n      if (prev) {\n        if (isContainer) prev.childContainerIds = prev.childContainerIds?.filter(id => id !== entityId);\n        else prev.nodeIds = prev.nodeIds.filter(id => id !== entityId);\n      }\n      entity.parentId = undefined;\n  }\n};\n\n// --- Port Proxy Logic ---\n\nexport const getRenderablePorts = (graph: GraphModel, container: Container): Port[] => {\n    const containerPorts = container.ports || [];\n    if (!container.collapsed) return containerPorts;\n\n    const proxyPorts: Port[] = [];\n    const childNodeIds = new Set(container.nodeIds || []); \n\n    Object.values(graph.edgesById).forEach(edge => {\n      const isSourceInside = childNodeIds.has(edge.sourceNodeId);\n      const isTargetInside = childNodeIds.has(edge.targetNodeId);\n\n      // Edge goes OUT\n      if (isSourceInside && !isTargetInside) {\n        const sourceNode = graph.nodesById[edge.sourceNodeId];\n        const internalPort = sourceNode?.ports?.find(p => p.id === edge.sourcePortId);\n        proxyPorts.push({\n          id: edge.sourcePortId || `proxy-src-${edge.id}`, \n          label: internalPort ? `${sourceNode?.label}.${internalPort.label}` : \"out\"\n        });\n      } \n      // Edge comes IN\n      else if (!isSourceInside && isTargetInside) {\n        const targetNode = graph.nodesById[edge.targetNodeId];\n        const internalPort = targetNode?.ports?.find(p => p.id === edge.targetPortId);\n        proxyPorts.push({\n          id: edge.targetPortId || `proxy-tgt-${edge.id}`, \n          label: internalPort ? `${targetNode?.label}.${internalPort.label}` : \"in\"\n        });\n      }\n    });\n\n    return [...containerPorts, ...proxyPorts];\n};\n\nexport const collectDragStartPositions = (\n  rootIds: ID[],\n  map: Map<ID, Vec2>,\n  graph: GraphModel\n): Map<ID, Vec2> => {\n  for (const id of rootIds) {\n    // 1. Try finding a Node\n    const n = graph.nodesById[id];\n    if (n) {\n      if (!map.has(id)) {\n        map.set(id, { ...n.position });\n      }\n      continue;\n    }\n\n    // 2. Try finding a Container\n    const c = graph.containersById[id];\n    if (c) {\n      if (!map.has(id)) {\n        map.set(id, { ...c.position });\n      }\n\n      // Recursively add children nodes\n      if (c.nodeIds) {\n          c.nodeIds.forEach(nid => {\n              const child = graph.nodesById[nid];\n              if(child && !map.has(nid)) map.set(nid, {...child.position});\n          });\n      }\n      // Recursively add child containers\n      if (c.childContainerIds) {\n        collectDragStartPositions(c.childContainerIds, map, graph);\n      }\n    }\n  }\n  return map;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}